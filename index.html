<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDGly+ Beta v0.1</title>
    <link rel="icon" type="image/svg+xml" href="/images/ask-ed_OLD.svg">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .logo-container {
                flex-direction: column;
                text-align: center;
                gap: 10px;
            }
            
            .logo-svg {
                width: 120px !important;
                height: 120px !important;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 10px;
            }
            
            .dashboard {
                grid-template-columns: 1fr !important;
            }
            
            .dashboard-card {
                padding: 15px !important;
            }
            
            .form-container {
                padding: 15px;
            }
            
            .form-row {
                flex-direction: column;
            }
            
            .records-list {
                padding: 10px;
            }
            
            .record-card {
                flex-direction: column !important;
                align-items: flex-start !important;
            }
            
            .analytics-grid,
            .charts-grid {
                grid-template-columns: 1fr !important;
            }
            
            
            .sortable-table {
                font-size: 12px;
            }
            
            .sortable-table th,
            .sortable-table td {
                padding: 8px 4px !important;
            }
            
            .templates-grid,
            .wizard-card {
                grid-template-columns: 1fr !important;
            }
        }
        
        @media (max-width: 480px) {
            .stats-grid {
                grid-template-columns: 1fr !important;
            }
            
            .stat-card {
                padding: 15px;
            }
            
            .stat-number {
                font-size: 2em;
            }
            
            h1 {
                font-size: 1.5em !important;
            }
            
            h2 {
                font-size: 1.2em !important;
            }
            
            .refresh-btn,
            .delete-btn {
                padding: 8px 12px;
                font-size: 12px;
            }
            
            .chat-input-container {
                flex-direction: column;
            }
            
            .chat-input {
                width: 100%;
                margin-bottom: 10px;
            }
        }
        
        /* Touch-friendly improvements */
        @media (hover: none) and (pointer: coarse) {
            button,
            .refresh-btn,
            .delete-btn,
            .dashboard-card {
                min-height: 44px;
                min-width: 44px;
            }
            
            input,
            select,
            textarea {
                font-size: 16px; /* Prevents zoom on iOS */
            }
        }
        
        /* Landscape mobile optimization */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f3f3f3; /* Windows 11 Light theme background */
            min-height: 100vh;
            padding: 0;
            margin: 0;
            color: #202020;
            overflow: hidden;
        }
        
        body.dark-theme {
            background: #202020; /* Windows 11 Dark theme background */
            color: #e0e0e0;
        }
        
        /* Refined Scrollbar Styles */
        /* Webkit browsers (Chrome, Edge, Safari) */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        
        /* Light theme scrollbar */
        ::-webkit-scrollbar-thumb {
            background: rgba(100, 100, 100, 0.25);
            border-radius: 4px;
            transition: background 0.2s ease;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(100, 100, 100, 0.4);
        }
        
        /* Dark theme scrollbar */
        body.dark-theme ::-webkit-scrollbar-thumb {
            background: rgba(180, 180, 180, 0.2);
        }
        
        body.dark-theme ::-webkit-scrollbar-thumb:hover {
            background: rgba(180, 180, 180, 0.35);
        }
        
        /* Ensure scrollbars don't interfere with layout */
        ::-webkit-scrollbar-corner {
            background: transparent;
        }
        
        /* Firefox */
        * {
            scrollbar-width: thin;
            scrollbar-color: rgba(100, 100, 100, 0.25) transparent;
        }
        
        body.dark-theme * {
            scrollbar-color: rgba(180, 180, 180, 0.2) transparent;
        }

        .container {
            width: 100%;
            height: 100vh;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Windows-style Title Bar */
        .title-bar {
            background: #1e1e1e;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0;
            -webkit-app-region: drag;
            user-select: none;
            z-index: 10001;
        }
        
        body.dark-theme .title-bar {
            background: #1e1e1e;
        }
        
        .title-bar-title {
            color: #ffffff;
            font-size: 12px;
            padding: 0 12px;
            font-weight: 400;
            flex: 1;
        }
        
        body.dark-theme .title-bar-title {
            color: #ffffff;
        }
        
        .window-controls {
            display: flex;
            -webkit-app-region: no-drag;
            height: 100%;
        }
        
        .window-control {
            width: 46px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #e0e0e0;
            font-size: 12px;
            transition: background-color 0.15s;
            border: 1px solid #3e3e42;
            background: #3e3e42;
            padding: 0;
            margin-left: -1px;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
            box-shadow: none;
            text-decoration: none;
        }
        
        .window-control:first-of-type {
            margin-left: 0;
        }
        
        .window-control:hover {
            background: #4e4e52;
        }
        
        .window-control.close:hover {
            background: #4e4e52;
        }

        .window-control:focus,
        .window-control:active {
            background: #3e3e42;
            box-shadow: none;
        }
        
        body.dark-theme .window-control {
            color: #e0e0e0;
            border-color: #3e3e42;
            background: #3e3e42;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
            box-shadow: none;
        }
        
        body.dark-theme .window-control:hover {
            background: #4e4e52;
        }
        
        body.dark-theme .window-control.close:hover {
            background: #4e4e52;
        }

        body.dark-theme .window-control:focus,
        body.dark-theme .window-control:active {
            background: #3e3e42;
            box-shadow: none;
        }
        
        /* Dialog Backdrop */
        .dialog-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10009;
            display: none;
        }
        
        /* Windows-style Dialog */
        .windows-dialog {
            position: fixed;
            background: #ffffff;
            border: 1px solid #d0d0d0;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            display: none;
            flex-direction: column;
            z-index: 10010;
            min-width: 400px;
            min-height: 300px;
            max-width: 90vw;
            max-height: 90vh;
        }
        
        body.dark-theme .windows-dialog {
            background: #2d2d30;
            border-color: #3e3e42;
        }
        
        body.dark-theme .dialog-body {
            color: #e0e0e0;
        }
        
        body.dark-theme .dialog-body label {
            color: #cccccc;
        }
        
        body.dark-theme .dialog-body select,
        body.dark-theme .dialog-body input {
            background: #1e1e1e;
            border-color: #3e3e42;
            color: #e0e0e0;
        }
        
        body.dark-theme .dialog-body .empty-state {
            color: #808080;
        }
        
        /* Repository Modal Filters Dark Mode */
        body.dark-theme .repository-modal-filters {
            background: #252526 !important;
            border-bottom-color: #3e3e42 !important;
        }
        
        body.dark-theme .repository-modal-search,
        body.dark-theme .repository-modal-filter-select {
            background: #1e1e1e !important;
            border-color: #3e3e42 !important;
            color: #e0e0e0 !important;
        }
        
        body.dark-theme .repository-modal-filter-label {
            color: #cccccc !important;
        }
        
        body.dark-theme .repository-modal-filter-count {
            color: #808080 !important;
        }

        .repository-tabs {
            display: flex;
            gap: 6px;
            border-bottom: 1px solid #3e3e42;
            margin-bottom: 12px;
            padding-bottom: 8px;
        }

        .repository-tab-btn {
            background: #1a1a1a;
            color: #c0c0c0;
            border: 1px solid rgba(128, 128, 128, 0.3);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }

        .repository-tab-btn.active {
            background: #3e3e3e;
            color: #ffffff;
            border-color: #5a5a5f;
        }

        .repository-tab-btn:hover {
            background: #2a2a2a;
        }

        .repository-tab-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .repository-tab-panel {
            display: none;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }

        .repository-tab-panel.active {
            display: block;
        }

        .repository-properties-toolbar {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .repository-properties-toolbar input,
        .repository-properties-toolbar select,
        .repository-properties-toolbar textarea {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            color: #e0e0e0;
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 12px;
        }

        .repository-property-row {
            display: flex;
            gap: 12px;
            align-items: flex-start;
            padding: 10px 0;
            border-bottom: 1px solid #3e3e42;
        }

        .repository-property-icon {
            position: relative;
            width: 32px;
            height: 32px;
            flex: 0 0 32px;
        }

        .repository-property-icon img {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        .repository-property-gear {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #ffffff;
            color: #000000;
            font-size: 11px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 2px rgba(0,0,0,0.4);
        }

        .repository-property-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .repository-property-actions button[disabled] {
            opacity: 0.45;
            cursor: not-allowed;
        }
        
        .dialog-title-bar {
            background: #1e1e1e;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0;
            cursor: move;
            user-select: none;
            border-bottom: 1px solid #808080;
        }
        
        body.dark-theme .dialog-title-bar {
            background: #1e1e1e;
            border-bottom-color: #808080;
        }
        
        .dialog-title {
            color: #ffffff;
            font-size: 12px;
            padding: 0 12px;
            font-weight: 400;
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .dialog-controls {
            display: flex;
            height: 100%;
        }
        
        .dialog-control {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #e0e0e0;
            font-size: 14px;
            transition: background-color 0.15s;
            border: 1px solid #3e3e42;
            background: #3e3e42;
            padding: 0;
            margin-left: 0;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
            box-shadow: none;
        }
        
        
        .dialog-control:hover {
            background: #4e4e52;
        }
        
        .dialog-control.close:hover {
            background: #4e4e52;
        }

        .dialog-control:focus,
        .dialog-control:active {
            background: #3e3e42;
            box-shadow: none;
        }
        
        .dialog-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background: #ffffff;
        }
        
        body.dark-theme .dialog-content {
            background: #2d2d30;
        }
        
        .dialog-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        
        .dialog-footer {
            padding: 12px 16px;
            border-top: 1px solid #e5e5e5;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            background: #fafafa;
        }
        
        body.dark-theme .dialog-footer {
            background: #252526;
            border-top-color: #3e3e42;
        }
        
        /* Windows-style Menu Bar */
        .menu-bar {
            background: #fafafa;
            border-bottom: 1px solid #e5e5e5;
            height: 30px;
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-size: 13px;
            user-select: none;
            z-index: 10000;
        }
        
        body.dark-theme .menu-bar {
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
        }
        
        .menu-item {
            padding: 4px 12px;
            cursor: pointer;
            color: #202020;
            border-radius: 3px;
            -webkit-app-region: no-drag;
            transition: background 0.15s;
        }
        
        body.dark-theme .menu-item {
            color: #e0e0e0;
        }
        
        .menu-item:hover {
            background: #e5e5e5;
        }
        
        body.dark-theme .menu-item:hover {
            background: #3e3e42;
        }
        
        .menu-item:active {
            background: #d0d0d0;
        }
        
        body.dark-theme .menu-item:active {
            background: #505050;
        }
        
        .menu-separator {
            width: 1px;
            height: 16px;
            background: #d0d0d0;
            margin: 0 4px;
        }
        
        body.dark-theme .menu-separator {
            background: #3e3e42;
        }
        
        .menu-dropdown {
            position: absolute;
            background: #1a1a1a;
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            min-width: 180px;
            padding: 4px 0;
            display: none;
            z-index: 10001;
            font-size: 13px;
        }
        
        body.dark-theme .menu-dropdown {
            background: #1a1a1a;
            border-color: rgba(128, 128, 128, 0.3);
        }
        
        .menu-dropdown-item {
            padding: 6px 24px 6px 32px;
            cursor: pointer;
            color: #c0c0c0;
            display: flex;
            align-items: center;
            position: relative;
        }
        
        body.dark-theme .menu-dropdown-item {
            color: #c0c0c0;
        }
        
        .menu-dropdown-item:hover {
            background: #3e3e3e;
        }
        
        body.dark-theme .menu-dropdown-item:hover {
            background: #3e3e3e;
        }
        
        .menu-dropdown-item.disabled {
            color: #808080;
            cursor: not-allowed;
        }
        
        /* Templates submenu styling - black and grey theme */
        #templatesSubmenu {
            display: none;
            position: absolute;
            left: 100%;
            top: 0;
            margin-left: 2px;
            background: #1a1a1a;
            border: 1px solid #808080;
            border-radius: 4px;
            padding: 4px 0;
            min-width: 200px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            z-index: 10002;
        }
        
        body.dark-theme #templatesSubmenu {
            background: #1a1a1a;
            border-color: #808080;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
        }
        
        body.dark-theme .menu-dropdown-item.disabled {
            color: #808080;
        }
        
        .menu-dropdown-item.disabled:hover {
            background: transparent;
        }
        
        .menu-dropdown-separator {
            height: 1px;
            background: #808080;
            margin: 4px 0;
        }
        
        body.dark-theme .menu-dropdown-separator {
            background: #808080;
        }
        
        .menu-shortcut {
            margin-left: auto;
            color: #808080;
            font-size: 11px;
        }
        
        body.dark-theme .menu-shortcut {
            color: #808080;
        }
        
        #chatbot .container {
            max-width: 100%;
        }
        

        /* Windows 11 Fluent Design Typography - Updated */
        h1 {
            color: #202020;
            text-align: left;
            margin-bottom: 24px;
            font-size: 28px;
            font-weight: 600;
            line-height: 1.2;
        }
        
        body.dark-theme h1 {
            color: #e0e0e0;
        }

        /* Windows 11 Fluent Design Form Container */
        .form-container {
            background: #ffffff;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid #e5e5e5;
            position: relative;
            overflow: hidden;
            width: 100%;
            box-sizing: border-box;
        }
        
        body.dark-theme .form-container {
            background: #2d2d30;
            border-color: #3e3e42;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .form-group {
            margin-bottom: 20px;
        }

        /* Windows 11 Fluent Design Label Styles */
        label {
            display: block;
            margin-bottom: 6px;
            color: #202020;
            font-weight: 400;
            font-size: 13px;
            position: relative;
            padding-left: 0;
        }
        
        body.dark-theme label {
            color: #e0e0e0;
        }
        
        label.required::after {
            content: ' *';
            color: #d13438;
        }
        
        body.dark-theme label.required::after {
            color: #f48771;
        }

        /* Windows 11 Fluent Design Input Styles */
        input[type="text"],
        input[type="email"],
        input[type="password"],
        input[type="number"],
        input[type="search"],
        textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.15s ease;
            font-family: 'Segoe UI', sans-serif;
            background: #ffffff;
            color: #202020;
            min-height: 32px;
            box-sizing: border-box;
        }
        
        body.dark-theme input[type="text"],
        body.dark-theme input[type="email"],
        body.dark-theme input[type="password"],
        body.dark-theme input[type="number"],
        body.dark-theme input[type="search"],
        body.dark-theme textarea {
            background: #1e1e1e;
            border-color: #3e3e42;
            color: #e0e0e0;
        }

        input[type="text"]:focus,
        input[type="email"]:focus,
        input[type="password"]:focus,
        input[type="number"]:focus,
        input[type="search"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #0078d4;
            box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.2);
        }
        
        body.dark-theme input[type="text"]:focus,
        body.dark-theme input[type="email"]:focus,
        body.dark-theme input[type="password"]:focus,
        body.dark-theme input[type="number"]:focus,
        body.dark-theme input[type="search"]:focus,
        body.dark-theme textarea:focus,
        body.dark-theme select:focus {
            border-color: #60cdff;
            box-shadow: 0 0 0 2px rgba(96, 205, 255, 0.2);
        }
        
        input[type="text"]:disabled,
        input[type="email"]:disabled,
        input[type="password"]:disabled,
        input[type="number"]:disabled,
        input[type="search"]:disabled,
        textarea:disabled,
        select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #f5f5f5;
        }
        
        body.dark-theme input[type="text"]:disabled,
        body.dark-theme input[type="email"]:disabled,
        body.dark-theme input[type="password"]:disabled,
        body.dark-theme input[type="number"]:disabled,
        body.dark-theme input[type="search"]:disabled,
        body.dark-theme textarea:disabled,
        body.dark-theme select:disabled {
            background: #2d2d30;
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        /* Windows 11 Fluent Design Button Styles */
        button {
            background: #1a1a1a;
            color: #c0c0c0;
            border: 1px solid rgba(128, 128, 128, 0.3);
            padding: 6px 16px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.15s ease;
            width: auto;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', sans-serif;
            min-height: 32px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        button:hover {
            background-color: #3e3e3e;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }

        button:active {
            background-color: #505050;
            box-shadow: 0 1px 1px rgba(0,0,0,0.1);
            transform: translateY(1px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #c0c0c0;
            box-shadow: none;
        }
        
        body.dark-theme button {
            background: #1a1a1a;
        }
        
        body.dark-theme button:hover {
            background-color: #3e3e3e;
        }
        
        body.dark-theme button:active {
            background-color: #505050;
        }
        
        body.dark-theme button:disabled {
            background-color: #3e3e42;
            color: #808080;
        }
        
        /* Secondary button style */
        button.secondary {
            background: transparent;
            color: #c0c0c0;
            border: 1px solid rgba(128, 128, 128, 0.5);
        }
        
        button.secondary:hover {
            background: rgba(255, 255, 255, 0.06);
        }
        
        body.dark-theme button.secondary {
            color: #c0c0c0;
            border-color: rgba(128, 128, 128, 0.5);
        }
        
        body.dark-theme button.secondary:hover {
            background: rgba(255, 255, 255, 0.06);
        }
        
        /* Danger button style */
        button.danger {
            background: #d13438;
        }
        
        button.danger:hover {
            background-color: #e74c50;
        }
        
        button.danger:active {
            background-color: #b02a2e;
        }

        /* Form submit buttons - full width */
        form button[type="submit"] {
            width: 100%;
        }
        
        /* Toolbar buttons (refresh-btn) */
        .refresh-btn {
            background: #1a1a1a;
            color: #c0c0c0;
            border: 1px solid rgba(128, 128, 128, 0.3);
            padding: 4px 8px;
            border-radius: 2px;
            outline: none;
        }
        
        .refresh-btn:hover {
            background: #3e3e3e;
            color: #c0c0c0;
        }
        
        .refresh-btn:active {
            background: #505050;
        }
        
        /* Ensure canvas toolbar buttons stay grey/black */
        #canvasToolbar .refresh-btn {
            background: #1a1a1a !important;
            color: #c0c0c0 !important;
            border: 1px solid rgba(128, 128, 128, 0.3) !important;
            box-shadow: none !important;
        }
        
        #canvasToolbar .refresh-btn:hover {
            background: #3e3e3e !important;
        }
        
        #canvasToolbar .refresh-btn:active {
            background: #505050 !important;
        }


        /* Windows 11 Fluent Design Records Container */
        .records-container {
            background: #ffffff;
            border-radius: 8px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid #e5e5e5;
        }
        
        body.dark-theme .records-container {
            background: #2d2d30;
            border-color: #3e3e42;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .records-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .records-header h2 {
            color: #202020;
            font-size: 20px;
            font-weight: 600;
            margin: 0;
        }
        
        body.dark-theme .records-header h2 {
            color: #e0e0e0;
        }

        .refresh-btn {
            /* Uses base button style - small grey */
            width: auto;
        }

        /* Anchor tags with refresh-btn class */
        a.refresh-btn {
            background: transparent;
            color: #cccccc;
            border: none;
            padding: 4px 8px;
            border-radius: 2px;
            font-size: 13px;
            font-weight: 400;
            cursor: pointer;
            transition: background-color 0.15s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        a.refresh-btn:hover {
            background-color: #3e3e42;
            color: #ffffff;
        }

        a.refresh-btn:active {
            background-color: #505050;
        }

        .records-list {
            display: grid;
            gap: 15px;
        }

        /* Windows 11 Fluent Design Record Card */
        .record-card {
            background: #ffffff;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            padding: 16px;
            transition: all 0.15s ease;
        }
        
        body.dark-theme .record-card {
            background: #252526;
            border-color: #3e3e42;
        }

        .record-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-color: #0078d4;
        }
        
        body.dark-theme .record-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            border-color: #60cdff;
        }

        .record-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 15px;
        }

        .record-id {
            color: #202020;
            font-weight: 600;
            font-size: 18px;
        }
        
        body.dark-theme .record-id {
            color: #e0e0e0;
        }

        .delete-btn {
            /* Uses base button style - small grey */
            width: auto;
        }

        .record-field {
            margin-bottom: 10px;
        }

        .record-field strong {
            color: #606060;
            display: inline-block;
            min-width: 100px;
            font-weight: 600;
        }
        
        body.dark-theme .record-field strong {
            color: #a0a0a0;
        }

        .record-field span {
            color: #202020;
        }
        
        body.dark-theme .record-field span {
            color: #e0e0e0;
        }

        .record-image { width: 64px; height: 64px;
            border-radius: 8px;
            margin-bottom: 15px;
            background: rgba(255,255,255,0.05);
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .record-image img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* Windows 11 Fluent Design Empty State */
        .empty-state {
            text-align: center;
            padding: 48px 24px;
            color: #808080;
            font-size: 14px;
        }
        
        body.dark-theme .empty-state {
            color: #808080;
        }

        /* Windows 11 Fluent Design Messages */
        .success-message {
            background: #dff6dd;
            color: #107c10;
            padding: 12px 16px;
            border-radius: 4px;
            margin-bottom: 16px;
            text-align: left;
            display: none;
            border-left: 4px solid #107c10;
            font-size: 13px;
        }
        
        body.dark-theme .success-message {
            background: rgba(16, 124, 16, 0.2);
            color: #6fcf97;
            border-left-color: #6fcf97;
        }

        .error-message {
            background: #fde7e9;
            color: #d13438;
            padding: 12px 16px;
            border-radius: 4px;
            margin-bottom: 16px;
            text-align: left;
            display: none;
            border-left: 4px solid #d13438;
            font-size: 13px;
        }
        
        body.dark-theme .error-message {
            background: rgba(209, 52, 56, 0.2);
            color: #f48771;
            border-left-color: #f48771;
        }
        
        .info-message {
            background: #deecf9;
            color: #0078d4;
            padding: 12px 16px;
            border-radius: 4px;
            margin-bottom: 16px;
            text-align: left;
            display: none;
            border-left: 4px solid #0078d4;
            font-size: 13px;
        }
        
        body.dark-theme .info-message {
            background: rgba(0, 120, 212, 0.2);
            color: #60cdff;
            border-left-color: #60cdff;
        }
        
        .warning-message {
            background: #fff4e5;
            color: #ffaa44;
            padding: 12px 16px;
            border-radius: 4px;
            margin-bottom: 16px;
            text-align: left;
            display: none;
            border-left: 4px solid #ffaa44;
            font-size: 13px;
        }
        
        body.dark-theme .warning-message {
            background: rgba(255, 170, 68, 0.2);
            color: #ffc83d;
            border-left-color: #ffc83d;
        }


        /* Windows 11 Fluent Design Relationship Card */
        .relationship-card {
            background: #ffffff;
            border: 1px solid #e5e5e5;
            border-left: 4px solid #0078d4;
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 12px;
            transition: all 0.15s ease;
        }
        
        body.dark-theme .relationship-card {
            background: #252526;
            border-color: #3e3e42;
            border-left-color: #60cdff;
        }

        .relationship-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-color: #0078d4;
        }
        
        body.dark-theme .relationship-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            border-color: #60cdff;
        }
        
        /* Windows 11 Fluent Design Context Menus - Black and Grey Theme */
        #elementContextMenu,
        #relationshipContextMenu,
        #paletteInstanceMenu {
            display: none;
            position: fixed;
            background: #1a1a1a;
            border: 1px solid #808080;
            border-radius: 4px;
            padding: 4px 0;
            min-width: 180px;
            max-width: 320px;
            z-index: 10001;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            font-family: 'Segoe UI', sans-serif;
        }
        
        body.dark-theme #elementContextMenu,
        body.dark-theme #relationshipContextMenu,
        body.dark-theme #paletteInstanceMenu {
            background: #1a1a1a;
            border-color: #808080;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
        }
        
        .context-menu-item {
            width: 100%;
            padding: 8px 16px;
            background: transparent;
            border: none;
            color: #c0c0c0;
            text-align: left;
            cursor: pointer;
            font-size: 13px;
            font-weight: 400;
            transition: background-color 0.1s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-height: 32px;
            box-sizing: border-box;
            outline: none;
        }
        
        body.dark-theme .context-menu-item {
            color: #c0c0c0;
        }
        
        .context-menu-item:hover {
            background-color: #3e3e3e;
        }
        
        body.dark-theme .context-menu-item:hover {
            background-color: #3e3e3e;
        }
        
        .context-menu-item:active {
            background-color: #505050;
        }
        
        body.dark-theme .context-menu-item:active {
            background-color: #505050;
        }
        
        .context-menu-item:focus {
            outline: none;
            background-color: #3e3e3e;
        }
        
        body.dark-theme .context-menu-item:focus {
            outline: none;
            background-color: #3e3e3e;
        }
        
        /* Override button styles for context menu items */
        #elementContextMenu button.context-menu-item,
        #relationshipContextMenu button.context-menu-item,
        #paletteInstanceMenu button.context-menu-item {
            background: transparent;
            box-shadow: none;
            border-radius: 0;
            min-height: 32px;
            width: 100%;
            padding: 8px 16px;
        }
        
        #elementContextMenu button.context-menu-item:hover,
        #relationshipContextMenu button.context-menu-item:hover,
        #paletteInstanceMenu button.context-menu-item:hover {
            background-color: #3e3e3e;
            box-shadow: none;
        }
        
        body.dark-theme #elementContextMenu button.context-menu-item:hover,
        body.dark-theme #relationshipContextMenu button.context-menu-item:hover,
        body.dark-theme #paletteInstanceMenu button.context-menu-item:hover {
            background-color: #3e3e3e;
            box-shadow: none;
        }
        
        #elementContextMenu button.context-menu-item:active,
        #relationshipContextMenu button.context-menu-item:active,
        #paletteInstanceMenu button.context-menu-item:active {
            background-color: #505050;
            box-shadow: none;
            transform: none;
        }
        
        body.dark-theme #elementContextMenu button.context-menu-item:active,
        body.dark-theme #relationshipContextMenu button.context-menu-item:active,
        body.dark-theme #paletteInstanceMenu button.context-menu-item:active {
            background-color: #505050;
            box-shadow: none;
            transform: none;
        }
        
        #elementContextMenu button.context-menu-item:focus,
        #relationshipContextMenu button.context-menu-item:focus,
        #paletteInstanceMenu button.context-menu-item:focus {
            outline: none;
            box-shadow: none;
            background-color: #3e3e3e;
        }
        
        body.dark-theme #elementContextMenu button.context-menu-item:focus,
        body.dark-theme #relationshipContextMenu button.context-menu-item:focus,
        body.dark-theme #paletteInstanceMenu button.context-menu-item:focus {
            outline: none;
            box-shadow: none;
            background-color: #3e3e3e;
        }
        
        /* Property context menu button styling - black and grey theme */
        #propertyContextMenu button {
            background: transparent;
            box-shadow: none;
            border-radius: 0;
            outline: none;
            color: #c0c0c0;
        }
        
        #propertyContextMenu button:hover {
            background-color: #3e3e3e;
            box-shadow: none;
        }
        
        #propertyContextMenu button:active {
            background-color: #505050;
            box-shadow: none;
            transform: none;
        }
        
        #propertyContextMenu button:focus {
            outline: none;
            box-shadow: none;
            background-color: #3e3e3e;
        }
        
        .context-menu-item:disabled,
        .context-menu-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            color: #808080;
        }
        
        body.dark-theme .context-menu-item:disabled,
        body.dark-theme .context-menu-item.disabled {
            color: #808080;
        }
        
        .context-menu-item:disabled:hover,
        .context-menu-item.disabled:hover {
            background-color: transparent;
        }
        
        
        /* Context menu separator */
        #elementContextMenu > div[style*="height: 1px"],
        #relationshipContextMenu > div[style*="height: 1px"],
        #paletteInstanceMenu > div[style*="height: 1px"] {
            height: 1px;
            background: #808080;
            margin: 4px 0;
            padding: 0;
        }
        
        body.dark-theme #elementContextMenu > div[style*="height: 1px"],
        body.dark-theme #relationshipContextMenu > div[style*="height: 1px"],
        body.dark-theme #paletteInstanceMenu > div[style*="height: 1px"] {
            background: #808080;
        }
        
        /* Danger/Delete items in context menu - grey theme */
        .context-menu-item[data-action="deleteElementInstance"],
        .context-menu-item[data-action="deleteRelationship"],
        .context-menu-item.danger {
            color: #c0c0c0;
        }
        
        body.dark-theme .context-menu-item[data-action="deleteElementInstance"],
        body.dark-theme .context-menu-item[data-action="deleteRelationship"],
        body.dark-theme .context-menu-item.danger {
            color: #c0c0c0;
        }
        
        .context-menu-item[data-action="deleteElementInstance"]:hover,
        .context-menu-item[data-action="deleteRelationship"]:hover,
        .context-menu-item.danger:hover {
            background-color: #3e3e3e;
        }
        
        body.dark-theme .context-menu-item[data-action="deleteElementInstance"]:hover,
        body.dark-theme .context-menu-item[data-action="deleteRelationship"]:hover,
        body.dark-theme .context-menu-item.danger:hover {
            background-color: #3e3e3e;
        }
        
        /* Submenu styling - black and grey theme */
        #relatedElementsSubmenu {
            display: none;
            position: absolute;
            left: 100%;
            top: 0;
            margin-left: 2px;
            background: #1a1a1a;
            border: 1px solid #808080;
            border-radius: 4px;
            padding: 4px 0;
            min-width: 180px;
            max-width: 320px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            z-index: 10002;
        }
        
        body.dark-theme #relatedElementsSubmenu {
            background: #1a1a1a;
            border-color: #808080;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
        }
        
        #relatedElementsSubmenu .context-menu-item {
            padding: 8px 16px;
            font-size: 13px;
        }
        
        /* Ensure submenu items don't have blue accents */
        #relatedElementsSubmenu .context-menu-item:focus {
            outline: none;
            box-shadow: none;
        }
        
        /* Submenu arrow indicator */
        .context-menu-item span[style*="float: right"] {
            float: right;
            margin-left: 16px;
            color: #808080;
            font-size: 10px;
        }
        
        body.dark-theme .context-menu-item span[style*="float: right"] {
            color: #808080;
        }
        
        /* Palette Menu Header - Black and Grey Theme */
        .palette-menu-header {
            padding: 8px 16px;
            font-weight: 600;
            color: #c0c0c0;
            border-bottom: 1px solid #808080;
            font-size: 13px;
            background: #000000;
        }
        
        body.dark-theme .palette-menu-header {
            color: #c0c0c0;
            border-bottom-color: #808080;
            background: #000000;
        }
        
        .palette-menu-header #paletteMenuInstanceCount {
            float: right;
            color: #808080;
            font-size: 11px;
            font-weight: 400;
        }
        
        body.dark-theme .palette-menu-header #paletteMenuInstanceCount {
            color: #808080;
        }
        
        /* Palette Menu Empty State */
        .palette-menu-empty {
            display: none;
            padding: 16px;
            color: #808080;
            font-size: 12px;
            text-align: center;
        }
        
        body.dark-theme .palette-menu-empty {
            color: #808080;
        }
        
        /* Palette Instance List Items - Black and Grey Theme */
        #paletteInstanceList .palette-instance-item,
        .palette-search-list .palette-instance-item {
            padding: 8px 16px;
            cursor: pointer;
            color: #c0c0c0;
            font-size: 13px;
            transition: background-color 0.1s ease;
            border-bottom: 1px solid #808080;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        body.dark-theme #paletteInstanceList .palette-instance-item,
        body.dark-theme .palette-search-list .palette-instance-item {
            color: #c0c0c0;
            border-bottom-color: #808080;
        }
        
        #paletteInstanceList .palette-instance-item:hover,
        .palette-search-list .palette-instance-item:hover {
            background-color: #3e3e3e;
        }
        
        body.dark-theme #paletteInstanceList .palette-instance-item:hover,
        body.dark-theme .palette-search-list .palette-instance-item:hover {
            background-color: #3e3e3e;
        }
        
        #paletteInstanceList .palette-instance-item:active,
        .palette-search-list .palette-instance-item:active {
            background-color: #505050;
        }
        
        body.dark-theme #paletteInstanceList .palette-instance-item:active,
        body.dark-theme .palette-search-list .palette-instance-item:active {
            background-color: #505050;
        }
        
        #paletteInstanceList .palette-instance-item img,
        .palette-search-list .palette-instance-item img {
            width: 20px;
            height: 20px;
            object-fit: contain;
        }
        
        #paletteInstanceList .palette-instance-item .instance-name,
        .palette-search-list .palette-instance-item .instance-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .palette-search-input {
            width: 100%;
            padding: 6px 10px;
            font-size: 12px;
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            color: #ffffff;
            outline: none;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.35);
        }
        
        .palette-search-input::placeholder {
            color: #8a8a8a;
        }
        
        .palette-search-input:focus {
            border-color: #5a5a5f;
        }
        
        .palette-search-results {
            margin-top: 8px;
            border: 1px solid #3e3e42;
            border-radius: 6px;
            background: #1b1b1d;
            max-height: 220px;
            overflow-y: auto;
            position: absolute;
            left: 0;
            top: 32px;
            width: 320px;
            z-index: 10002;
            box-shadow: 0 6px 16px rgba(0,0,0,0.45);
        }
        
        .palette-search-list .palette-instance-item {
            border-bottom: 1px solid rgba(255,255,255,0.04);
        }
        
        .palette-search-list .palette-instance-item:last-child {
            border-bottom: none;
        }
        
        .palette-instance-item .instance-type {
            font-size: 10px;
            color: #808080;
            margin-left: 6px;
        }

        .relationship-flow {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .relationship-source {
            background: rgba(230, 230, 230, 0.2);
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 600;
            color: #e6e6e6;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid rgba(230, 230, 230, 0.5);
        }

        .relationship-arrow {
            color: #e6e6e6;
            font-size: 20px;
            font-weight: bold;
        }

        .relationship-type {
            background: rgba(230, 230, 230, 0.2);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            color: #e6e6e6;
            border: 1px solid rgba(230, 230, 230, 0.5);
        }

        .relationship-target {
            background: rgba(230, 230, 230, 0.2);
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 600;
            color: #e6e6e6;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid rgba(230, 230, 230, 0.5);
        }

        .relationship-element-image { width: 64px; height: 64px;
            border-radius: 4px;
            object-fit: contain;
            flex-shrink: 0;
        }

        .section-title {
            color: #ffffff;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid #e6e6e6;
            padding-bottom: 10px;
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }

        .dashboard-card {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: transform 0.3s, box-shadow 0.3s, border 0.3s;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .dashboard-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(123, 104, 238, 0.3);
            border-color: rgba(123, 104, 238, 0.5);
        }

        .dashboard-card-icon {
            font-size: 4em;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dashboard-card-icon img {
            max-width: 96px;
            max-height: 96px;
            width: 96px;
            height: 96px;
            object-fit: contain;
        }

        .dashboard-card h2 {
            color: #ffffff;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .dashboard-card p {
            color: #b0b0d0;
            font-size: 14px;
            line-height: 1.6;
        }

        .section {
            display: none;
        }

        .section {
            display: none;
            flex: 1;
            overflow: hidden;
        }
        
        .section.active {
            display: flex;
            flex-direction: column;
        }
        
        #modelingCanvas.section.active {
            width: 100%;
            max-width: 100%;
            padding: 0;
            margin: 0;
            height: 100%;
            overflow: hidden;
        }
        

        .back-to-dashboard {
            /* Uses base button style - small grey */
            width: auto;
            margin-bottom: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 25px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .stat-number {
            font-size: 2.5em;
            font-weight: bold;
            color: #888888;
            margin-bottom: 10px;
        }

        .stat-label {
            color: #b0b0d0;
            font-size: 14px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            overflow: auto;
        }

        .modal-content {
            background-color: #2a2a2a;
            margin: 5% auto;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 1200px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.1);
            color: #e0e0e0;
        }

        .draggable-handle {
            cursor: move;
            user-select: none;
        }

        .close {
            color: #b0b0d0;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s;
        }

        .close:hover {
            color: #ffffff;
        }

        .logo-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
        }

        .logo-svg { width: 200px; height: 200px;
            transition: transform 0.3s;
            object-fit: contain;
        }

        .logo-svg:hover {
            transform: scale(1.05);
        }
        
        .logo-container:hover {
            opacity: 0.9;
        }

        .logo-title {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .logo-title h1 {
            margin: 0;
            font-size: 2em;
            text-shadow: none;
        }

        .logo-subtitle {
            color: #b0b0d0;
            font-size: 0.9em;
            margin-top: 5px;
            font-weight: 400;
        }

        .quick-action-btn {
            /* Uses base button style - small grey */
            white-space: nowrap;
        }

        .chatbot-container {
            width: 100%;
            max-width: 100%;
            margin: 0 auto;
        }

        .chatbot-messages {
            background: #1e1e1e;
            border-radius: 4px;
            padding: 16px;
            height: 500px;
            overflow-y: auto;
            margin-bottom: 20px;
            border: 1px solid #3e3e42;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .edgly-commentary-bubble {
            margin-top: 6px;
            max-width: 200px;
            padding: 6px 8px;
            border-radius: 10px;
            border: none;
            background: transparent;
            font-size: 11px;
            line-height: 1.3;
            text-align: center;
            color: #ffffff;
            pointer-events: none;
            opacity: 0;
            transform: translateY(4px);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .edgly-commentary-bubble.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .edgly-wiggle {
            animation: edglyWiggle 0.9s ease-in-out 0s 4;
        }

        @keyframes edglyWiggle {
            0% { transform: translateX(0); }
            25% { transform: translateX(-6px); }
            50% { transform: translateX(6px); }
            75% { transform: translateX(-4px); }
            100% { transform: translateX(0); }
        }

        .chat-message {
            display: flex;
            gap: 12px;
            animation: fadeIn 0.3s ease-in;
            min-width: 0;
            max-width: 100%;
            box-sizing: border-box;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chat-message.user {
            flex-direction: row-reverse;
        }

        .chat-avatar { width: 80px; height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            flex-shrink: 0;
            overflow: hidden;
        }

        .chat-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }

        .chat-message.user .chat-avatar {
            background: linear-gradient(135deg, #FF6B35 0%, #FFD93D 100%);
        }

        .chat-message.assistant .chat-avatar {
            background: transparent;
        }

        .chat-content {
            flex: 1;
            min-width: 0;
            background: #252526;
            padding: 12px;
            border-radius: 4px;
            border: 1px solid #3e3e42;
            overflow-x: auto;
            max-width: 100%;
            box-sizing: border-box;
        }

        .chat-message.user .chat-content {
            background: #1e3a5f;
            border-color: #0078d4;
        }

        .chat-content p {
            margin: 0;
            color: #e0e0e0;
            line-height: 1.6;
        }
        
        /* Smaller fonts for AskED modal */
        #askedModalChatMessages .chat-content {
            font-size: 12px;
        }
        
        #askedModalChatMessages .chat-content p {
            font-size: 12px;
            line-height: 1.5;
        }
        
        #askedModalChatMessages .chat-message.user .chat-content p {
            font-size: 12px;
        }
        
        /* Formatting for responses */
        #askedModalChatMessages .chat-content h1,
        #askedModalChatMessages .chat-content h2,
        #askedModalChatMessages .chat-content h3,
        #askedModalChatMessages .chat-content h4 {
            color: #ffffff;
            margin: 12px 0 8px 0;
            font-weight: 600;
        }
        
        #askedModalChatMessages .chat-content h1 { font-size: 16px; }
        #askedModalChatMessages .chat-content h2 { font-size: 15px; }
        #askedModalChatMessages .chat-content h3 { font-size: 14px; }
        #askedModalChatMessages .chat-content h4 { font-size: 13px; }
        
        #askedModalChatMessages .chat-content strong {
            color: #ffffff;
            font-weight: 600;
        }
        
        #askedModalChatMessages .chat-content em {
            font-style: italic;
            color: #b0b0d0;
        }
        
        /* Citations and notes - smaller font */
        #askedModalChatMessages .chat-content .citation,
        #askedModalChatMessages .chat-content .note,
        #askedModalChatMessages .chat-content .footnote {
            font-size: 10px;
            color: #888;
            font-style: italic;
            margin-top: 8px;
            padding-left: 12px;
            border-left: 2px solid rgba(255,255,255,0.2);
        }
        
        /* Remove table formatting */
        #askedModalChatMessages .chat-content table {
            display: none;
        }
        
        /* Element/Relationship/Property images */
        #askedModalChatMessages .chat-content .element-image,
        #askedModalChatMessages .chat-content .relationship-image,
        #askedModalChatMessages .chat-content .property-image {
            display: inline-block;
            vertical-align: middle;
            margin: 0 6px;
            width: 24px;
            height: 24px;
            object-fit: contain;
        }
        
        #askedModalChatMessages .chat-content .element-image-large,
        #askedModalChatMessages .chat-content .relationship-image-large,
        #askedModalChatMessages .chat-content .property-image-large {
            display: block;
            margin: 8px 0;
            width: 48px;
            height: 48px;
            object-fit: contain;
        }

        .chat-content table {
            width: 100%;
            max-width: 100%;
            border-collapse: collapse;
            margin: 0;
            word-wrap: break-word;
            table-layout: auto;
            overflow-wrap: break-word;
            box-sizing: border-box;
            display: table;
        }

        .chat-content table td,
        .chat-content table th {
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            padding: 8px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .chat-content table td {
            white-space: normal;
        }

        .chat-content table img {
            max-width: 100%;
            height: auto;
        }
        
        /* Nested table styling for properties within element tables */
        .chat-content table table {
            width: 100%;
            max-width: 100%;
            margin: 4px 0;
            font-size: 11px;
        }
        
        .chat-content table table td,
        .chat-content table table th {
            padding: 4px;
            font-size: 11px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
        }
        
        .chat-content table table img {
            max-width: 64px;
            height: auto;
        }
        
        /* Sortable Table Styles */
        .sortable-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .sortable-table th.sortable {
            position: relative;
            padding-right: 25px;
        }
        
        .sortable-table th.sortable:hover {
            background: #353535;
        }
        
        .sortable-table th.sortable.sort-asc .sort-indicator::before {
            content: '';
            color: #888888;
        }
        
        .sortable-table th.sortable.sort-desc .sort-indicator::before {
            content: '';
            color: #888888;
        }
        
        .sortable-table th.sortable .sort-indicator {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .sortable-table tbody tr {
            border-bottom: 1px solid rgba(255,255,255,0.1);
            transition: background 0.2s;
        }
        
        .sortable-table tbody tr:hover {
            background: #353535;
        }
        
        .sortable-table tbody td {
            padding: 12px;
            color: #e0e0e0;
            vertical-align: top;
        }
        
        /* Resizable columns */
        .sortable-table th {
            position: relative;
        }
        
        .sortable-table th .resizer {
            position: absolute;
            top: 0;
            right: 0;
            width: 5px;
            height: 100%;
            cursor: col-resize;
            user-select: none;
            background: transparent;
        }
        
        .sortable-table th .resizer:hover {
            background: #888888;
        }
        
        .sortable-table th .resizer.resizing {
            background: #888888;
        }

        .chat-input-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        .chat-input {
            width: 100%;
            padding: 6px 12px;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            font-size: 12px;
            background: #1e1e1e;
            color: #e0e0e0;
            font-family: inherit;
            transition: border-color 0.3s;
            box-sizing: border-box;
        }

        .chat-input:focus {
            outline: none;
            border-color: #e6e6e6;
            box-shadow: 0 0 0 3px rgba(230, 230, 230, 0.2);
        }

        .chat-send-btn {
            /* Uses base button style - small grey */
            white-space: nowrap;
            align-self: flex-start;
        }

        .chat-suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        .suggestion-chip {
            background: #2a2a2a;
            border: 1px solid rgba(255,255,255,0.1);
            color: #e0e0e0;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .suggestion-chip:hover {
            background: #3d3d54;
            border-color: #e6e6e6;
            transform: translateY(-2px);
        }
        
        /* Palette Position Button Styles */
        .palette-position-btn:hover {
            background: #3d3d54 !important;
            border-color: rgba(255,255,255,0.3) !important;
        }
        
        .palette-position-btn:active {
            background: #4d4d64 !important;
        }
        
        /* Palette Section Styles */
        .palette-section-header {
            transition: background-color 0.2s ease;
        }
        
        .palette-section-header:hover {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        .palette-section-content {
            transition: max-height 0.3s ease-out;
        }
        
        .palette-section-chevron {
            display: inline-block;
            transition: transform 0.2s ease;
        }

        .auth-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .auth-overlay.auth-hidden {
            display: none;
        }

        .auth-modal {
            background: #ffffff;
            color: #202020;
            width: 360px;
            max-width: 90vw;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.35);
        }

        body.dark-theme .auth-modal {
            background: #2a2a2a;
            color: #e0e0e0;
        }

        .auth-modal h2 {
            margin-bottom: 16px;
            font-size: 20px;
        }

        .auth-modal input {
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 12px;
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.15);
            font-size: 14px;
        }

        body.dark-theme .auth-modal input {
            background: #1e1e1e;
            color: #e0e0e0;
            border-color: rgba(255, 255, 255, 0.1);
        }

        .auth-modal button {
            width: 100%;
        }

        .auth-error {
            display: none;
            background: #f44336;
            color: #ffffff;
            padding: 10px 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            font-size: 13px;
        }

        .auth-toggle {
            margin-top: 12px;
            text-align: center;
            font-size: 13px;
        }

        .auth-toggle button {
            background: transparent;
            color: inherit;
            border: none;
            cursor: pointer;
            font-weight: 600;
        }

        .auth-register-only {
            display: none;
        }

        .auth-overlay.auth-register-mode .auth-register-only {
            display: block;
        }
        
    </style>
</head>
<body class="dark-theme">
    <div id="authOverlay" class="auth-overlay auth-hidden">
        <div class="auth-modal">
            <h2 id="authTitle">Sign in</h2>
            <div id="authError" class="auth-error"></div>
            <form id="authForm">
                <input type="text" id="authFullName" class="auth-register-only" placeholder="Full name">
                <input type="email" id="authEmail" placeholder="Email" required>
                <input type="password" id="authPassword" placeholder="Password" required>
                <button type="submit" id="authSubmit">Sign in</button>
            </form>
            <div class="auth-toggle">
                <span id="authToggleText">No account yet?</span>
                <button type="button" id="authToggleBtn">Register</button>
            </div>
        </div>
    </div>
    <div class="container">
        <!-- Windows-style Menu Bar -->
        <div class="menu-bar">
            <div class="menu-item" onmouseenter="showMenuDropdown(event, 'fileMenu')" onmouseleave="hideMenuDropdown('fileMenu')">
                File
                <div id="fileMenu" class="menu-dropdown">
                    <div class="menu-dropdown-item" onclick="saveCanvasModel()">
                        <span>Save Model</span>
                        <span class="menu-shortcut">Ctrl+S</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="loadCanvasModels()">
                        <span>Load Model</span>
                        <span class="menu-shortcut">Ctrl+O</span>
                    </div>
                    <div class="menu-dropdown-separator"></div>
                    <div class="menu-dropdown-item" onclick="clearCanvas()">
                        <span>Clear Canvas</span>
                        <span class="menu-shortcut">Ctrl+Shift+C</span>
                    </div>
                </div>
            </div>
            <div class="menu-item" onmouseenter="showMenuDropdown(event, 'editMenu')" onmouseleave="hideMenuDropdown('editMenu')">
                Edit
                <div id="editMenu" class="menu-dropdown">
                    <div class="menu-dropdown-item" onclick="undoCanvasAction()">
                        <span>Undo</span>
                        <span class="menu-shortcut">Ctrl+Z</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="redoCanvasAction()">
                        <span>Redo</span>
                        <span class="menu-shortcut">Ctrl+Y</span>
                    </div>
                </div>
            </div>
            <div class="menu-item" onmouseenter="showMenuDropdown(event, 'viewMenu')" onmouseleave="hideMenuDropdown('viewMenu')">
                View
                <div id="viewMenu" class="menu-dropdown">
                    <div class="menu-dropdown-item" onclick="toggleGridlines()">
                        <span>Toggle Gridlines</span>
                        <span class="menu-shortcut">G</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="toggleLayerManagement()">
                        <span>Layer Management</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="toggleKeyboardShortcuts()">
                        <span>Keyboard Shortcuts</span>
                        <span class="menu-shortcut">?</span>
                    </div>
                    <div class="menu-dropdown-separator"></div>
                    <div class="menu-dropdown-item" onclick="toggleFullscreen()">
                        <span>Toggle Fullscreen</span>
                        <span class="menu-shortcut">F11</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="toggleCanvasTheme()">
                        <span>Toggle Theme</span>
                        <span class="menu-shortcut">T</span>
                    </div>
                    <div class="menu-dropdown-separator"></div>
                    <div class="menu-dropdown-item" id="autoCreateRelationshipsMenuItem" onclick="toggleAutoCreateRelationships()" style="display: flex; align-items: center; justify-content: space-between;">
                        <span id="autoCreateRelationshipsText">Auto-Create Relationships</span>
                        <span id="autoCreateRelationshipsCheckmark" style="margin-left: auto; color: #0078d4; font-weight: bold; padding-left: 12px;"></span>
                    </div>
                </div>
            </div>
            <div class="menu-item" onmouseenter="showMenuDropdown(event, 'toolsMenu')" onmouseleave="hideMenuDropdown('toolsMenu')">
                Repository
                <div id="toolsMenu" class="menu-dropdown">
                    <div class="menu-dropdown-item" onclick="openRepositoryTab('repository')">
                        <span>Elements</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="openRepositoryTab('analytics')">
                        <span>Advisor</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="openRepositoryTab('impact')">
                        <span>Impact Analysis</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="openRepositoryTab('properties')">
                        <span>Manage Properties</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="openRepositoryTab('models')">
                        <span>Models</span>
                    </div>
                    <div class="menu-dropdown-separator"></div>
                    <div class="menu-dropdown-item" onmouseenter="showTemplatesSubmenu()" onmouseleave="hideTemplatesSubmenu()" style="position: relative;">
                        <span>Templates for the Modeling Canvas</span>
                        <span style="float: right; margin-left: 8px; color: #888;"></span>
                        <div id="templatesSubmenu" class="menu-dropdown" style="position: absolute; left: 100%; top: 0; margin-left: 2px; min-width: 200px;">
                            <div class="menu-dropdown-item" onclick="applyCanvasTemplate('milkyway-map')">
                                <span>Milkyway Map</span>
                            </div>
                            <div class="menu-dropdown-item" onclick="applyCanvasTemplate('service-blueprint')">
                                <span>Service Blueprint</span>
                            </div>
                            <div class="menu-dropdown-separator"></div>
                            <div class="menu-dropdown-item" onclick="configureTemplateSegments()">
                                <span>Configure Segments</span>
                            </div>
                            <div class="menu-dropdown-separator"></div>
                            <div class="menu-dropdown-item" onclick="applyCanvasTemplate('none')">
                                <span>Remove Template</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="menu-item" onmouseenter="showMenuDropdown(event, 'helpMenu')" onmouseleave="hideMenuDropdown('helpMenu')">
                Help
                <div id="helpMenu" class="menu-dropdown">
                    <div class="menu-dropdown-item" onclick="toggleAskedChatbotModal()">
                        <span>EDGly</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="toggleEdglyNotifications()">
                        <span id="edglyNotificationsToggle">EDGly Notifications: On</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="toggleKeyboardShortcuts()">
                        <span>Keyboard Shortcuts</span>
                    </div>
                </div>
            </div>
            <div style="flex: 1;"></div>
            <div style="font-size: 11px; color: #808080; padding: 0 8px;">
                EDGly+ Modeling Canvas
            </div>
        </div>
        
        <!-- Dashboard (removed - no longer needed) -->
        <div id="dashboard" class="section" style="display: none;">
            <div class="stats-grid" id="statsGrid">
                <div class="stat-card">
                    <div class="stat-number" id="elementsCount">-</div>
                    <div class="stat-label">Element Instances</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="relationshipsCount">-</div>
                    <div class="stat-label">Relationships</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="completenessScore">-</div>
                    <div class="stat-label">Completeness Score</div>
                </div>
            </div>
            
            <!-- AI Insights Section -->
            <div id="aiInsightsSection" style="margin-top: 30px; display: none;">
                <h2 style="color: #ffffff; margin-bottom: 20px;"> AI Insights & Recommendations</h2>
                <div style="background: #2d2d44; border-radius: 12px; padding: 20px; margin-bottom: 20px; border: 1px solid rgba(255,255,255,0.1);">
                    <button class="refresh-btn" onclick="loadAIRecommendations()" style="width: 100%; padding: 12px;">
                        <span> Get AI Recommendations</span>
                    </button>
                    <div id="aiRecommendationsContent" style="margin-top: 20px;"></div>
                </div>
            </div>
            
            <!-- Enhanced Analytics Section -->
            <div id="analyticsSection" style="margin-top: 30px; display: none;">
                <h2 style="color: #ffffff; margin-bottom: 20px;">Repository Analytics</h2>
                
                <!-- Health Metrics -->
                <div class="analytics-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px;">
                    <div class="analytics-card" style="background: #2d2d44; border-radius: 12px; padding: 20px; border: 1px solid rgba(255,255,255,0.1);">
                        <h3 style="color: #ffffff; font-size: 14px; margin-bottom: 10px;">Description Coverage</h3>
                        <div class="metric-value" id="descriptionCoverage" style="font-size: 2em; font-weight: bold; color: #888888;">-</div>
                        <div class="metric-detail" id="descriptionDetail" style="color: #b0b0d0; font-size: 12px; margin-top: 5px;">-</div>
                    </div>
                    <div class="analytics-card" style="background: #2d2d44; border-radius: 12px; padding: 20px; border: 1px solid rgba(255,255,255,0.1);">
                        <h3 style="color: #ffffff; font-size: 14px; margin-bottom: 10px;">Properties Coverage</h3>
                        <div class="metric-value" id="propertiesCoverage" style="font-size: 2em; font-weight: bold; color: #888888;">-</div>
                        <div class="metric-detail" id="propertiesDetail" style="color: #b0b0d0; font-size: 12px; margin-top: 5px;">-</div>
                    </div>
                    <div class="analytics-card" style="background: #2d2d44; border-radius: 12px; padding: 20px; border: 1px solid rgba(255,255,255,0.1);">
                        <h3 style="color: #ffffff; font-size: 14px; margin-bottom: 10px;">Relationships Coverage</h3>
                        <div class="metric-value" id="relationshipsCoverage" style="font-size: 2em; font-weight: bold; color: #888888;">-</div>
                        <div class="metric-detail" id="relationshipsDetail" style="color: #b0b0d0; font-size: 12px; margin-top: 5px;">-</div>
                    </div>
                    <div class="analytics-card" style="background: #2d2d44; border-radius: 12px; padding: 20px; border: 1px solid rgba(255,255,255,0.1);">
                        <h3 style="color: #ffffff; font-size: 14px; margin-bottom: 10px;">Avg Relationships/Element</h3>
                        <div class="metric-value" id="avgRelationships" style="font-size: 2em; font-weight: bold; color: #888888;">-</div>
                    </div>
                </div>
                
                <!-- Distribution Charts -->
                <div class="charts-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 30px;">
                    <div class="chart-card" style="background: #2d2d44; border-radius: 12px; padding: 20px; border: 1px solid rgba(255,255,255,0.1);">
                        <h3 style="color: #ffffff; font-size: 16px; margin-bottom: 15px;">Facet Distribution</h3>
                        <div id="facetChart" style="min-height: 200px;"></div>
                    </div>
                    <div class="chart-card" style="background: #2d2d44; border-radius: 12px; padding: 20px; border: 1px solid rgba(255,255,255,0.1);">
                        <h3 style="color: #ffffff; font-size: 16px; margin-bottom: 15px;">Element Type Distribution</h3>
                        <div id="elementTypeChart" style="min-height: 200px;"></div>
                    </div>
                    <div class="chart-card" style="background: #2d2d44; border-radius: 12px; padding: 20px; border: 1px solid rgba(255,255,255,0.1);">
                        <h3 style="color: #ffffff; font-size: 16px; margin-bottom: 15px;">RAG Status Distribution</h3>
                        <div id="ragChart" style="min-height: 200px;"></div>
                    </div>
                </div>
                
                <!-- Issues Section -->
                <div class="issues-section" style="background: #2d2d44; border-radius: 12px; padding: 20px; border: 1px solid rgba(255,255,255,0.1); margin-bottom: 30px;">
                    <h3 style="color: #ffffff; font-size: 16px; margin-bottom: 15px;">Repository Issues</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                        <div>
                            <h4 style="color: #ff6b6b; font-size: 14px; margin-bottom: 10px;">Orphaned Instances (<span id="orphanedCount">0</span>)</h4>
                            <div id="orphanedList" style="max-height: 150px; overflow-y: auto; font-size: 12px; color: #b0b0d0;"></div>
                        </div>
                        <div>
                            <h4 style="color: #ffa500; font-size: 14px; margin-bottom: 10px;">Incomplete Instances (<span id="incompleteCount">0</span>)</h4>
                            <div id="incompleteList" style="max-height: 150px; overflow-y: auto; font-size: 12px; color: #b0b0d0;"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="dashboard">
                <div class="dashboard-card" onclick="window.showSection('chatbot')">
                    <div class="dashboard-card-icon"><img src="/images/ask-ed_OLD.svg" alt="EDGly" onerror="this.style.display='none';" style="max-width: 96px; max-height: 96px;"></div><h2>EDGly</h2>
                    <p>Ask questions about your repository and EDGY Enterprise Design principles</p>
                </div>
                
                <div class="dashboard-card" onclick="window.showSection('addElement')">
                    <div class="dashboard-card-icon"><img src="/images/add-elements.png" alt="Add Elements" onerror="this.style.display='none';" style="max-width: 96px; max-height: 96px;"></div><h2>Add Elements</h2>
                    <p>Create new domain model elements with enterprise, facet, and element details</p>
                </div>
                
                <div class="dashboard-card" onclick="window.showSection('modelingCanvas')">
                    <div class="dashboard-card-icon"><img src="/images/diagram-modeller.png" alt="Modeling Canvas" onerror="this.style.display='none';" style="max-width: 96px; max-height: 96px;"></div><h2>Modeling Canvas</h2>
                    <p>Drag and drop elements to create visual models with automatic relationship connections</p>
                </div>
                
                
            </div>
        </div>
        
        <!-- Add Element Section -->
        <div id="addElement" class="section">
            
            <div class="records-container">
                <div class="records-header">
                    <h2 class="section-title"><img src="/images/add-elements.png" alt="All Element Instances" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';" style="width: 64px; height: 64px; vertical-align: middle; margin-right: 8px; object-fit: contain;"><span>All Element Instances</span></h2>
                    <button class="refresh-btn" onclick="loadRecords()"><span>Refresh</span>
                    </button>
                </div>
                
                <!-- Advanced Search/Filter Section -->
                <div style="background: #2d2d44; border-radius: 12px; padding: 20px; margin-bottom: 20px; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="color: #ffffff; font-size: 16px; margin: 0;">Search & Filter</h3>
                        <button class="refresh-btn" onclick="clearFilters()" style="padding: 6px 12px; font-size: 12px;">
                            <span>Clear Filters</span>
                        </button>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div>
                            <label style="color: #b0b0d0; font-size: 12px; display: block; margin-bottom: 5px;">Search Name/Description</label>
                            <input type="text" id="searchText" placeholder="Search..." style="width: 100%; padding: 8px; background: #1a1a2e; border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0;" oninput="filterRecords()">
                        </div>
                        <div>
                            <label style="color: #b0b0d0; font-size: 12px; display: block; margin-bottom: 5px;">Element Type</label>
                            <select id="filterElementType" style="width: 100%; padding: 8px; background: #1a1a2e; border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0;" onchange="filterRecords()">
                                <option value="">All Types</option>
                            </select>
                        </div>
                        <div>
                            <label style="color: #b0b0d0; font-size: 12px; display: block; margin-bottom: 5px;">Facet</label>
                            <select id="filterFacet" style="width: 100%; padding: 8px; background: #1a1a2e; border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0;" onchange="filterRecords()">
                                <option value="">All Facets</option>
                                <option value="Base">Base</option>
                                <option value="Architecture">Architecture</option>
                                <option value="Identity">Identity</option>
                                <option value="Experience">Experience</option>
                                <option value="Product">Product</option>
                                <option value="Organisation">Organisation</option>
                                <option value="Brand">Brand</option>
                            </select>
                        </div>
                        <div>
                            <label style="color: #b0b0d0; font-size: 12px; display: block; margin-bottom: 5px;">Enterprise</label>
                            <select id="filterEnterprise" style="width: 100%; padding: 8px; background: #1a1a2e; border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0;" onchange="filterRecords()">
                                <option value="">All Enterprises</option>
                            </select>
                        </div>
                        <div>
                            <label style="color: #b0b0d0; font-size: 12px; display: block; margin-bottom: 5px;">Has Properties</label>
                            <select id="filterHasProperties" style="width: 100%; padding: 8px; background: #1a1a2e; border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0;" onchange="filterRecords()">
                                <option value="">Any</option>
                                <option value="yes">Yes</option>
                                <option value="no">No</option>
                            </select>
                        </div>
                    </div>
                    <div style="margin-top: 15px; display: flex; gap: 10px; align-items: center;">
                        <button class="refresh-btn" onclick="saveFilterPreset()" style="padding: 6px 12px; font-size: 12px;">
                            <span> Save Filter Preset</span>
                        </button>
                        <select id="filterPresets" style="padding: 6px 12px; background: #1a1a2e; border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0; font-size: 12px;" onchange="loadFilterPreset(this.value)">
                            <option value="">Load Saved Filter...</option>
                        </select>
                        <span id="filterResultsCount" style="color: #b0b0d0; font-size: 12px; margin-left: auto;"></span>
                    </div>
                </div>
                
                <div id="recordsList" class="records-list">
                    <div class="empty-state">Loading records...</div>
                </div>
            </div>
        </div>

        <!-- Dialog Backdrop -->
        <div id="dialogBackdrop" class="dialog-backdrop" onclick="closeAllDialogs()"></div>
        
        <!-- Modeling Canvas Section -->
        <div id="modelingCanvas" class="section active">
            <div id="canvasMainContainer" style="display: flex; height: 100%; gap: 15px; width: 100%; max-width: 100%;">
                <!-- Element Palette Sidebar -->
                <div id="elementPalette" style="width: 180px; background: #2d2d30; padding: 0; overflow: visible; position: relative; border: 1px solid #3e3e42; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
                    <!-- Palette Header with Position Controls -->
                    <div id="paletteHeader" style="padding: 12px 16px; background: #1e1e1e; display: flex; align-items: center; justify-content: flex-start; cursor: move; border-bottom: 1px solid #3e3e42;" title="Drag to move (floating mode)">
                        <div id="palettePositionControls" style="display: flex; gap: 4px;">
                            <button class="palette-position-btn" data-position="left" title="Left Side" style="padding: 4px 8px; background: transparent; border: none; border-radius: 4px; color: #808080; cursor: pointer; font-size: 12px; transition: background-color 0.15s;" onmouseover="this.style.background='#3e3e42'; this.style.color='#c0c0c0'" onmouseout="this.style.background='transparent'; this.style.color='#808080'"></button>
                            <button class="palette-position-btn" data-position="right" title="Right Side" style="padding: 4px 8px; background: transparent; border: none; border-radius: 4px; color: #808080; cursor: pointer; font-size: 12px; transition: background-color 0.15s;" onmouseover="this.style.background='#3e3e42'; this.style.color='#c0c0c0'" onmouseout="this.style.background='transparent'; this.style.color='#808080'"></button>
                            <button class="palette-position-btn" data-position="floating" title="Floating" style="padding: 4px 8px; background: transparent; border: none; border-radius: 4px; color: #808080; cursor: pointer; font-size: 12px; transition: background-color 0.15s;" onmouseover="this.style.background='#3e3e42'; this.style.color='#c0c0c0'" onmouseout="this.style.background='transparent'; this.style.color='#808080'"></button>
                        </div>
                    </div>
                    <div style="padding: 15px; overflow-y: auto; max-height: calc(100vh - 90px); background: #2d2d30;">
                        <div id="paletteSearchContainer" style="margin-bottom: 14px; position: relative;">
                            <input type="text" id="elementSearchInput" placeholder="Search element occurrences..." class="palette-search-input"
                                   title="Search element occurrences by name or type">
                            <div id="paletteSearchResults" class="palette-search-results" style="display: none;">
                                <div id="paletteSearchList" class="palette-search-list"></div>
                                <div id="paletteSearchEmpty" class="palette-menu-empty" style="display: none;">No occurrences found</div>
                            </div>
                        </div>
                        <!-- Elements Section -->
                        <div class="palette-section">
                            <div class="palette-section-header" onclick="togglePaletteSection('elementTypes')" style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; user-select: none; margin-bottom: 10px; padding: 4px 0;">
                                <h3 style="color: #ffffff; margin: 0; font-size: 14px; font-weight: 600;">Elements</h3>
                                <span class="palette-section-chevron" id="elementTypes-chevron" style="color: #808080; font-size: 12px; transition: transform 0.2s;"></span>
                            </div>
                            <div id="elementTypes-content" class="palette-section-content" style="overflow: hidden; transition: max-height 0.3s ease-out;">
                                <div id="elementPaletteList" style="display: flex; flex-direction: column; gap: 12px;">
                                    <!-- Element cards grouped by facet will be populated here -->
                                </div>
                            </div>
                        </div>
                        
                        <!-- Metrics & Tags Section -->
                        <div class="palette-section" style="margin-top: 20px;">
                            <div class="palette-section-header" onclick="togglePaletteSection('properties')" style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; user-select: none; margin-bottom: 10px; padding: 4px 0;">
                                <h3 style="color: #ffffff; margin: 0; font-size: 14px; font-weight: 600;">Metrics & Tags</h3>
                                <span class="palette-section-chevron" id="properties-chevron" style="color: #808080; font-size: 12px; transition: transform 0.2s;"></span>
                            </div>
                            <div id="properties-content" class="palette-section-content" style="overflow: hidden; transition: max-height 0.3s ease-out;">
                                <div id="propertyPaletteList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; max-height: 300px; overflow-y: auto; overflow-x: hidden;">
                                    <!-- Property cards will be populated here -->
                                </div>
                            </div>
                        </div>
                        
                        <!-- Templates Section -->
                        <div class="palette-section" style="margin-top: 20px;">
                            <div class="palette-section-header" onclick="togglePaletteSection('templates')" style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; user-select: none; margin-bottom: 10px; padding: 4px 0;">
                                <h3 style="color: #ffffff; margin: 0; font-size: 14px; font-weight: 600;">Templates</h3>
                                <span class="palette-section-chevron" id="templates-chevron" style="color: #808080; font-size: 12px; transition: transform 0.2s;"></span>
                            </div>
                            <div id="templates-content" class="palette-section-content" style="overflow: hidden; transition: max-height 0.3s ease-out;">
                                <div id="templatePaletteList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px;">
                                    <!-- Template cards will be populated here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Palette Instance Context Menu -->
                <div id="paletteInstanceMenu" style="max-width: 300px; max-height: 400px; overflow: hidden;">
                    <div class="palette-menu-header">
                        <span id="paletteMenuElementType">Existing Instances</span>
                        <span id="paletteMenuInstanceCount"></span>
                    </div>
                    <div id="paletteInstanceList" style="max-height: 320px; overflow-y: auto;">
                        <!-- Instance items will be populated here -->
                    </div>
                    <div id="paletteInstanceEmpty" class="palette-menu-empty">
                        No instances of this element type yet
                    </div>
                </div>
                
                <!-- Canvas Area -->
                <div id="canvasArea" style="flex: 1; display: flex; flex-direction: column; background: #1e1e1e; overflow: hidden;">
                    <!-- Toast Notification Container -->
                    <div id="canvasToastContainer" style="position: fixed; top: 20px; right: 20px; z-index: 100000; display: flex; flex-direction: column; gap: 10px; pointer-events: none;"></div>
                    
                    <!-- Custom Confirm Dialog -->
                    <div id="canvasConfirmDialog" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 100001; align-items: center; justify-content: center;">
                        <div style="background: #2d2d44; padding: 30px; border-radius: 8px; min-width: 400px; max-width: 500px; border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
                            <h3 style="color: #ffffff; margin-bottom: 20px; font-size: 18px;">Confirm</h3>
                            <p id="canvasConfirmMessage" style="color: #e0e0e0; margin-bottom: 25px; font-size: 14px; line-height: 1.5;"></p>
                            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                                <button id="canvasConfirmCancel" class="refresh-btn" style="padding: 8px 16px;">Cancel</button>
                                <button id="canvasConfirmOk" class="refresh-btn" style="padding: 8px 16px; background: #667eea;">OK</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Toolbar -->
                    <div id="canvasToolbar" style="background: #2d2d30; padding: 8px 12px; border-bottom: 1px solid #3e3e42; display: flex; gap: 8px; align-items: center; height: 40px;">
                        <button class="refresh-btn" onclick="undoCanvasAction()" style="padding: 6px 12px; font-size: 13px;" id="undoBtn" title="Undo">
                            <span>Undo</span>
                        </button>
                        <button class="refresh-btn" onclick="redoCanvasAction()" style="padding: 6px 12px; font-size: 13px;" id="redoBtn" title="Redo">
                            <span>Redo</span>
                        </button>
                        <div style="width: 1px; height: 20px; background: #3e3e42; margin: 0 4px;"></div>
                        <button class="refresh-btn" onclick="saveCanvasModel()" style="padding: 6px 12px; font-size: 13px;">
                            <span>Save Model</span>
                        </button>
                        <button class="refresh-btn" onclick="loadCanvasModels()" style="padding: 6px 12px; font-size: 13px;">
                            <span>Load Model</span>
                        </button>
                        <button class="refresh-btn" onclick="clearCanvas()" style="padding: 6px 12px; font-size: 13px;">
                            <span>Clear</span>
                        </button>
                        <div style="width: 1px; height: 20px; background: #3e3e42; margin: 0 4px;"></div>
                        <!-- Canvas Info Display -->
                        <div id="canvasInfoDisplay" style="display: flex; gap: 15px; align-items: center; color: #b0b0d0; font-size: 12px;">
                            <span id="canvasModelName" style="font-weight: 600; color: #ffffff;"></span>
                            <span id="canvasElementCount" style="color: #667eea;">0 Elements</span>
                            <span id="canvasRelationshipCount" style="color: #667eea;">0 Relationships</span>
                        </div>
                        <div style="margin-left: auto; display: flex; gap: 10px; align-items: center;">
                            <!-- Element Search -->
                            
                            <button class="refresh-btn" onclick="toggleKeyboardShortcuts()" style="padding: 6px 12px; font-size: 13px;" id="shortcutsBtn" title="Keyboard Shortcuts (?)">
                                <span>?</span>
                            </button>
                            <!-- Layer Management Button -->
                            <button class="refresh-btn" onclick="toggleLayerManagement()" style="padding: 6px 12px; font-size: 13px;" id="layerManagementBtn" title="Layer Management">
                                <span>Layers</span>
                            </button>
                            <button class="refresh-btn" onclick="toggleGridlines()" style="padding: 6px 12px; font-size: 13px;" id="gridlinesToggleBtn" title="Toggle Gridlines">
                                <span id="gridlinesToggleIcon"></span>
                            </button>
                            <button class="refresh-btn" onclick="toggleFullscreen()" style="padding: 6px 12px; font-size: 13px;" id="fullscreenToggleBtn" title="Toggle Fullscreen">
                                <span id="fullscreenToggleIcon"></span>
                            </button>
                            <button class="refresh-btn" onclick="toggleCanvasTheme()" style="padding: 6px 12px; font-size: 13px;" id="themeToggleBtn" title="Toggle Dark/Light Mode">
                                <span id="themeToggleIcon">Theme</span>
                            </button>
                            <button class="refresh-btn" onclick="zoomCanvas('out')" style="padding: 6px 12px; font-size: 13px;">
                                <span></span>
                            </button>
                            <span id="zoomLevel" style="color: #ffffff; font-size: 13px; min-width: 50px; text-align: center;">100%</span>
                            <button class="refresh-btn" onclick="zoomCanvas('in')" style="padding: 6px 12px; font-size: 13px;">
                                <span>+</span>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Canvas Container -->
                    <div id="canvasContainer" style="flex: 1; position: relative; overflow: auto; background: #1a1a1a; background-image: 
                        linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
                        background-size: 20px 20px;">
                        <!-- EDGly Chatbot Button -->
                        <div id="askedChatbotButton" onclick="toggleAskedChatbotModal()" 
                             style="position: absolute; bottom: 20px; right: 20px; width: 120px; height: auto; 
                                    z-index: 2005; cursor: pointer; transition: transform 0.2s, opacity 0.2s;
                                    display: flex; flex-direction: column; align-items: center; justify-content: center;"
                             onmouseover="this.style.transform='scale(1.1)'; this.style.opacity='0.9';"
                             onmouseout="this.style.transform='scale(1)'; this.style.opacity='1';"
                             title="EDGly">
                            <div class="edgly-avatar" style="width: 120px; height: 120px; display: flex; align-items: center; justify-content: center;">
                            <img src="/images/ask-ed_OLD.svg" alt="EDGly" 
                                 style="width: 100%; height: 100%; object-fit: contain; pointer-events: none;"
                                 onerror="this.style.display='none';">
                            </div>
                            <div id="edglyCommentaryBubble" class="edgly-commentary-bubble" aria-live="polite"></div>
                        </div>
                        
                        <!-- Template Layer (for Milkyway Map and other templates) -->
                        <svg id="templateLayer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto; z-index: 0; display: none; cursor: pointer;">
                            <defs>
                                <!-- Filters and gradients for template styling -->
                            </defs>
                        </svg>
                        
                        <!-- Minimap -->
                        <div id="canvasMinimap" style="position: absolute; bottom: 20px; right: 90px; width: 200px; height: 150px; 
                             background: rgba(45, 45, 68, 0.95); border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; 
                             z-index: 1000; display: none; overflow: hidden; cursor: pointer;">
                            <div style="padding: 8px; background: rgba(0,0,0,0.3); border-bottom: 1px solid rgba(255,255,255,0.1); 
                                 font-size: 11px; color: #ffffff; font-weight: 600;">Minimap</div>
                            <svg id="minimapSvg" style="width: 100%; height: calc(100% - 30px); display: block;"></svg>
                            <div id="minimapViewport" style="position: absolute; border: 2px solid #667eea; pointer-events: none;"></div>
                        </div>
                        <!-- Empty State (hidden) -->
                        <div id="canvasEmptyState" style="display: none;"></div>
                        
                        <!-- Snap Guides Layer -->
                        <svg id="snapGuidesLayer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 3; display: none;">
                            <!-- Snap guide lines will be drawn here -->
                        </svg>
                        
                        <!-- Connection Lines Layer -->
                        <svg id="connectionsLayer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;">
                            <defs>
                            </defs>
                        </svg>
                        
                        <!-- Elements Layer -->
                        <div id="elementsLayer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none;">
                            <!-- Element instances will be added here -->
                        </div>
                        
                        <!-- Property Instances Layer -->
                        <div id="propertyInstancesLayer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; pointer-events: none;">
                            <!-- Property instances will be added here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Template Segments Configuration Modal -->
            <div id="templateSegmentsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10001; align-items: center; justify-content: center;">
                <div style="background: #2d2d30; padding: 30px; border-radius: 8px; min-width: 500px; max-width: 700px; max-height: 80vh; overflow-y: auto; border: 1px solid #3e3e42; box-shadow: 0 4px 12px rgba(0,0,0,0.3); position: relative;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="color: #ffffff; margin: 0; font-size: 18px;">Configure Template Segments</h3>
                        <button onclick="closeTemplateSegmentsModal()" style="background: transparent; border: none; color: #c0c0c0; cursor: pointer; font-size: 18px; padding: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; transition: background-color 0.15s; outline: none;" onmouseover="this.style.background='#3e3e3e'" onmouseout="this.style.background='transparent'"></button>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="color: #e0e0e0; display: block; margin-bottom: 8px; font-size: 14px;">Number of Segments:</label>
                        <input type="number" id="segmentCountInput" min="2" max="12" value="4" 
                               style="width: 100px; padding: 8px; background: #1e1e1e; border: 1px solid #3e3e42; border-radius: 4px; color: #ffffff; font-size: 14px;"
                               onchange="updateSegmentInputs()">
                    </div>
                    <div id="segmentInputsContainer" style="margin-bottom: 20px;">
                        <!-- Segment name inputs will be generated here -->
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button class="refresh-btn" onclick="closeTemplateSegmentsModal()" style="padding: 8px 16px;">Cancel</button>
                        <button class="refresh-btn" onclick="saveTemplateSegments()" style="padding: 8px 16px; background: #0078d4;">Save</button>
                    </div>
                </div>
            </div>
            
            <!-- Model Name Input Modal -->
            <div id="saveModelModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; align-items: center; justify-content: center;">
                <div style="background: #2d2d30; padding: 30px; border-radius: 8px; min-width: 400px; max-width: 700px; border: 1px solid #3e3e42; box-shadow: 0 4px 12px rgba(0,0,0,0.3); position: relative;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="color: #ffffff; margin: 0; font-size: 18px;">Save Canvas Model</h3>
                        <button onclick="closeSaveModal()" style="background: transparent; border: none; color: #c0c0c0; cursor: pointer; font-size: 18px; padding: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; transition: background-color 0.15s; outline: none;" onmouseover="this.style.background='#3e3e3e'" onmouseout="this.style.background='transparent'"></button>
                    </div>
                    <input type="text" id="modelNameInput" placeholder="Enter model name..." 
                           style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #3e3e42; background: #1e1e1e; color: #ffffff; margin-bottom: 10px; font-size: 14px; box-sizing: border-box;">
                    <textarea id="modelDescriptionInput" placeholder="Description (optional)" 
                              style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #3e3e42; background: #1e1e1e; color: #ffffff; margin-bottom: 15px; font-size: 14px; min-height: 80px; resize: vertical; box-sizing: border-box;"></textarea>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button class="refresh-btn" onclick="closeSaveModal()" style="padding: 8px 16px;">Cancel</button>
                        <button class="refresh-btn" onclick="confirmSaveModel()" style="padding: 8px 16px; background: #667eea;">Save</button>
                    </div>
                </div>
            </div>
            
            <!-- Load Model Modal -->
            <div id="loadModelModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; align-items: center; justify-content: center;">
                <div style="background: #2d2d30; padding: 30px; border-radius: 8px; min-width: 500px; max-width: 700px; max-height: 80vh; overflow-y: auto; border: 1px solid #3e3e42; box-shadow: 0 4px 12px rgba(0,0,0,0.3); position: relative;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="color: #ffffff; margin: 0; font-size: 18px;">Load Canvas Model</h3>
                        <button onclick="closeLoadModal()" style="background: transparent; border: none; color: #c0c0c0; cursor: pointer; font-size: 18px; padding: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; transition: background-color 0.15s; outline: none;" onmouseover="this.style.background='#3e3e3e'" onmouseout="this.style.background='transparent'"></button>
                    </div>
                    <div id="savedModelsList" style="margin-bottom: 15px;">
                        <!-- Saved models will be listed here -->
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button class="refresh-btn" onclick="closeLoadModal()" style="padding: 8px 16px;">Cancel</button>
                    </div>
                </div>
            </div>

            <!-- Impact Analysis Modal -->
            <div id="impactAnalysisModal" class="modal" style="z-index: 10030;">
                <div class="modal-content" style="max-width: 600px;">
                    <div class="plantuml-header">
                        <h2 style="margin: 0;">Impact Analysis</h2>
                        <span class="close" onclick="closeImpactAnalysisModal()">&times;</span>
                    </div>
                    <div class="dialog-body" style="padding: 16px;">
                        <div style="color: #b0b0d0; font-size: 12px; margin-bottom: 12px;">
                            Build a multi-hop impact model starting from any occurrence in the repository.
                        </div>
                        <div style="margin-bottom: 12px; display: flex; gap: 8px;">
                            <input id="impactSearchInput" type="text" placeholder="Search occurrences (name, type, description)" style="flex: 1; padding: 8px; border: 1px solid #3e3e42; border-radius: 4px; background: #1e1e1e; color: #e0e0e0; font-size: 12px;">
                            <button class="refresh-btn" onclick="searchImpactOccurrences()" style="padding: 6px 12px; font-size: 12px;">Search</button>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 6px; color: #cccccc; font-size: 12px;">Source Occurrence</label>
                            <select id="impactSourceInstance" style="width: 100%; padding: 8px; border: 1px solid #3e3e42; border-radius: 4px; background: #1e1e1e; color: #e0e0e0; font-size: 12px;">
                                <option value="">Loading...</option>
                            </select>
                        </div>
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            <div style="flex: 1; min-width: 120px;">
                                <label style="display: block; margin-bottom: 6px; color: #cccccc; font-size: 12px;">Depth (hops)</label>
                                <input id="impactDepth" type="number" min="1" max="6" value="2" style="width: 100%; padding: 8px; border: 1px solid #3e3e42; border-radius: 4px; background: #1e1e1e; color: #e0e0e0; font-size: 12px;">
                            </div>
                            <div style="flex: 1; min-width: 120px;">
                                <label style="display: block; margin-bottom: 6px; color: #cccccc; font-size: 12px;">Direction</label>
                                <select id="impactDirection" style="width: 100%; padding: 8px; border: 1px solid #3e3e42; border-radius: 4px; background: #1e1e1e; color: #e0e0e0; font-size: 12px;">
                                    <option value="both">Both</option>
                                    <option value="outgoing">Outgoing</option>
                                    <option value="incoming">Incoming</option>
                                </select>
                            </div>
                        </div>
                        <div style="margin-top: 12px;">
                            <label style="display: block; margin-bottom: 6px; color: #cccccc; font-size: 12px;">Relationship Types (optional)</label>
                            <select id="impactRelationshipTypes" multiple size="4" style="width: 100%; padding: 8px; border: 1px solid #3e3e42; border-radius: 4px; background: #1e1e1e; color: #e0e0e0; font-size: 12px;">
                            </select>
                            <div style="color: #808080; font-size: 11px; margin-top: 6px;">Hold Ctrl/Cmd to select multiple types.</div>
                        </div>
                    </div>
                    <div class="dialog-footer" style="display: flex; justify-content: flex-end; gap: 8px;">
                        <button class="refresh-btn" onclick="closeImpactAnalysisModal()" style="padding: 6px 12px; font-size: 12px;">Cancel</button>
                        <button class="refresh-btn" onclick="runImpactAnalysis()" style="padding: 6px 12px; font-size: 12px;">Create Impact Model</button>
                    </div>
                </div>
            </div>
            
            <!-- EDGly Chatbot Modal -->
            <div id="askedChatbotModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10002; align-items: center; justify-content: center;">
                <div style="background: #2d2d30; border-radius: 8px; width: 450px; max-width: 90vw; height: calc(100vh - 40px); max-height: 800px; display: flex; flex-direction: column; border: 1px solid #3e3e42; box-shadow: 0 4px 12px rgba(0,0,0,0.3); position: relative;">
                    <!-- Modal Header -->
                    <div style="padding: 12px 16px; border-bottom: 1px solid #3e3e42; display: flex; justify-content: space-between; align-items: center; background: #1e1e1e;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <h3 style="color: #ffffff; margin: 0; font-size: 18px; font-weight: 400;">EDGly</h3>
                        </div>
                        <button onclick="toggleAskedChatbotModal()" style="background: transparent; border: none; color: #c0c0c0; cursor: pointer; font-size: 18px; padding: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; transition: background-color 0.15s; outline: none;" onmouseover="this.style.background='#3e3e3e'" onmouseout="this.style.background='transparent'"></button>
                    </div>
                    
                    <!-- Modal Content -->
                    <div style="flex: 1; display: flex; flex-direction: column; overflow: hidden; background: #2d2d30;">
                        <!-- Chat Messages -->
                        <div id="askedModalChatMessages" style="flex: 1; overflow-y: auto; padding: 16px; background: #1e1e1e;">
                            <div class="chat-message assistant">
                                <div class="chat-avatar"><img src="/images/ask-ed_OLD.svg" alt="EDGly" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;"></div>
                                <div class="chat-content">
                                    <p>Hello! I'm EDGly. I can help you understand your repository elements, relationships, and EDGY Enterprise Design concepts. Try asking me about your data or EDGY principles!</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Chat Suggestions -->
                        <div style="padding: 12px 16px; border-top: 1px solid #3e3e42; border-bottom: 1px solid #3e3e42; max-height: 120px; overflow-y: auto; background: #252526;">
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                <div class="suggestion-chip" onclick="askQuestionModal('Summarize repository warnings and rule violations')" style="font-size: 11px; padding: 4px 8px;">Repo Warnings</div>
                                <div class="suggestion-chip" onclick="askQuestionModal('Which elements have missing descriptions or properties?')" style="font-size: 11px; padding: 4px 8px;">Missing Info</div>
                                <div class="suggestion-chip" onclick="askQuestionModal('Show orphaned elements or relationship gaps')" style="font-size: 11px; padding: 4px 8px;">Gaps</div>
                                <div class="suggestion-chip" onclick="askQuestionModal('Give top insights and cleanup actions for this repository')" style="font-size: 11px; padding: 4px 8px;">Top Actions</div>
                            </div>
                        </div>
                        
                        <!-- Chat Input -->
                        <div style="padding: 12px 16px; border-top: 1px solid #3e3e42; background: #252526;">
                            <div class="chat-input-container" style="display: flex; gap: 8px;">
                                <input type="text" class="chat-input" id="askedModalChatInput" placeholder="Ask me anything..." 
                                       style="flex: 1; padding: 6px 12px; border-radius: 4px; border: 1px solid #3e3e42; background: #1e1e1e; color: #e0e0e0; font-size: 12px; outline: none;"
                                       onkeypress="handleAskedModalChatKeyPress(event)">
                                <button class="chat-send-btn" onclick="sendAskedModalChatMessage()" style="padding: 6px 16px; border-radius: 4px; background: #0078d4; border: none; color: #ffffff; cursor: pointer; font-size: 12px; font-weight: 400; min-height: 32px;">
                                    <span>Send</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Layer Management Panel -->
            <div id="layerManagementPanel" style="display: none; position: fixed; top: 60px; right: 20px; background: #2d2d30; border: 1px solid #3e3e42; border-radius: 8px; padding: 15px; min-width: 200px; z-index: 10001; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="color: #ffffff; margin: 0; font-size: 18px; font-weight: 600;">Layer Visibility</h3>
                    <button onclick="toggleLayerManagement()" style="background: transparent; border: none; color: #c0c0c0; cursor: pointer; font-size: 18px; padding: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; transition: background-color 0.15s; outline: none;" onmouseover="this.style.background='#3e3e3e'" onmouseout="this.style.background='transparent'"></button>
                </div>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <label style="display: flex; align-items: center; gap: 10px; color: #e0e0e0; font-size: 13px; cursor: pointer;">
                        <input type="checkbox" id="layerElementsToggle" checked style="width: 16px; height: 16px; cursor: pointer;">
                        <span>Elements</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 10px; color: #e0e0e0; font-size: 13px; cursor: pointer;">
                        <input type="checkbox" id="layerPropertiesToggle" checked style="width: 16px; height: 16px; cursor: pointer;">
                    <span>Properties</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 10px; color: #e0e0e0; font-size: 13px; cursor: pointer;">
                        <input type="checkbox" id="layerConnectionsToggle" checked style="width: 16px; height: 16px; cursor: pointer;">
                        <span>Connections</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 10px; color: #e0e0e0; font-size: 13px; cursor: pointer;">
                        <input type="checkbox" id="layerGridToggle" checked style="width: 16px; height: 16px; cursor: pointer;">
                        <span>Grid</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 10px; color: #e0e0e0; font-size: 13px; cursor: pointer;">
                        <input type="checkbox" id="layerSnapToGridToggle" checked style="width: 16px; height: 16px; cursor: pointer;">
                        <span>Snap to Grid</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 10px; color: #e0e0e0; font-size: 13px; cursor: pointer;">
                        <input type="checkbox" id="layerElementShadowsToggle" checked style="width: 16px; height: 16px; cursor: pointer;">
                        <span>Shadows</span>
                    </label>
                </div>
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <label style="display: flex; align-items: center; gap: 10px; color: #e0e0e0; font-size: 13px; cursor: pointer;">
                        <input type="checkbox" id="snapGuidesToggle" checked style="width: 16px; height: 16px; cursor: pointer;">
                        <span>Snap Guides</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 10px; color: #e0e0e0; font-size: 13px; cursor: pointer; margin-top: 10px;">
                        <input type="checkbox" id="layerMinimapToggle" checked style="width: 16px; height: 16px; cursor: pointer;">
                        <span>Minimap</span>
                    </label>
                </div>
            </div>
            
            <!-- Repository Modal -->
            <div id="repositoryModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; align-items: center; justify-content: center;">
                <div style="background: #2d2d30; padding: 24px; border-radius: 8px; width: 900px; max-width: 92vw; max-height: 90vh; overflow: hidden; border: 1px solid #3e3e42; box-shadow: 0 4px 12px rgba(0,0,0,0.3); position: relative; display: flex; flex-direction: column;">
                    <div class="draggable-handle" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h3 style="color: #ffffff; margin: 0; font-size: 18px;">Repository</h3>
                        <button onclick="toggleRepositoryModal()" style="background: transparent; border: none; color: #c0c0c0; cursor: pointer; font-size: 18px; padding: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; transition: background-color 0.15s; outline: none;" onmouseover="this.style.background='#3e3e3e'" onmouseout="this.style.background='transparent'"></button>
                    </div>
                    <div class="repository-tabs">
                        <button class="repository-tab-btn active" data-tab="repository" onclick="setRepositoryTab('repository')">Elements</button>
                        <button class="repository-tab-btn" data-tab="analytics" onclick="setRepositoryTab('analytics')">Advisor</button>
                        <button class="repository-tab-btn" data-tab="impact" onclick="setRepositoryTab('impact')">Impact Analysis</button>
                        <button class="repository-tab-btn" data-tab="properties" onclick="setRepositoryTab('properties')">Manage Properties</button>
                        <button class="repository-tab-btn" data-tab="models" onclick="setRepositoryTab('models')">Models</button>
                    </div>
                    <div class="repository-tab-content">
                        <div id="repositoryTab-repository" class="repository-tab-panel active">
                            <div style="flex: 1; overflow-y: auto;">
                                <div id="repositoryModalRecordsList" style="flex: 1; overflow-y: auto;" class="records-list">
                                    <div class="empty-state">Loading records...</div>
                                </div>
                            </div>
                        </div>
                        <div id="repositoryTab-analytics" class="repository-tab-panel">
                            <div style="display: flex; align-items: center; margin-bottom: 10px; padding-top: 2px;">
                                <div style="color: #e0e0e0; font-size: 14px; font-weight: 600;">Repository Advice Meter</div>
                            </div>
                            <div id="analyticsContent" style="flex: 1; overflow-y: auto; color: #e0e0e0;">
                                <div style="text-align: center; padding: 40px; color: #808080;">
                                    <div style="font-size: 48px; margin-bottom: 10px;"></div>
                                    <div>Loading analytics...</div>
                                </div>
                            </div>
                        </div>
                        <div id="repositoryTab-impact" class="repository-tab-panel">
                            <div style="display: flex; align-items: center; margin-bottom: 10px; padding-top: 2px;">
                                <div style="color: #e0e0e0; font-size: 14px; font-weight: 600;">Impact Analysis</div>
                            </div>
                            <div style="color: #b0b0d0; font-size: 12px; margin-bottom: 12px;">
                                Build a multi-hop impact model starting from any occurrence in the repository.
                            </div>
                            <div style="margin-bottom: 12px; display: flex; gap: 8px;">
                                <input id="impactSearchInput" type="text" placeholder="Search occurrences (name, type, description)" style="flex: 1; padding: 8px; border: 1px solid #3e3e42; border-radius: 4px; background: #1e1e1e; color: #e0e0e0; font-size: 12px;">
                                <button class="refresh-btn" onclick="searchImpactOccurrences()" style="padding: 6px 12px; font-size: 12px;">Search</button>
                            </div>
                            <div style="margin-bottom: 12px;">
                                <label style="display: block; margin-bottom: 6px; color: #cccccc; font-size: 12px;">Source Occurrence</label>
                                <select id="impactSourceInstance" style="width: 100%; padding: 8px; border: 1px solid #3e3e42; border-radius: 4px; background: #1e1e1e; color: #e0e0e0; font-size: 12px;">
                                    <option value="">Search repository occurrences...</option>
                                </select>
                            </div>
                            <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                                <div style="flex: 1; min-width: 120px;">
                                    <label style="display: block; margin-bottom: 6px; color: #cccccc; font-size: 12px;">Depth (hops)</label>
                                    <input id="impactDepth" type="number" min="1" max="6" value="2" style="width: 100%; padding: 8px; border: 1px solid #3e3e42; border-radius: 4px; background: #1e1e1e; color: #e0e0e0; font-size: 12px;">
                                </div>
                                <div style="flex: 1; min-width: 120px;">
                                    <label style="display: block; margin-bottom: 6px; color: #cccccc; font-size: 12px;">Direction</label>
                                    <select id="impactDirection" style="width: 100%; padding: 8px; border: 1px solid #3e3e42; border-radius: 4px; background: #1e1e1e; color: #e0e0e0; font-size: 12px;">
                                        <option value="both">Both</option>
                                        <option value="outgoing">Outgoing</option>
                                        <option value="incoming">Incoming</option>
                                    </select>
                                </div>
                            </div>
                            <div style="margin-top: 12px;">
                                <label style="display: block; margin-bottom: 6px; color: #cccccc; font-size: 12px;">Relationship Types (optional)</label>
                                <select id="impactRelationshipTypes" multiple size="4" style="width: 100%; padding: 8px; border: 1px solid #3e3e42; border-radius: 4px; background: #1e1e1e; color: #e0e0e0; font-size: 12px;">
                                </select>
                                <div style="color: #808080; font-size: 11px; margin-top: 6px;">Hold Ctrl/Cmd to select multiple types.</div>
                            </div>
                            <div style="display: flex; justify-content: flex-end; gap: 8px; margin-top: 12px;">
                                <button class="refresh-btn" onclick="runImpactAnalysis()" style="padding: 6px 12px; font-size: 12px;">Create Impact Model</button>
                            </div>
                            <div style="margin-top: 18px;">
                                <div style="color: #e0e0e0; font-size: 13px; font-weight: 600; margin-bottom: 10px;">Impact Models</div>
                                <div id="impactModelsList" class="records-list">
                                    <div class="empty-state">Loading impact models...</div>
                                </div>
                            </div>
                        </div>
                        <div id="repositoryTab-properties" class="repository-tab-panel">
                            <div id="repositoryPropertiesContent" style="flex: 1; overflow-y: auto;">
                                <div class="empty-state">Loading properties...</div>
                            </div>
                        </div>
                        <div id="repositoryTab-models" class="repository-tab-panel">
                            <div id="repositoryModelsContent" style="flex: 1; overflow-y: auto;">
                                <div class="empty-state">Loading models...</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Keyboard Shortcuts Modal -->
            <div id="keyboardShortcutsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; align-items: center; justify-content: center;">
                <div style="background: #2d2d44; padding: 30px; border-radius: 8px; min-width: 500px; max-width: 600px; max-height: 80vh; overflow-y: auto; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="color: #ffffff; margin: 0;">Keyboard Shortcuts</h3>
                        <button class="refresh-btn" onclick="toggleKeyboardShortcuts()" style="padding: 6px 12px; font-size: 13px;"></button>
                    </div>
                    <div id="shortcutsList" style="color: #b0b0d0; font-size: 13px; line-height: 2;">
                        <div style="margin-bottom: 15px;">
                            <div style="color: #ffffff; font-weight: 600; margin-bottom: 8px;">Canvas Navigation</div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;"><span>Zoom In</span><span style="color: #667eea;">Ctrl + Plus / Cmd + Plus</span></div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;"><span>Zoom Out</span><span style="color: #667eea;">Ctrl + Minus / Cmd + Minus</span></div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;"><span>Reset Zoom</span><span style="color: #667eea;">Ctrl + 0 / Cmd + 0</span></div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;"><span>Pan Canvas</span><span style="color: #667eea;">Click + Drag</span></div>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <div style="color: #ffffff; font-weight: 600; margin-bottom: 8px;">Editing</div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;"><span>Undo</span><span style="color: #667eea;">Ctrl + Z / Cmd + Z</span></div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;"><span>Redo</span><span style="color: #667eea;">Ctrl + Shift + Z / Cmd + Shift + Z</span></div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;"><span>Delete Selected</span><span style="color: #667eea;">Delete / Backspace</span></div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;"><span>Multi-Select</span><span style="color: #667eea;">Ctrl + Click / Cmd + Click</span></div>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <div style="color: #ffffff; font-weight: 600; margin-bottom: 8px;">View</div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;"><span>Toggle Fullscreen</span><span style="color: #667eea;">F11</span></div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;"><span>Toggle Gridlines</span><span style="color: #667eea;">G</span></div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;"><span>Toggle Theme</span><span style="color: #667eea;">T</span></div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;"><span>Show Shortcuts</span><span style="color: #667eea;">?</span></div>
                        </div>
                        <div>
                            <div style="color: #ffffff; font-weight: 600; margin-bottom: 8px;">Actions</div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;"><span>Save Model</span><span style="color: #667eea;">Ctrl + S / Cmd + S</span></div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;"><span>Load Model</span><span style="color: #667eea;">Ctrl + O / Cmd + O</span></div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;"><span>Clear Canvas</span><span style="color: #667eea;">Ctrl + Shift + C</span></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Context Menu -->
            <div id="elementContextMenu">
                <button class="context-menu-item" id="infoContextMenuItem" onclick="showElementInfo()" onmouseover="showInfoTooltip(event)" onmouseout="hideInfoTooltip()">Description</button>
                <div id="infoTooltip" style="display: none; position: fixed; background: #2d2d30; color: #e0e0e0; padding: 8px 12px; border-radius: 4px; font-size: 12px; max-width: 300px; z-index: 10002; box-shadow: 0 4px 12px rgba(0,0,0,0.5); border: 1px solid #3e3e42; pointer-events: none;"></div>
                <div style="height: 1px; background: rgba(255,255,255,0.1); margin: 2px 0;"></div>
                <div class="context-menu-item" id="addRelatedElementMenuItem" style="position: relative;" onmouseover="showRelatedElementsSubmenu()" onmouseout="hideRelatedElementsSubmenu()">
                    <span>Add Related</span>
                    <span style="float: right; margin-left: 8px; color: #888;"></span>
                </div>
                <div id="relatedElementsSubmenu">
                    <!-- Related element types will be populated here -->
                </div>
                <div style="height: 1px; background: rgba(255,255,255,0.1); margin: 2px 0;"></div>
                <button class="context-menu-item" id="createRelationshipMenuItem" data-action="selectElementFromContextMenu" style="display: none;">Create Relationship</button>
                <div style="height: 1px; background: rgba(255,255,255,0.1); margin: 2px 0;"></div>
                <button class="context-menu-item" data-action="deleteElementInstance">Delete</button>
            </div>
            
            <!-- Relationship Context Menu -->
            <div id="relationshipContextMenu">
                <button class="context-menu-item" data-action="deleteRelationship">Delete</button>
            </div>
            
            <!-- Element Info Modal -->
            <div id="elementInfoModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10002; align-items: center; justify-content: center;">
                <div style="background: #2d2d30; padding: 30px; border-radius: 8px; min-width: 500px; max-width: 700px; max-height: 80vh; overflow-y: auto; border: 1px solid #3e3e42; box-shadow: 0 4px 12px rgba(0,0,0,0.3); position: relative; display: flex; flex-direction: column;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="color: #ffffff; margin: 0; font-size: 18px;">Element Instance Information</h3>
                        <button onclick="closeElementInfoModal()" style="background: transparent; border: none; color: #c0c0c0; cursor: pointer; font-size: 18px; padding: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; transition: background-color 0.15s; outline: none;" onmouseover="this.style.background='#3e3e3e'" onmouseout="this.style.background='transparent'"></button>
                    </div>
                    <div id="elementInfoContent" style="color: #e0e0e0; flex: 1;">
                        <!-- Element info will be displayed here -->
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                        <button class="refresh-btn" id="saveElementInfoBtn" onclick="saveElementInstanceInfo()" style="padding: 8px 16px; background: #667eea; display: none;">Save</button>
                    </div>
                </div>
            </div>
            
            <!-- Add Property Modal -->
            <div id="addPropertyModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10002; align-items: center; justify-content: center; flex-direction: column;">
                <div style="background: #2d2d44; padding: 30px; border-radius: 8px; min-width: 500px; border: 1px solid rgba(255,255,255,0.1);">
                    <h3 style="color: #ffffff; margin-bottom: 20px;">Add Property</h3>
                    <div style="margin-bottom: 15px;">
                        <label style="color: #ffffff; display: block; margin-bottom: 5px;">Property Name *</label>
                        <input type="text" id="propertyNameInput" placeholder="Enter property name..." 
                               style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #404060; background: #1e1e3f; color: #ffffff; font-size: 14px;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="color: #ffffff; display: block; margin-bottom: 5px;">Description</label>
                        <textarea id="propertyDescriptionInput" placeholder="Enter property description..." 
                                  style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #404060; background: #1e1e3f; color: #ffffff; font-size: 14px; min-height: 80px; resize: vertical;"></textarea>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="color: #ffffff; display: block; margin-bottom: 5px;">RAG Type</label>
                        <select id="propertyRAGTypeInput" 
                                style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #404060; background: #1e1e3f; color: #ffffff; font-size: 14px;">
                            <option value="">None</option>
                            <option value="Red">Red</option>
                            <option value="Amber">Amber</option>
                            <option value="Green">Green</option>
                            <option value="Black">Black</option>
                        </select>
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button class="refresh-btn" onclick="closeAddPropertyModal()" style="padding: 8px 16px;">Cancel</button>
                        <button class="refresh-btn" onclick="confirmAddProperty()" style="padding: 8px 16px; background: #667eea;">Add Property</button>
                    </div>
                </div>
            </div>
            
            <!-- Add Related Element Modal -->
            <div id="addRelatedElementModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10002; align-items: center; justify-content: center; flex-direction: column;">
                <div style="background: #2d2d44; padding: 30px; border-radius: 8px; min-width: 500px; max-width: 600px; max-height: 80vh; overflow-y: auto; border: 1px solid rgba(255,255,255,0.1);">
                    <h3 style="color: #ffffff; margin-bottom: 20px;">Add Related Element</h3>
                    <div style="margin-bottom: 15px; color: #e0e0e0;">
                        <div><strong>From:</strong> <span id="relatedElementSourceName"></span></div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="color: #ffffff; display: block; margin-bottom: 10px;">Select Element Type *</label>
                        <div id="relatedElementTypesList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; max-height: 400px; overflow-y: auto;">
                            <!-- Valid element types will be listed here -->
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button class="refresh-btn" onclick="closeAddRelatedElementModal()" style="padding: 8px 16px;">Cancel</button>
                    </div>
                </div>
            </div>
            
        </div>


        <!-- Ask ED Chatbot Section -->
        <div id="chatbot" class="section">
            
            <div class="form-container">
                <h2 class="section-title"><img src="/images/ask-ed_OLD.svg" alt="EDGly" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';" style="width: 64px; height: 64px; vertical-align: middle; margin-right: 8px; object-fit: contain;"><span>EDGly</span>
                </h2>
                <p style="color: #b0b0d0; margin-bottom: 20px;">
                    Ask me questions about your repository elements, relationships, and EDGY Enterprise Design principles.
                </p>
                
                <div style="margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
                    <label for="chatbotEnterpriseSelect" style="color: #ffffff; font-weight: 600;">Enterprise Filter:</label>
                    <select id="chatbotEnterpriseSelect" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #404060; background: #1e1e3f; color: #ffffff; min-width: 150px;">
                        <option value="">All Enterprises</option>
                    </select>
                </div>
                
                <div class="chat-suggestions">
                    <div class="suggestion-chip" onclick="askQuestion('Summarize repository warnings and rule violations')">Repository warnings</div>
                    <div class="suggestion-chip" onclick="askQuestion('Which elements have missing descriptions or properties?')">Missing descriptions/properties</div>
                    <div class="suggestion-chip" onclick="askQuestion('Show orphaned elements or relationship gaps')">Orphaned or gaps</div>
                    <div class="suggestion-chip" onclick="askQuestion('What are the top 5 elements with the most relationships?')">Relationship hotspots</div>
                    <div class="suggestion-chip" onclick="askQuestion('Show element instances by facet with counts')">Facet breakdown</div>
                    <div class="suggestion-chip" onclick="askQuestion('What properties are assigned to my element instances?')">Property coverage</div>
                    <div class="suggestion-chip" onclick="askQuestion('Give me data quality issues and suggested fixes')">Data quality fixes</div>
                    <div class="suggestion-chip" onclick="askQuestion('Explain EDGY principles in the context of this repository')">EDGY guidance</div>
                </div>
                
                <div class="chatbot-container">
                    <div class="chatbot-messages" id="chatMessages">
                        <div class="chat-message assistant">
                            <div class="chat-avatar"><img src="/images/ask-ed_OLD.svg" alt="EDGly" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;"></div><div class="chat-content"><p>Hello! I'm EDGly. I can help you understand your repository elements, relationships, and EDGY Enterprise Design concepts. Try asking me about your data or EDGY principles!</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="chat-input-container">
                        <input type="text" class="chat-input" id="chatInput" placeholder="Ask me anything about your repository or EDGY..." onkeypress="handleChatKeyPress(event)">
                        <button class="chat-send-btn" onclick="sendChatMessage()"><span>Send</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Element Properties Modal -->
    <div id="propertiesModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="plantuml-header">
                <h2 style="margin: 0;"><span id="propertiesModalTitle">Element Properties</span></h2>
                <span class="close" onclick="closePropertiesModal()">&times;</span>
            </div>
            <div id="propertiesContent">
                <!-- Assign Existing Properties Section -->
                <div style="margin-bottom: 30px; background: #2d2d44; border-radius: 8px; padding: 20px; border: 1px solid rgba(255,255,255,0.1);">
                    <h3 style="color: #ffffff; margin-bottom: 15px;">Assign Existing Properties</h3>
                    <p style="color: #b0b0d0; font-size: 12px; margin-bottom: 15px;">Select from existing properties used by other elements to assign them to this element.</p>
                    <div style="background: #1a1a2e; border: 1px solid #404060; border-radius: 8px; padding: 15px; max-height: 250px; overflow-y: auto;">
                        <div id="availablePropertiesList" style="display: grid; gap: 10px;">
                            <div class="empty-state" style="padding: 10px; text-align: center; color: #888;">Loading available properties...</div>
                        </div>
                    </div>
                    <button type="button" onclick="assignSelectedProperties()" style="background: #808080; color: #ffffff; border: none; padding: 10px 20px; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: pointer; width: 100%; margin-top: 15px;">
                        <span>Assign Selected Properties</span>
                    </button>
                </div>
                
                <!-- Property Templates Section -->
                <div style="margin-bottom: 30px; background: #2d2d44; border-radius: 8px; padding: 20px; border: 1px solid rgba(255,255,255,0.1);">
                    <h3 style="color: #ffffff; margin-bottom: 15px;">Property Templates</h3>
                    <p style="color: #b0b0d0; font-size: 13px; margin-bottom: 15px;">Quickly add pre-defined property sets to this element</p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                        <button class="refresh-btn" onclick="applyPropertyTemplate('risk-assessment')" style="padding: 10px; font-size: 12px;">
                            <span> Risk Assessment</span>
                        </button>
                        <button class="refresh-btn" onclick="applyPropertyTemplate('compliance')" style="padding: 10px; font-size: 12px;">
                            <span> Compliance</span>
                        </button>
                        <button class="refresh-btn" onclick="applyPropertyTemplate('performance')" style="padding: 10px; font-size: 12px;">
                            <span> Performance</span>
                        </button>
                        <button class="refresh-btn" onclick="applyPropertyTemplate('maturity')" style="padding: 10px; font-size: 12px;">
                            <span> Maturity</span>
                        </button>
                    </div>
                </div>
                
                <!-- Create New Property Section -->
                <div style="margin-bottom: 30px; background: #2d2d44; border-radius: 8px; padding: 20px; border: 1px solid rgba(255,255,255,0.1);">
                    <h3 style="color: #ffffff; margin-bottom: 15px;">Create New Property</h3>
                    <form id="addPropertyForm" onsubmit="addProperty(event)">
                        <input type="hidden" id="propertyElementId">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                            <div>
                                <label style="display: block; color: #b0b0d0; margin-bottom: 5px; font-size: 13px;">Property Type</label>
                                <select id="propertyType" onchange="updatePropertyTypeFields()" style="width: 100%; padding: 8px; border: 1px solid #404060; border-radius: 4px; background: #1a1a2e; color: #e0e0e0; font-size: 13px;">
                                    <option value="text">Text</option>
                                    <option value="numeric">Numeric</option>
                                    <option value="date">Date</option>
                                    <option value="link">Link (URL)</option>
                                </select>
                            </div>
                            <div>
                                <label style="display: block; color: #b0b0d0; margin-bottom: 5px; font-size: 13px;">RAG Type</label>
                                <select id="propertyRagType" onchange="updatePropertyTagPreview()" style="width: 100%; padding: 8px; border: 1px solid #404060; border-radius: 4px; background: #1a1a2e; color: #e0e0e0; font-size: 13px;">
                                    <option value="">Select RAG Type</option>
                                    <option value="Negative">Negative</option>
                                    <option value="Warning">Warning</option>
                                    <option value="Positive">Positive</option>
                                    <option value="Black">Black</option>
                                </select>
                                <div id="ragTagPreview" style="margin-top: 8px; display: none;">
                                    <img id="ragTagPreviewImg" src="" alt="RAG Tag" style="width: 64px; height: 64px; border-radius: 4px; object-fit: contain;">
                                </div>
                            </div>
                            <div>
                                <label style="display: block; color: #b0b0d0; margin-bottom: 5px; font-size: 13px;">Property Name *</label>
                                <input type="text" id="propertyName" required style="width: 100%; padding: 8px; border: 1px solid #404060; border-radius: 4px; background: #1a1a2e; color: #e0e0e0; font-size: 13px;">
                            </div>
                            <div>
                                <label style="display: block; color: #b0b0d0; margin-bottom: 5px; font-size: 13px;">Image URL (Optional - auto-set from RAG type)</label>
                                <input type="text" id="propertyImageUrl" readonly style="width: 100%; padding: 8px; border: 1px solid #404060; border-radius: 4px; background: #2d2d44; color: #b0b0d0; font-size: 13px; cursor: not-allowed;" placeholder="Auto-set based on RAG type">
                            </div>
                        </div>
                        <div id="propertyTypeSpecificFields" style="margin-bottom: 15px;">
                            <!-- Type-specific fields will be shown here -->
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; color: #b0b0d0; margin-bottom: 5px; font-size: 13px;">Description</label>
                            <textarea id="propertyDescription" rows="3" style="width: 100%; padding: 8px; border: 1px solid #404060; border-radius: 4px; background: #1a1a2e; color: #e0e0e0; font-size: 13px; resize: vertical;"></textarea>
                        </div>
                        <button type="submit" style="background: #808080; color: #ffffff; border: none; padding: 10px 20px; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: pointer; width: 100%;">
                            <span>Create New Property</span>
                        </button>
                    </form>
                </div>
                
                <!-- Audit Log & Version History -->
                <div style="margin-bottom: 30px; background: #2d2d44; border-radius: 8px; padding: 20px; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="color: #ffffff; margin: 0;">Change History</h3>
                        <div style="display: flex; gap: 10px;">
                            <button class="refresh-btn" onclick="loadAuditLog()" style="padding: 6px 12px; font-size: 12px;">
                                <span> Audit Log</span>
                            </button>
                            <button class="refresh-btn" onclick="loadVersionHistory()" style="padding: 6px 12px; font-size: 12px;">
                                <span> Versions</span>
                            </button>
                        </div>
                    </div>
                    <div id="auditLogContent" style="max-height: 300px; overflow-y: auto;">
                        <div style="color: #b0b0d0; text-align: center; padding: 20px;">Click "Audit Log" or "Versions" to view change history</div>
                    </div>
                </div>
                
                <!-- Current Element Properties -->
                <div>
                    <h3 style="color: #ffffff; margin-bottom: 15px;">Current Element Properties</h3>
                    <div id="propertiesList" class="empty-state">Loading properties...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Element Details Modal -->
    <div id="elementDetailsModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="plantuml-header">
                <h2 style="margin: 0;"><span id="elementDetailsModalTitle">Element Details</span></h2>
                <span class="close" onclick="closeElementDetailsModal()">&times;</span>
            </div>
            <div id="elementDetailsContent" style="padding: 20px;">
                <div class="empty-state">Loading element details...</div>
            </div>
        </div>
    </div>

    <!-- Relationship Details Modal -->
    <div id="relationshipDetailsModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="plantuml-header">
                <h2 style="margin: 0;"><img src="/images/create-relationships.png" alt="Relationship Details" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';" style="width: 64px; height: 64px; vertical-align: middle; margin-right: 8px; object-fit: contain;"><span id="relationshipDetailsModalTitle">Relationship Details</span></h2>
                <span class="close" onclick="closeRelationshipDetailsModal()">&times;</span>
            </div>
            <div id="relationshipDetailsContent" style="padding: 20px;">
                <div class="empty-state">Loading relationship details...</div>
            </div>
        </div>
    </div>

    <script>
        const AUTH_TOKEN_KEY = 'edgy_auth_token';
        const authOverlay = document.getElementById('authOverlay');
        const authForm = document.getElementById('authForm');
        const authTitle = document.getElementById('authTitle');
        const authError = document.getElementById('authError');
        const authSubmit = document.getElementById('authSubmit');
        const authToggleBtn = document.getElementById('authToggleBtn');
        const authToggleText = document.getElementById('authToggleText');
        const authFullName = document.getElementById('authFullName');

        let authMode = 'login';

        function setAuthMode(mode) {
            authMode = mode;
            const isRegister = mode === 'register';
            authOverlay.classList.toggle('auth-register-mode', isRegister);
            authTitle.textContent = isRegister ? 'Create account' : 'Sign in';
            authSubmit.textContent = isRegister ? 'Create account' : 'Sign in';
            authToggleText.textContent = isRegister ? 'Already have an account?' : 'No account yet?';
            authToggleBtn.textContent = isRegister ? 'Sign in' : 'Register';
            authError.style.display = 'none';
        }

        function showAuthOverlay() {
            authOverlay.classList.remove('auth-hidden');
        }

        function hideAuthOverlay() {
            authOverlay.classList.add('auth-hidden');
        }

        function setAuthError(message) {
            authError.textContent = message;
            authError.style.display = 'block';
        }

        authToggleBtn.addEventListener('click', () => {
            setAuthMode(authMode === 'login' ? 'register' : 'login');
        });

        authForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const email = authForm.querySelector('#authEmail').value.trim();
            const password = authForm.querySelector('#authPassword').value;
            const fullName = authFullName.value.trim();
            if (!email || !password) {
                setAuthError('Email and password are required.');
                return;
            }

            const endpoint = authMode === 'register' ? '/api/auth/register' : '/api/auth/login';
            const payload = { email, password };
            if (authMode === 'register' && fullName) {
                payload.full_name = fullName;
            }

            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (!response.ok) {
                    setAuthError(data.error || 'Authentication failed.');
                    return;
                }
                localStorage.setItem(AUTH_TOKEN_KEY, data.token);
                hideAuthOverlay();
            } catch (error) {
                setAuthError('Authentication failed. Please try again.');
            }
        });

        const originalFetch = window.fetch.bind(window);
        window.fetch = async (input, init = {}) => {
            const token = localStorage.getItem(AUTH_TOKEN_KEY);
            const url = typeof input === 'string' ? input : input.url;
            const isApiRequest = url.includes('/api/');
            const headers = new Headers(init.headers || (input instanceof Request ? input.headers : undefined));
            if (token && isApiRequest) {
                headers.set('Authorization', `Bearer ${token}`);
            }
            const response = await originalFetch(input, { ...init, headers });
            if (response.status === 401) {
                showAuthOverlay();
            }
            return response;
        };

        async function verifySession() {
            const token = localStorage.getItem(AUTH_TOKEN_KEY);
            if (!token) {
                showAuthOverlay();
                return;
            }
            try {
                const response = await originalFetch('/api/auth/me', {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) {
                    showAuthOverlay();
                    return;
                }
                hideAuthOverlay();
            } catch (error) {
                showAuthOverlay();
            }
        }

        verifySession();

        let allRecords = [];

        // EDGY Color mapping for Facets and Elements
        // Based on Intersections groups EDGY color scheme
        const facetColors = {
            'Business Operations': { primary: '#666666', secondary: '#555555', accent: '#777777' },
            'Supply Chain': { primary: '#50C878', secondary: '#2E7D4E', accent: '#6FD88F' },
            'Financial Services': { primary: '#FF6B6B', secondary: '#CC5555', accent: '#FF8E8E' },
            'Security': { primary: '#FFA500', secondary: '#CC8400', accent: '#FFB84D' },
            'Analytics': { primary: '#888888', secondary: '#777777', accent: '#999999' },
            'Technology': { primary: '#3498DB', secondary: '#2A7BA8', accent: '#5DADE2' },
            'Operations': { primary: '#1ABC9C', secondary: '#158F75', accent: '#48D1CC' },
            'default': { primary: '#7B68EE', secondary: '#5D4FD6', accent: '#9370DB' }
        };

        const elementColors = {
            'CRM Module': { primary: '#E74C3C', secondary: '#C0392B', accent: '#EC7063' },
            'Warehouse Management': { primary: '#16A085', secondary: '#138D75', accent: '#48C9B0' },
            'Transaction Engine': { primary: '#F39C12', secondary: '#D68910', accent: '#F7DC6F' },
            'Auth Service': { primary: '#8E44AD', secondary: '#7D3C98', accent: '#BB8FCE' },
            'Reporting Tool': { primary: '#2980B9', secondary: '#21618C', accent: '#5DADE2' },
            'default': { primary: '#95A5A6', secondary: '#7F8C8D', accent: '#BDC3C7' }
        };

        // Get color for a facet
        function getFacetColor(facet) {
            if (!facet) return facetColors.default;
            const normalizedFacet = Object.keys(facetColors).find(key => 
                key.toLowerCase() === facet.toLowerCase()
            );
            return facetColors[normalizedFacet] || facetColors.default;
        }

        // Get facet icon image path
        function getFacetIcon(facet) {
            if (!facet) return null;
            const facetLower = facet.toLowerCase();
            if (facetLower.includes('base')) {
                return null; // No base icon available
            } else if (facetLower.includes('architecture')) {
                return '/images/icon-architecture.svg';
            } else if (facetLower.includes('identity')) {
                return '/images/Icon-Identity.svg';
            } else if (facetLower.includes('experience')) {
                return '/images/Icon-Experience.svg';
            } else if (facetLower.includes('product')) {
                return '/images/icon-product.svg';
            } else if (facetLower.includes('organisation') || facetLower.includes('organization')) {
                return '/images/icon-organisation.svg';
            } else if (facetLower.includes('brand')) {
                return '/images/Icon-Brand.svg';
            }
            return null;
        }

        // Get color for an element
        function getElementColor(element) {
            if (!element) return elementColors.default;
            const normalizedElement = Object.keys(elementColors).find(key => 
                key.toLowerCase() === element.toLowerCase()
            );
            return elementColors[normalizedElement] || elementColors.default;
        }

        // Get combined color (neutral gray)
        function getRecordColor(record) {
            return {
                primary: '#e6e6e6',
                secondary: '#e6e6e6',
                accent: '#e6e6e6'
            };
        }

        // Blend two hex colors
        function blendColors(color1, color2) {
            const c1 = hexToRgb(color1);
            const c2 = hexToRgb(color2);
            const r = Math.round((c1.r + c2.r) / 2);
            const g = Math.round((c1.g + c2.g) / 2);
            const b = Math.round((c1.b + c2.b) / 2);
            return rgbToHex(r, g, b);
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        // Load records on page load
        // Menu dropdown functions
        function showMenuDropdown(event, menuId) {
            // Hide all other menus
            document.querySelectorAll('.menu-dropdown').forEach(menu => {
                if (menu.id !== menuId) {
                    menu.style.display = 'none';
                }
            });
            
            const menu = document.getElementById(menuId);
            if (menu) {
                const rect = event.target.getBoundingClientRect();
                menu.style.left = rect.left + 'px';
                menu.style.top = (rect.bottom + 2) + 'px';
                menu.style.display = 'block';
            }
        }
        
        function hideMenuDropdown(menuId) {
            setTimeout(() => {
                const menu = document.getElementById(menuId);
                if (menu && !menu.matches(':hover')) {
                    menu.style.display = 'none';
                }
            }, 150);
        }
        
        // Close menus when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.menu-item') && !e.target.closest('.menu-dropdown')) {
                document.querySelectorAll('.menu-dropdown').forEach(menu => {
                    menu.style.display = 'none';
                });
            }
        });
        
        // Templates submenu functions
        function showTemplatesSubmenu() {
            const submenu = document.getElementById('templatesSubmenu');
            if (submenu) {
                submenu.style.display = 'block';
            }
        }
        
        function hideTemplatesSubmenu() {
            const submenu = document.getElementById('templatesSubmenu');
            if (submenu) {
                setTimeout(() => {
                    if (!submenu.matches(':hover') && !submenu.parentElement.matches(':hover')) {
                        submenu.style.display = 'none';
                    }
                }, 150);
            }
        }
        
        // Apply canvas template background
        function applyCanvasTemplate(templateName, isNewTemplate = false) {
            const previousTemplate = canvasState.canvasTemplate;
            canvasState.canvasTemplate = templateName;
            localStorage.setItem('canvasTemplate', templateName);
            
            const container = document.getElementById('canvasContainer');
            const templateLayer = document.getElementById('templateLayer');
            if (!container) return;
            
            // Hide all menus
            document.querySelectorAll('.menu-dropdown').forEach(menu => {
                menu.style.display = 'none';
            });
            
            if (templateName === 'none') {
                // Remove template, restore default background
                if (templateLayer) {
                    templateLayer.style.display = 'none';
                    templateLayer.innerHTML = '';
                }
                container.style.backgroundImage = '';
                container.style.backgroundSize = '';
                container.style.backgroundPosition = '';
                container.style.backgroundRepeat = '';
                applyCanvasTheme(); // Reapply theme with grid
            } else if (templateName === 'milkyway-map') {
                // Reset template zoom/pan for Milkyway Map (locked at 125%, no transforms)
                canvasState.templateZoom = 1.0;
                canvasState.templatePanX = 0;
                canvasState.templatePanY = 0;
                canvasState.templateSelected = false;
                localStorage.removeItem('templateZoom');
                localStorage.removeItem('templatePanX');
                localStorage.removeItem('templatePanY');
                
                // Create scalable SVG-based Milkyway Map template at 125%
                createMilkywayMapTemplate();
                // No template selection setup - template is locked as background
                // Update chatbot button SVG based on theme
                updateChatbotButtonSVG();
                
                // If this is a new template being added (different from previous), open configure modal
                if (isNewTemplate || previousTemplate !== templateName) {
                    setTimeout(() => {
                        configureTemplateSegments();
                    }, 300); // Small delay to ensure template is rendered
                }
            } else if (templateName === 'service-blueprint') {
                // Create scalable SVG-based Service Blueprint template
                createServiceBlueprintTemplate();
                // Setup template selection after template is created
                setTimeout(() => {
                    setupTemplateSelection();
                }, 100);
                // Update chatbot button SVG based on theme
                updateChatbotButtonSVG();
            } else {
                // Fallback for other template types (if any)
                if (templateLayer) {
                    templateLayer.style.display = 'none';
                    templateLayer.innerHTML = '';
                }
                applyCanvasTheme();
            }
        }
        
        // Create scalable Milkyway Map template with concentric circles and icons
        function createMilkywayMapTemplate() {
            const templateLayer = document.getElementById('templateLayer');
            const container = document.getElementById('canvasContainer');
            if (!templateLayer || !container) return;
            
            // Clear existing template
            templateLayer.innerHTML = '';
            templateLayer.style.display = 'block';
            
            // Reset template selection when recreating
            canvasState.templateSelected = false;
            updateTemplateSelectionVisual();
            
            // Get container dimensions for centering (use getBoundingClientRect for accurate rendered size)
            const containerRect = container.getBoundingClientRect();
            const containerWidth = containerRect.width || container.clientWidth || 2000;
            const containerHeight = containerRect.height || container.clientHeight || 2000;
            const centerX = containerWidth / 2;
            const centerY = containerHeight / 2;
            
            // Set SVG viewBox for proper scaling (let CSS handle width/height via percentage)
            templateLayer.setAttribute('viewBox', `0 0 ${containerWidth} ${containerHeight}`);
            // Remove explicit width/height attributes to let CSS percentage sizing work
            templateLayer.removeAttribute('width');
            templateLayer.removeAttribute('height');
            
            // Define circle sizes at 125% (locked size, no resizing)
            const baseSize = Math.min(containerWidth, containerHeight) * 0.4 * 1.25; // 40% of smaller dimension * 125%
            const circle1Radius = baseSize; // Outermost (pink)
            const circle2Radius = baseSize * 0.75; // Second (light blue)
            const circle3Radius = baseSize * 0.5; // Third (light green)
            const circle4Radius = baseSize * 0.25; // Center (white)
            
            // Create SVG group for the template
            const svgNS = 'http://www.w3.org/2000/svg';
            const group = document.createElementNS(svgNS, 'g');
            group.setAttribute('id', 'milkywayTemplateGroup');
            // Make group non-interactive so clicks pass through to templateLayer
            group.setAttribute('pointer-events', 'none');
            
            // Define colors based on theme
            const isDark = canvasState.theme === 'dark';
            const colors = {
                circle1: isDark ? '#ff6b9d' : '#ff8fb3', // Pink
                circle2: '#9bc4e2', // Light blue (same in both modes)
                circle3: '#9de2b4', // Light green (same in both modes)
                circle4: '#f0f0f0', // White (same in both modes)
                circle4Inner: '#c0c0c0', // Gray center (same in both modes)
                line: isDark ? 'rgba(255,255,255,0.3)' : 'rgba(0,0,0,0.2)' // Guide lines
            };
            
            // Draw concentric circles as filled rings
            // Draw from largest to smallest, with each inner circle creating the ring effect
            // Use light mode background color for cut-out circles so center appears same in both modes
            const bgColor = '#f5f5f5'; // Same in both modes (light mode color)
            
            // Add white background circle underneath all rings to prevent grid lines from showing through
            // This ensures consistent appearance in both light and dark modes
            const whiteBackground = document.createElementNS(svgNS, 'circle');
            whiteBackground.setAttribute('cx', centerX);
            whiteBackground.setAttribute('cy', centerY);
            whiteBackground.setAttribute('r', circle1Radius);
            whiteBackground.setAttribute('fill', '#ffffff');
            whiteBackground.setAttribute('opacity', '1');
            group.appendChild(whiteBackground);
            
            // Outermost ring (pink) - draw large pink circle
            const ring1 = document.createElementNS(svgNS, 'circle');
            ring1.setAttribute('cx', centerX);
            ring1.setAttribute('cy', centerY);
            ring1.setAttribute('r', circle1Radius);
            ring1.setAttribute('fill', colors.circle1);
            ring1.setAttribute('opacity', '0.5'); // Keep same opacity as light mode
            ring1.setAttribute('stroke', '#ffffff');
            ring1.setAttribute('stroke-width', '4.5');
            ring1.setAttribute('stroke-opacity', '1');
            group.appendChild(ring1);
            
            // Cut out inner part of ring1 with background color
            const ring1Inner = document.createElementNS(svgNS, 'circle');
            ring1Inner.setAttribute('cx', centerX);
            ring1Inner.setAttribute('cy', centerY);
            ring1Inner.setAttribute('r', circle2Radius);
            ring1Inner.setAttribute('fill', bgColor);
            ring1Inner.setAttribute('opacity', '1');
            group.appendChild(ring1Inner);
            
            // Second ring (light blue) - draw blue circle
            const ring2 = document.createElementNS(svgNS, 'circle');
            ring2.setAttribute('cx', centerX);
            ring2.setAttribute('cy', centerY);
            ring2.setAttribute('r', circle2Radius);
            ring2.setAttribute('fill', colors.circle2);
            ring2.setAttribute('opacity', '0.5'); // Keep same opacity as light mode
            ring2.setAttribute('stroke', '#ffffff');
            ring2.setAttribute('stroke-width', '4.5');
            ring2.setAttribute('stroke-opacity', '1');
            group.appendChild(ring2);
            
            // Cut out inner part of ring2 with background color
            const ring2Inner = document.createElementNS(svgNS, 'circle');
            ring2Inner.setAttribute('cx', centerX);
            ring2Inner.setAttribute('cy', centerY);
            ring2Inner.setAttribute('r', circle3Radius);
            ring2Inner.setAttribute('fill', bgColor);
            ring2Inner.setAttribute('opacity', '1');
            group.appendChild(ring2Inner);
            
            // Third ring (light green) - draw green circle
            const ring3 = document.createElementNS(svgNS, 'circle');
            ring3.setAttribute('cx', centerX);
            ring3.setAttribute('cy', centerY);
            ring3.setAttribute('r', circle3Radius);
            ring3.setAttribute('fill', colors.circle3);
            ring3.setAttribute('opacity', '0.5'); // Keep same opacity as light mode
            ring3.setAttribute('stroke', '#ffffff');
            ring3.setAttribute('stroke-width', '4.5');
            ring3.setAttribute('stroke-opacity', '1');
            group.appendChild(ring3);
            
            // Cut out inner part of ring3 with background color
            const ring3Inner = document.createElementNS(svgNS, 'circle');
            ring3Inner.setAttribute('cx', centerX);
            ring3Inner.setAttribute('cy', centerY);
            ring3Inner.setAttribute('r', circle4Radius);
            ring3Inner.setAttribute('fill', bgColor);
            ring3Inner.setAttribute('opacity', '1');
            group.appendChild(ring3Inner);
            
            // Center circle (white)
            const circle4 = document.createElementNS(svgNS, 'circle');
            circle4.setAttribute('cx', centerX);
            circle4.setAttribute('cy', centerY);
            circle4.setAttribute('r', circle4Radius);
            circle4.setAttribute('fill', colors.circle4);
            circle4.setAttribute('stroke', '#ffffff');
            circle4.setAttribute('stroke-width', '4.5');
            circle4.setAttribute('stroke-opacity', '1');
            circle4.setAttribute('opacity', '0.8'); // Keep same opacity as light mode
            group.appendChild(circle4);
            
            // Draw configurable segments (dividing lines) - BEFORE guide lines so they're visible
            // Use configured segments if available, otherwise default to 4
            // Ensure we only use the actual number of segments in templateSegments
            let segmentCount = 4;
            if (canvasState.templateSegments && canvasState.templateSegments.length > 0) {
                segmentCount = canvasState.templateSegments.length;
            } else if (canvasState.templateSegmentCount) {
                segmentCount = canvasState.templateSegmentCount;
            }
            const segmentAngleStep = (2 * Math.PI) / segmentCount;
            // Keep the top vertical axis fixed as a segment divider.
            const topAxisAngle = -Math.PI / 2;
            const segmentStartAngle = topAxisAngle;
            // Map segment index 0 to the wedge that contains the bottom-left ray.
            const desiredStartAngle = (3 * Math.PI) / 4;
            let offsetAngle = desiredStartAngle - topAxisAngle;
            offsetAngle = (offsetAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
            const segmentIndexOffset = Math.floor(offsetAngle / segmentAngleStep) % segmentCount;
            
            // Draw segment dividing lines - only draw the exact number of segments
            for (let i = 0; i < segmentCount; i++) {
                const angle = segmentStartAngle + (i * segmentAngleStep);
                const x1 = centerX + Math.cos(angle) * circle4Radius;
                const y1 = centerY + Math.sin(angle) * circle4Radius;
                const x2 = centerX + Math.cos(angle) * circle1Radius;
                const y2 = centerY + Math.sin(angle) * circle1Radius;
                
                const segmentLine = document.createElementNS(svgNS, 'line');
                segmentLine.setAttribute('x1', x1);
                segmentLine.setAttribute('y1', y1);
                segmentLine.setAttribute('x2', x2);
                segmentLine.setAttribute('y2', y2);
                segmentLine.setAttribute('stroke', '#ffffff');
                segmentLine.setAttribute('stroke-width', '4.5');
                segmentLine.setAttribute('opacity', '1');
                segmentLine.setAttribute('id', `segment-line-${i}`);
                group.appendChild(segmentLine);
            }
            
            // Draw segment names in center circle
            if (canvasState.templateSegments && canvasState.templateSegments.length > 0) {
                const fontSize = Math.min(circle4Radius * 0.2, 18);
                const textRadius = circle4Radius * 0.5;
                
                canvasState.templateSegments.forEach((segment) => {
                    const segmentIndex = segment.segment_index;
                    const angle = segmentStartAngle + ((segmentIndex + segmentIndexOffset) * segmentAngleStep) + (segmentAngleStep / 2);
                    const textX = centerX + Math.cos(angle) * textRadius;
                    const textY = centerY + Math.sin(angle) * textRadius;
                    
                    const text = document.createElementNS(svgNS, 'text');
                    text.setAttribute('x', textX);
                    text.setAttribute('y', textY);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    // Use black text for visibility on white center circle
                    text.setAttribute('fill', '#000000');
                    text.setAttribute('font-size', fontSize + 'px');
                    text.setAttribute('font-weight', 'bold');
                    text.setAttribute('font-family', 'Arial, sans-serif');
                    text.setAttribute('pointer-events', 'none');
                    text.setAttribute('style', 'user-select: none;');
                    // Use createTextNode for proper SVG text rendering
                    const textNode = document.createTextNode(segment.segment_name);
                    text.appendChild(textNode);
                    text.setAttribute('id', `segment-name-${segment.segment_index}`);
                    group.appendChild(text);
                });
            }
            
            // Draw vertical guide line (static, always shown)
            // Vertical line (partial, from top to inner ring boundary)
            const lineV = document.createElementNS(svgNS, 'line');
            lineV.setAttribute('x1', centerX);
            lineV.setAttribute('y1', centerY - circle1Radius);
            lineV.setAttribute('x2', centerX);
            lineV.setAttribute('y2', centerY - circle4Radius);
            lineV.setAttribute('stroke', '#ffffff');
            lineV.setAttribute('stroke-width', '4.5');
            lineV.setAttribute('opacity', '1');
            group.appendChild(lineV);
            
            // Position icons along the vertical line based on milkyway-map.png reference
            // Icon positions (relative to center, along vertical axis)
            // Note: Experience and Identity positions are swapped, Brand and Product removed
            const iconSize = 48; // Base icon size
            const iconPositions = [
                { name: 'Experience', y: -circle1Radius * 0.85, icon: '/images/Icon-Experience.svg' }, // Pink ring (within outer ring)
                { name: 'Architecture', y: -circle2Radius * 0.9, icon: '/images/icon-architecture.svg' }, // Light blue ring (blue triangle/house position)
                { name: 'Identity', y: -circle3Radius * 0.85, icon: '/images/Icon-Identity.svg' } // Light green ring (swapped with Experience)
            ];
            
            // Add icons at specified positions
            iconPositions.forEach((iconPos, index) => {
                const img = document.createElementNS(svgNS, 'image');
                img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', iconPos.icon);
                img.setAttribute('x', centerX - iconSize / 2);
                img.setAttribute('y', centerY + iconPos.y - iconSize / 2);
                img.setAttribute('width', iconSize);
                img.setAttribute('height', iconSize);
                img.setAttribute('opacity', '1'); // Fully opaque
                img.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                img.setAttribute('id', `template-icon-${iconPos.name.toLowerCase()}`);
                
                group.appendChild(img);
            });
            
            // Draw ring boundaries on top (bring to front)
            // Outermost ring boundary
            const ring1Boundary = document.createElementNS(svgNS, 'circle');
            ring1Boundary.setAttribute('cx', centerX);
            ring1Boundary.setAttribute('cy', centerY);
            ring1Boundary.setAttribute('r', circle1Radius);
            ring1Boundary.setAttribute('fill', 'none');
            ring1Boundary.setAttribute('stroke', '#ffffff');
            ring1Boundary.setAttribute('stroke-width', '4.5');
            ring1Boundary.setAttribute('stroke-opacity', '1');
            group.appendChild(ring1Boundary);
            
            // Second ring boundary
            const ring2Boundary = document.createElementNS(svgNS, 'circle');
            ring2Boundary.setAttribute('cx', centerX);
            ring2Boundary.setAttribute('cy', centerY);
            ring2Boundary.setAttribute('r', circle2Radius);
            ring2Boundary.setAttribute('fill', 'none');
            ring2Boundary.setAttribute('stroke', '#ffffff');
            ring2Boundary.setAttribute('stroke-width', '4.5');
            ring2Boundary.setAttribute('stroke-opacity', '1');
            group.appendChild(ring2Boundary);
            
            // Third ring boundary
            const ring3Boundary = document.createElementNS(svgNS, 'circle');
            ring3Boundary.setAttribute('cx', centerX);
            ring3Boundary.setAttribute('cy', centerY);
            ring3Boundary.setAttribute('r', circle3Radius);
            ring3Boundary.setAttribute('fill', 'none');
            ring3Boundary.setAttribute('stroke', '#ffffff');
            ring3Boundary.setAttribute('stroke-width', '4.5');
            ring3Boundary.setAttribute('stroke-opacity', '1');
            group.appendChild(ring3Boundary);
            
            // Center circle boundary
            const circle4Boundary = document.createElementNS(svgNS, 'circle');
            circle4Boundary.setAttribute('cx', centerX);
            circle4Boundary.setAttribute('cy', centerY);
            circle4Boundary.setAttribute('r', circle4Radius);
            circle4Boundary.setAttribute('fill', 'none');
            circle4Boundary.setAttribute('stroke', '#ffffff');
            circle4Boundary.setAttribute('stroke-width', '4.5');
            circle4Boundary.setAttribute('stroke-opacity', '1');
            group.appendChild(circle4Boundary);
            
            // Append group to template layer
            templateLayer.appendChild(group);
            
            // Update transform to match current zoom/pan
            updateCanvasTransform();
            
            // Keep gridlines if enabled
            if (canvasState.showGridlines) {
                const gridImage = canvasState.theme === 'light' 
                    ? `linear-gradient(rgba(0,0,0,0.1) 1px, transparent 1px),
                       linear-gradient(90deg, rgba(0,0,0,0.1) 1px, transparent 1px)`
                    : `linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                       linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px)`;
                
                container.style.backgroundImage = gridImage;
                container.style.backgroundSize = '20px 20px';
                container.style.backgroundPosition = '0 0';
                container.style.backgroundRepeat = 'repeat';
            } else {
                container.style.backgroundImage = 'none';
                container.style.backgroundSize = '';
                container.style.backgroundPosition = '';
                container.style.backgroundRepeat = '';
            }
            
            // Set background color to match theme
            container.style.backgroundColor = canvasState.theme === 'light' ? '#f5f5f5' : '#1a1a1a';
            
            // Update template selection visual after creation
            updateTemplateSelectionVisual();
        }
        
        // Create scalable Service Blueprint template with horizontal lanes
        function createServiceBlueprintTemplate() {
            const templateLayer = document.getElementById('templateLayer');
            const container = document.getElementById('canvasContainer');
            if (!templateLayer || !container) return;
            
            // Clear existing template
            templateLayer.innerHTML = '';
            templateLayer.style.display = 'block';
            
            // Reset template selection when recreating
            canvasState.templateSelected = false;
            updateTemplateSelectionVisual();
            
            // Get container dimensions
            const containerRect = container.getBoundingClientRect();
            const containerWidth = containerRect.width || container.clientWidth || 2000;
            const containerHeight = containerRect.height || container.clientHeight || 2000;
            
            // Set SVG viewBox for proper scaling
            templateLayer.setAttribute('viewBox', `0 0 ${containerWidth} ${containerHeight}`);
            templateLayer.removeAttribute('width');
            templateLayer.removeAttribute('height');
            
            // Define lane dimensions (3 equal horizontal sections)
            const laneHeight = containerHeight / 3;
            const iconAreaWidth = 80; // Width for icons on the left
            
            // Create SVG group for the template
            const svgNS = 'http://www.w3.org/2000/svg';
            const group = document.createElementNS(svgNS, 'g');
            group.setAttribute('id', 'serviceBlueprintTemplateGroup');
            group.setAttribute('pointer-events', 'none');
            
            // Define colors with 0.5 opacity (same as Milkyway Map)
            const colors = {
                experience: '#FF99BD', // Experience panel color
                product: '#E599FF',    // Product panel color
                architecture: '#A6C0FF'  // Architecture panel color
            };
            
            // Define lanes
            const lanes = [
                { name: 'Experience', y: 0, color: colors.experience, icon: '/images/Icon-Experience.svg' },
                { name: 'Product', y: laneHeight, color: colors.product, icon: '/images/icon-product.svg' },
                { name: 'Architecture', y: laneHeight * 2, color: colors.architecture, icon: '/images/icon-architecture.svg' }
            ];
            
            // Add white background rectangle underneath all segments to ensure colors are maintained in dark mode
            const whiteBackground = document.createElementNS(svgNS, 'rect');
            whiteBackground.setAttribute('x', 0);
            whiteBackground.setAttribute('y', 0);
            whiteBackground.setAttribute('width', containerWidth);
            whiteBackground.setAttribute('height', containerHeight);
            whiteBackground.setAttribute('fill', '#ffffff');
            whiteBackground.setAttribute('opacity', '1');
            group.appendChild(whiteBackground);
            
            // Draw each lane (backgrounds and icons first)
            lanes.forEach((lane, index) => {
                // Background rectangle for lane
                const rect = document.createElementNS(svgNS, 'rect');
                rect.setAttribute('x', 0);
                rect.setAttribute('y', lane.y);
                rect.setAttribute('width', containerWidth);
                rect.setAttribute('height', laneHeight);
                rect.setAttribute('fill', lane.color);
                rect.setAttribute('opacity', '0.5'); // Same opacity as Milkyway Map
                group.appendChild(rect);
                
                // Icon area background (left side)
                const iconAreaBg = document.createElementNS(svgNS, 'rect');
                iconAreaBg.setAttribute('x', 0);
                iconAreaBg.setAttribute('y', lane.y);
                iconAreaBg.setAttribute('width', iconAreaWidth);
                iconAreaBg.setAttribute('height', laneHeight);
                iconAreaBg.setAttribute('fill', lane.color);
                iconAreaBg.setAttribute('opacity', '0.5');
                group.appendChild(iconAreaBg);
                
                // Icon (centered in icon area, same size as Milkyway Map: 48px)
                const iconSize = 48;
                const img = document.createElementNS(svgNS, 'image');
                img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', lane.icon);
                img.setAttribute('x', iconAreaWidth / 2 - iconSize / 2);
                img.setAttribute('y', lane.y + laneHeight / 2 - iconSize / 2);
                img.setAttribute('width', iconSize);
                img.setAttribute('height', iconSize);
                img.setAttribute('opacity', '1');
                img.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                img.setAttribute('id', `service-blueprint-icon-${lane.name.toLowerCase()}`);
                group.appendChild(img);
            });
            
            // Draw all dividing lines last to ensure they appear on top and are fully opaque
            // Horizontal divider lines between lanes
            lanes.forEach((lane, index) => {
                if (index < lanes.length - 1) {
                    const divider = document.createElementNS(svgNS, 'line');
                    divider.setAttribute('x1', 0);
                    divider.setAttribute('y1', lane.y + laneHeight);
                    divider.setAttribute('x2', containerWidth);
                    divider.setAttribute('y2', lane.y + laneHeight);
                    divider.setAttribute('stroke', '#ffffff');
                    divider.setAttribute('stroke-width', '4.5');
                    divider.setAttribute('stroke-opacity', '1');
                    divider.setAttribute('opacity', '1');
                    // Ensure no fill affects the line
                    divider.setAttribute('fill', 'none');
                    group.appendChild(divider);
                }
            });
            
            // Vertical dividing line separating icon area from main sections - drawn last to be on top
            const verticalDivider = document.createElementNS(svgNS, 'line');
            verticalDivider.setAttribute('x1', iconAreaWidth);
            verticalDivider.setAttribute('y1', 0);
            verticalDivider.setAttribute('x2', iconAreaWidth);
            verticalDivider.setAttribute('y2', containerHeight);
            verticalDivider.setAttribute('stroke', '#ffffff');
            verticalDivider.setAttribute('stroke-width', '4.5');
            verticalDivider.setAttribute('stroke-opacity', '1');
            verticalDivider.setAttribute('opacity', '1');
            verticalDivider.setAttribute('fill', 'none');
            group.appendChild(verticalDivider);
            
            // Append group to template layer
            templateLayer.appendChild(group);
            
            // Update transform to match current zoom/pan
            updateCanvasTransform();
            
            // Keep gridlines if enabled
            if (canvasState.showGridlines) {
                const gridImage = canvasState.theme === 'light' 
                    ? `linear-gradient(rgba(0,0,0,0.1) 1px, transparent 1px),
                       linear-gradient(90deg, rgba(0,0,0,0.1) 1px, transparent 1px)`
                    : `linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                       linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px)`;
                
                container.style.backgroundImage = gridImage;
                container.style.backgroundSize = '20px 20px';
                container.style.backgroundPosition = '0 0';
                container.style.backgroundRepeat = 'repeat';
            } else {
                container.style.backgroundImage = 'none';
                container.style.backgroundSize = '';
                container.style.backgroundPosition = '';
                container.style.backgroundRepeat = '';
            }
            
            // Set background color to match theme
            container.style.backgroundColor = canvasState.theme === 'light' ? '#f5f5f5' : '#1a1a1a';
            
            // Update template selection visual after creation
            updateTemplateSelectionVisual();
        }
        
        // Update visual feedback for template selection
        function updateTemplateSelectionVisual() {
            const templateLayer = document.getElementById('templateLayer');
            if (!templateLayer) return;
            
            // Templates are locked as background - no selection visual needed
            templateLayer.style.outline = 'none';
            templateLayer.style.cursor = 'default';
        }
        
        // Setup template layer click handler for selection
        function setupTemplateSelection() {
            const templateLayer = document.getElementById('templateLayer');
            if (!templateLayer || !templateLayer.parentNode) return;
            
            try {
                // Remove any existing listeners by cloning and replacing
                const newLayer = templateLayer.cloneNode(false);
                while (templateLayer.firstChild) {
                    newLayer.appendChild(templateLayer.firstChild);
                }
                templateLayer.parentNode.replaceChild(newLayer, templateLayer);
            } catch (e) {
                console.warn('Error setting up template selection:', e);
                return;
            }
            
            // Get the updated reference
            const updatedLayer = document.getElementById('templateLayer');
            if (!updatedLayer) return;
            
            // Ensure pointer events are enabled and cursor is set
            updatedLayer.style.pointerEvents = 'auto';
            updatedLayer.style.cursor = 'pointer';
            
            // Template selection disabled - templates are locked as background
            // No click handler needed - templates are non-interactive backgrounds
        }
        
        // Update template on canvas resize - disabled for Milkyway Map (locked at 125%)
        function updateTemplateOnResize() {
            // Milkyway Map is locked at 125% and doesn't resize
            if (canvasState.canvasTemplate === 'service-blueprint') {
                createServiceBlueprintTemplate();
            }
        }
        
        // Configure template segments
        function configureTemplateSegments() {
            // Hide menus
            document.querySelectorAll('.menu-dropdown').forEach(menu => {
                menu.style.display = 'none';
            });
            
            // Load current segments if available
            loadTemplateSegments().then(() => {
                const modal = document.getElementById('templateSegmentsModal');
                if (modal) {
                    const countInput = document.getElementById('segmentCountInput');
                    const container = document.getElementById('segmentInputsContainer');
                    
                    // Clear the container first
                    if (container) {
                        container.innerHTML = '';
                    }
                    
                    if (countInput) {
                        // Set count to current segments length, or default to 4
                        const currentCount = canvasState.templateSegments && canvasState.templateSegments.length > 0 
                            ? canvasState.templateSegments.length 
                            : (canvasState.templateSegmentCount || 4);
                        countInput.value = currentCount;
                        canvasState.templateSegmentCount = currentCount;
                        
                        // Filter segments to only include those within the current count
                        if (canvasState.templateSegments && canvasState.templateSegments.length > 0) {
                            canvasState.templateSegments = canvasState.templateSegments.filter(s => s.segment_index < currentCount);
                        }
                    }
                    updateSegmentInputs();
                    modal.style.display = 'flex';
                }
            });
        }
        
        // Update segment name inputs based on count
        function updateSegmentInputs() {
            const container = document.getElementById('segmentInputsContainer');
            const countInput = document.getElementById('segmentCountInput');
            if (!container || !countInput) return;
            
            const count = parseInt(countInput.value) || 4;
            if (count < 2) {
                countInput.value = 2;
                return;
            }
            if (count > 12) {
                countInput.value = 12;
                return;
            }
            
            canvasState.templateSegmentCount = count;
            
            // Filter out any segments beyond the new count - this ensures old segments are cleared
            if (canvasState.templateSegments) {
                canvasState.templateSegments = canvasState.templateSegments.filter(s => s.segment_index < count);
            }
            
            // Clear container completely
            container.innerHTML = '';
            
            // Create input for each segment
            for (let i = 0; i < count; i++) {
                // Only use segment name if it exists and is within the current count
                const segment = canvasState.templateSegments && canvasState.templateSegments.length > 0
                    ? canvasState.templateSegments.find(s => s.segment_index === i)
                    : null;
                const segmentName = segment ? segment.segment_name : `Segment ${i + 1}`;
                
                const div = document.createElement('div');
                div.style.marginBottom = '12px';
                div.innerHTML = `
                    <label style="color: #e0e0e0; display: block; margin-bottom: 6px; font-size: 13px;">Segment ${i + 1}:</label>
                    <input type="text" id="segmentName_${i}" value="${escapeHtml(segmentName)}" 
                           style="width: 100%; padding: 8px; background: #1e1e1e; border: 1px solid #3e3e42; border-radius: 4px; color: #ffffff; font-size: 14px;"
                           placeholder="Enter segment name">
                `;
                container.appendChild(div);
            }
        }
        
        // Save template segments
        async function saveTemplateSegments() {
            const countInput = document.getElementById('segmentCountInput');
            const count = parseInt(countInput.value) || 4;
            const segments = [];
            
            for (let i = 0; i < count; i++) {
                const input = document.getElementById(`segmentName_${i}`);
                const name = input ? input.value.trim() : `Segment ${i + 1}`;
                segments.push({
                    segment_index: i,
                    segment_name: name || `Segment ${i + 1}`
                });
            }
            
            // Track if we need to save the model (new template scenario)
            const needsModelSave = !canvasState.currentModelId;
            
            try {
                // If model doesn't exist yet, we'll save it after segments are configured
                if (needsModelSave) {
                    // Store segments temporarily
                    canvasState.templateSegments = segments;
                    canvasState.templateSegmentCount = count;
                    closeTemplateSegmentsModal();
                    
                    // Recreate template to show new segments
                    if (canvasState.canvasTemplate === 'milkyway-map') {
                        createMilkywayMapTemplate();
                    }
                    
                    // Automatically open Save Model modal
                    setTimeout(() => {
                        saveCanvasModel();
                    }, 300);
                } else {
                    // Model exists, save segments to database
                    const response = await fetch(`/api/canvas/models/${canvasState.currentModelId}/template-segments`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ segments: segments })
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to save segments');
                    }
                    
                    canvasState.templateSegments = segments;
                    canvasState.templateSegmentCount = count;
                    closeTemplateSegmentsModal();
                    
                    // Recreate template to show new segments and lock it at 125%
                    if (canvasState.canvasTemplate === 'milkyway-map') {
                        createMilkywayMapTemplate();
                        // Lock template - disable selection and resizing
                        canvasState.templateSelected = false;
                        updateTemplateSelectionVisual();
                    }
                    
                    showCanvasToast('Template segments saved successfully', 'success');
                    
                    // Automatically open Save Model modal to save the updated template configuration
                    setTimeout(() => {
                        saveCanvasModel();
                    }, 300);
                }
            } catch (error) {
                showCanvasToast('Error saving segments: ' + error.message, 'error');
            }
        }
        
        // Load template segments
        async function loadTemplateSegments() {
            if (!canvasState.currentModelId) {
                canvasState.templateSegments = [];
                canvasState.templateSegmentCount = 4;
                return;
            }
            
            try {
                const response = await fetch(`/api/canvas/models/${canvasState.currentModelId}/template-segments`);
                if (response.ok) {
                    const segments = await response.json();
                    canvasState.templateSegments = segments;
                    canvasState.templateSegmentCount = segments.length || 4;
                } else {
                    canvasState.templateSegments = [];
                    canvasState.templateSegmentCount = 4;
                }
            } catch (error) {
                console.error('Error loading segments:', error);
                canvasState.templateSegments = [];
                canvasState.templateSegmentCount = 4;
            }
        }
        
        // Load element-segment associations
        async function loadElementSegmentAssociations() {
            if (!canvasState.currentModelId) {
                canvasState.elementSegmentAssociations = {};
                return;
            }
            
            try {
                const response = await fetch(`/api/canvas/models/${canvasState.currentModelId}/element-segment-associations`);
                if (response.ok) {
                    const associations = await response.json();
                    canvasState.elementSegmentAssociations = associations;
                } else {
                    canvasState.elementSegmentAssociations = {};
                }
            } catch (error) {
                console.error('Error loading associations:', error);
                canvasState.elementSegmentAssociations = {};
            }
        }
        
        // Get segment index for a given position (x, y) on the canvas
        function getSegmentForPosition(x, y) {
            if (!canvasState.templateSegments || canvasState.templateSegments.length === 0) {
                return null;
            }
            
            const container = document.getElementById('canvasContainer');
            if (!container) return null;
            
            const containerWidth = Math.max(container.scrollWidth || 2000, container.clientWidth || 2000);
            const containerHeight = Math.max(container.scrollHeight || 2000, container.clientHeight || 2000);
            const centerX = containerWidth / 2;
            const centerY = containerHeight / 2;
            
            // Calculate angle from center to element position (using element center)
            const elementCenterX = x + (120 / 2); // Assume standard element width for center calculation
            const elementCenterY = y + (120 / 2); // Assume standard element height for center calculation
            const dx = elementCenterX - centerX;
            const dy = elementCenterY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Check if element is within the template area (between inner and outer rings)
            const baseSize = Math.min(containerWidth, containerHeight) * 0.4;
            const circle1Radius = baseSize; // Outermost
            const circle4Radius = baseSize * 0.25; // Inner
            
            // Only associate if element center is within the ring area
            if (distance < circle4Radius || distance > circle1Radius) {
                return null; // Outside template area
            }
            
            // Calculate angle (atan2 returns -PI to PI, normalize to 0..2*PI)
            let angle = Math.atan2(dy, dx);
            if (angle < 0) angle += 2 * Math.PI;
            
            // Keep the top vertical axis fixed as a divider, but map index 0 to bottom-left.
            const topAxisAngle = -Math.PI / 2;
            const segmentStartAngle = topAxisAngle;
            const desiredStartAngle = (3 * Math.PI) / 4;
            let offsetAngle = desiredStartAngle - topAxisAngle;
            offsetAngle = (offsetAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
            
            // Determine which segment this angle falls into
            const segmentCount = canvasState.templateSegments.length;
            const segmentAngleStep = (2 * Math.PI) / segmentCount;
            const segmentIndexOffset = Math.floor(offsetAngle / segmentAngleStep) % segmentCount;
            let normalizedAngle = angle - segmentStartAngle;
            if (normalizedAngle < 0) normalizedAngle += 2 * Math.PI;
            let segmentIndex = Math.floor(normalizedAngle / segmentAngleStep);
            segmentIndex = (segmentIndex - segmentIndexOffset + segmentCount) % segmentCount;
            
            // Handle edge case where angle is exactly 2*PI (should be segment 0)
            if (segmentIndex >= segmentCount) {
                segmentIndex = 0;
            }
            
            return segmentIndex;
        }
        
        // Associate element with segment
        async function associateElementWithSegment(elementInstanceId, segmentIndex) {
            if (!canvasState.currentModelId) {
                // If model not saved yet, just store in memory
                canvasState.elementSegmentAssociations[elementInstanceId] = segmentIndex;
                return;
            }
            
            try {
                if (segmentIndex === null) {
                    // Remove association
                    delete canvasState.elementSegmentAssociations[elementInstanceId];
                    return;
                }
                
                const response = await fetch(`/api/canvas/models/${canvasState.currentModelId}/element-segment-associations`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        element_instance_id: elementInstanceId,
                        segment_index: segmentIndex
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to associate element');
                }
                
                canvasState.elementSegmentAssociations[elementInstanceId] = segmentIndex;
            } catch (error) {
                console.error('Error associating element with segment:', error);
                // Still store in memory even if save fails
                canvasState.elementSegmentAssociations[elementInstanceId] = segmentIndex;
            }
        }
        
        // Close template segments modal
        function closeTemplateSegmentsModal() {
            document.getElementById('templateSegmentsModal').style.display = 'none';
        }
        
        // Listen for canvas container resize
        let resizeObserver = null;
        function setupTemplateResizeObserver() {
            const container = document.getElementById('canvasContainer');
            if (!container || resizeObserver) return;
            
            // Use ResizeObserver to detect canvas size changes
            if (typeof ResizeObserver !== 'undefined') {
                resizeObserver = new ResizeObserver(() => {
                    // Milkyway Map is locked at 125% and doesn't resize
                    if (canvasState.canvasTemplate === 'service-blueprint') {
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                createServiceBlueprintTemplate();
                            });
                        });
                    }
                });
                resizeObserver.observe(container);
            }
        }
        
        function closeAllDialogs() {
            const modals = ['repositoryModal'];
            modals.forEach(id => {
                const modal = document.getElementById(id);
                if (modal) modal.style.display = 'none';
            });
            const backdrop = document.getElementById('dialogBackdrop');
            if (backdrop) backdrop.style.display = 'none';
        }

        // Records list (Add Element)

        async function loadRecords() {
            const recordsList = document.getElementById('recordsList');
            if (recordsList) {
                recordsList.innerHTML = '<div class="empty-state">Loading records...</div>';
            }
            try {
                const response = await fetch('/api/records');
                if (!response.ok) {
                    throw new Error('Failed to load records');
                }
                allRecords = await response.json();
                populateRecordFilters(allRecords);
                loadFilterPresets();
                renderRecordsList(allRecords);
            } catch (error) {
                if (recordsList) {
                    recordsList.innerHTML = `<div class="empty-state">Error loading records: ${error.message}</div>`;
                }
            }
        }

        function populateRecordFilters(records) {
            const elementSelect = document.getElementById('filterElementType');
            const facetSelect = document.getElementById('filterFacet');
            const enterpriseSelect = document.getElementById('filterEnterprise');
            if (!elementSelect || !facetSelect || !enterpriseSelect) return;

            const currentElement = elementSelect.value;
            const currentFacet = facetSelect.value;
            const currentEnterprise = enterpriseSelect.value;

            const elementTypes = new Set();
            const facets = new Set();
            const enterprises = new Set();

            records.forEach(record => {
                const elementType = record.element || record.element_type || record.element_type_name || record.element_name;
                if (elementType) elementTypes.add(elementType);
                if (record.facet) facets.add(record.facet);
                if (record.enterprise) enterprises.add(record.enterprise);
            });

            elementSelect.innerHTML = '<option value="">All Types</option>';
            Array.from(elementTypes).sort().forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                elementSelect.appendChild(option);
            });

            facetSelect.innerHTML = '<option value="">All Facets</option>';
            Array.from(facets).sort().forEach(facet => {
                const option = document.createElement('option');
                option.value = facet;
                option.textContent = facet;
                facetSelect.appendChild(option);
            });

            enterpriseSelect.innerHTML = '<option value="">All Enterprises</option>';
            Array.from(enterprises).sort().forEach(enterprise => {
                const option = document.createElement('option');
                option.value = enterprise;
                option.textContent = enterprise;
                enterpriseSelect.appendChild(option);
            });

            elementSelect.value = currentElement;
            facetSelect.value = currentFacet;
            enterpriseSelect.value = currentEnterprise;
        }

        function recordHasProperties(record) {
            if (!record) return false;
            if (Array.isArray(record.properties)) return record.properties.length > 0;
            if (typeof record.properties === 'string') {
                try {
                    const parsed = JSON.parse(record.properties);
                    return Array.isArray(parsed) ? parsed.length > 0 : Boolean(parsed);
                } catch {
                    return Boolean(record.properties);
                }
            }
            return Boolean(record.propertyname);
        }

        function filterRecords() {
            const searchText = (document.getElementById('searchText')?.value || '').toLowerCase();
            const filterElement = document.getElementById('filterElementType')?.value || '';
            const filterFacet = document.getElementById('filterFacet')?.value || '';
            const filterEnterprise = document.getElementById('filterEnterprise')?.value || '';
            const filterHasProperties = document.getElementById('filterHasProperties')?.value || '';

            const filtered = allRecords.filter(record => {
                const name = (record.name || '').toLowerCase();
                const description = (record.description || '').toLowerCase();
                const element = record.element || '';
                const facet = record.facet || '';
                const enterprise = record.enterprise || '';

                const matchesSearch = !searchText || name.includes(searchText) || description.includes(searchText);
                const matchesElement = !filterElement || element === filterElement;
                const matchesFacet = !filterFacet || facet === filterFacet;
                const matchesEnterprise = !filterEnterprise || enterprise === filterEnterprise;
                const matchesProps = filterHasProperties === ''
                    ? true
                    : filterHasProperties === 'yes'
                        ? recordHasProperties(record)
                        : !recordHasProperties(record);

                return matchesSearch && matchesElement && matchesFacet && matchesEnterprise && matchesProps;
            });

            renderRecordsList(filtered);
        }

        function renderRecordsList(records) {
            const recordsList = document.getElementById('recordsList');
            if (!recordsList) return;
            const resultCount = document.getElementById('filterResultsCount');
            if (resultCount) {
                resultCount.textContent = `${records.length} result${records.length === 1 ? '' : 's'}`;
            }

            if (!records.length) {
                recordsList.innerHTML = '<div class="empty-state">No records found.</div>';
                return;
            }

            recordsList.innerHTML = records.map(record => {
                const imageUrl = record.image_url ? escapeHtml(record.image_url) : '';
                return `
                    <div class="record-card">
                        <div class="record-header">
                            <div class="record-id">${escapeHtml(record.name || 'Unnamed')}</div>
                            <button class="refresh-btn delete-btn" onclick="deleteRecord(${record.id})" style="padding: 4px 8px; font-size: 11px;">Delete</button>
                        </div>
                        ${imageUrl ? `
                        <div class="record-image">
                            <img src="${imageUrl}" alt="${escapeHtml(record.name || 'Record')}">
                        </div>` : ''}
                        <div class="record-field"><strong>Element:</strong> <span>${escapeHtml(record.element || 'N/A')}</span></div>
                        <div class="record-field"><strong>Facet:</strong> <span>${escapeHtml(record.facet || 'N/A')}</span></div>
                        <div class="record-field"><strong>Enterprise:</strong> <span>${escapeHtml(record.enterprise || 'N/A')}</span></div>
                        ${record.description ? `<div class="record-field"><strong>Description:</strong> <span>${escapeHtml(record.description)}</span></div>` : ''}
                    </div>
                `;
            }).join('');
        }

        function saveFilterPreset() {
            const presetName = prompt('Name this filter preset:');
            if (!presetName) return;
            const preset = {
                searchText: document.getElementById('searchText')?.value || '',
                filterElementType: document.getElementById('filterElementType')?.value || '',
                filterFacet: document.getElementById('filterFacet')?.value || '',
                filterEnterprise: document.getElementById('filterEnterprise')?.value || '',
                filterHasProperties: document.getElementById('filterHasProperties')?.value || ''
            };
            const presets = JSON.parse(localStorage.getItem('edgyFilterPresets') || '{}');
            presets[presetName] = preset;
            localStorage.setItem('edgyFilterPresets', JSON.stringify(presets));
            loadFilterPresets();
        }

        function loadFilterPresets() {
            const select = document.getElementById('filterPresets');
            if (!select) return;
            const presets = JSON.parse(localStorage.getItem('edgyFilterPresets') || '{}');
            select.innerHTML = '<option value="">Load Saved Filter...</option>';
            Object.keys(presets).sort().forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            });
        }

        function loadFilterPreset(presetName) {
            if (!presetName) return;
            const presets = JSON.parse(localStorage.getItem('edgyFilterPresets') || '{}');
            const preset = presets[presetName];
            if (!preset) return;
            const searchText = document.getElementById('searchText');
            const filterElementType = document.getElementById('filterElementType');
            const filterFacet = document.getElementById('filterFacet');
            const filterEnterprise = document.getElementById('filterEnterprise');
            const filterHasProperties = document.getElementById('filterHasProperties');
            if (searchText) searchText.value = preset.searchText || '';
            if (filterElementType) filterElementType.value = preset.filterElementType || '';
            if (filterFacet) filterFacet.value = preset.filterFacet || '';
            if (filterEnterprise) filterEnterprise.value = preset.filterEnterprise || '';
            if (filterHasProperties) filterHasProperties.value = preset.filterHasProperties || '';
            filterRecords();
        }

        function toggleAnalyticsModal() {
            openRepositoryTab('analytics');
        }

        function ensureAnalyticsContentLayout() {
            const analyticsContent = document.getElementById('analyticsContent');
            if (!analyticsContent || document.getElementById('designRulesSection')) return;
            analyticsContent.innerHTML = `
                <div style="display: flex; gap: 20px; align-items: flex-start; flex-wrap: wrap; margin-bottom: 20px;">
                    <div style="flex: 1; min-width: 300px; min-height: 340px; display: flex; align-items: center; gap: 16px; margin: 0 auto;">
                        <div style="min-width: 160px; max-width: 220px; color: #ffffff; font-size: 11px; text-align: left; line-height: 1.4;">
                            <div style="white-space: normal; word-break: break-word;">0 = Poor. 100 = Good.</div>
                            <div style="margin-top: 6px; white-space: normal; word-break: break-word;">Higher scores indicate healthier repository alignment.</div>
                    </div>
                        <div style="flex: 1; display: flex; flex-direction: column; align-items: center; margin-top: 28px; padding-top: 6px; overflow: visible;">
                            <canvas id="repositoryAdviceMeterChart" style="width: 100%; max-width: 520px; height: 230px; display: block; margin: 0 auto;"></canvas>
                            <div id="gaugeLegendContainer" style="margin-top: 10px; width: 100%; max-width: 520px; margin-left: auto; margin-right: auto;"></div>
                    </div>
                    </div>
                    <div id="designRulesSummaryCards" style="display: grid; gap: 8px; min-width: 160px; margin-left: auto;"></div>
                </div>
                <div id="designRulesSection"></div>
            `;
        }

        async function loadAnalytics() {
            try {
                const response = await fetch('/api/analytics');
                if (!response.ok) {
                    throw new Error('Failed to load analytics');
                }
                const analytics = await response.json();
                updateAnalyticsDisplay(analytics);
            } catch (error) {
                const analyticsContent = document.getElementById('analyticsContent');
                if (analyticsContent) {
                    analyticsContent.innerHTML = `<div style="color: #ff6b6b; padding: 10px;">Error loading analytics: ${error.message}</div>`;
                }
            }
        }

        async function loadDesignRulesAndViolations() {
            ensureAnalyticsContentLayout();
            try {
                const rulesResponse = await fetch('/api/analytics/design-rules');
                if (!rulesResponse.ok) throw new Error('Failed to load rules');
                const rules = await rulesResponse.json();

                const violationsResponse = await fetch('/api/analytics/design-rules/violations');
                const violations = violationsResponse.ok ? await violationsResponse.json() : [];

                createRepositoryAdviceMeterChart(violations, rules);
                renderDesignRulesSection(rules, violations);
            } catch (error) {
                const section = document.getElementById('designRulesSection');
                if (section) {
                    section.innerHTML = `<div style="color: #ff6b6b; padding: 10px;">Error loading design rules: ${error.message}</div>`;
                }
            }
        }

        async function openImpactAnalysisModal() {
            await populateImpactAnalysisOptions();
            const modal = document.getElementById('impactAnalysisModal');
            if (modal) {
                modal.style.display = 'flex';
            }
        }

        function closeImpactAnalysisModal() {
            const modal = document.getElementById('impactAnalysisModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        async function populateImpactAnalysisOptions() {
            const sourceSelect = document.getElementById('impactSourceInstance');
            const relSelect = document.getElementById('impactRelationshipTypes');
            if (!sourceSelect || !relSelect) return;

            sourceSelect.innerHTML = '<option value="">Search repository occurrences...</option>';
            relSelect.innerHTML = '';

            try {
                const relTypesResponse = await fetch('/api/relationship-types');
                if (relTypesResponse.ok) {
                    const relTypes = await relTypesResponse.json();
                    relSelect.innerHTML = relTypes.map(type => `<option value="${escapeHtml(type)}">${escapeHtml(type)}</option>`).join('');
                }
            } catch (error) {
                console.error('Error loading impact analysis options:', error);
                sourceSelect.innerHTML = '<option value="">Failed to load options</option>';
            }
        }

        async function searchImpactOccurrences() {
            const query = document.getElementById('impactSearchInput')?.value.trim();
            const sourceSelect = document.getElementById('impactSourceInstance');
            if (!sourceSelect) return;
            if (!query) {
                sourceSelect.innerHTML = '<option value="">Enter a search term first</option>';
                return;
            }

            sourceSelect.innerHTML = '<option value="">Searching...</option>';
            try {
                const response = await fetch(`/api/canvas/element-instances/search?q=${encodeURIComponent(query)}`);
                if (!response.ok) {
                    throw new Error('Search failed');
                }
                const results = await response.json();
                if (!results.length) {
                    sourceSelect.innerHTML = '<option value="">No matches found</option>';
                    return;
                }
                sourceSelect.innerHTML = results.map(item => {
                    const label = `${item.instance_name || 'Untitled'} (${item.element_type || 'Unknown'})  ${item.model_name || 'Unknown Model'}`;
                    return `<option value="${item.id}">${escapeHtml(label)}</option>`;
                }).join('');
            } catch (error) {
                console.error('Error searching occurrences:', error);
                sourceSelect.innerHTML = '<option value="">Search failed</option>';
            }
        }

        async function loadImpactModels() {
            const container = document.getElementById('impactModelsList');
            if (!container) return;
            container.innerHTML = '<div class="empty-state">Loading impact models...</div>';
            try {
                const response = await fetch('/api/canvas/models');
                if (!response.ok) throw new Error('Failed to load models');
                const models = await response.json();
                const impactModels = (models || []).filter(model => (model.name || '').toLowerCase().startsWith('impact:'));
                if (!impactModels.length) {
                    container.innerHTML = '<div class="empty-state">No impact models created yet.</div>';
                    return;
                }
                const listHtml = impactModels.map(model => {
                    const updated = model.updated_at ? new Date(model.updated_at).toLocaleString() : 'Unknown';
                    const description = model.description ? escapeHtml(model.description) : 'No description';
                    return `
                        <div style="padding: 10px; background: #1e1e1e; border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px;">
                                <div>
                                    <div style="color: #ffffff; font-weight: 600; font-size: 13px;">${escapeHtml(model.name)}</div>
                                    <div style="color: #b0b0d0; font-size: 11px; margin-top: 4px;">${description}</div>
                                    <div style="color: #888; font-size: 10px; margin-top: 4px;">Updated: ${updated}</div>
                                </div>
                                <div style="display: flex; gap: 6px;">
                                    <button class="refresh-btn" onclick="loadCanvasModel(${model.id})" style="padding: 4px 8px; font-size: 11px;">Open</button>
                                    <button class="refresh-btn" onclick="deleteCanvasModel(${model.id})" style="padding: 4px 8px; font-size: 11px;">Delete</button>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                container.innerHTML = listHtml;
            } catch (error) {
                container.innerHTML = `<div class="empty-state">Error loading impact models: ${error.message}</div>`;
            }
        }

        async function runImpactAnalysis() {
            const sourceId = document.getElementById('impactSourceInstance')?.value;
            const depth = parseInt(document.getElementById('impactDepth')?.value || '2', 10);
            const direction = document.getElementById('impactDirection')?.value || 'both';
            const relSelect = document.getElementById('impactRelationshipTypes');
            const relationship_types = relSelect ? Array.from(relSelect.selectedOptions).map(o => o.value) : [];

            if (!sourceId) {
                showCanvasToast('Select a source occurrence to analyze.', 'warning');
                return;
            }

            showCanvasToast('Running impact analysis...', 'info');

            try {
                const response = await fetch('/api/impact-analysis/create-model', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        source_instance_id: parseInt(sourceId, 10),
                        max_depth: depth,
                        direction,
                        relationship_types
                    })
                });
                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));
                    throw new Error(error.error || 'Failed to run impact analysis');
                }
                const result = await response.json();
                closeImpactAnalysisModal();
                showSection('modelingCanvas');
                await loadCanvasModel(result.model_id);
                showCanvasToast(`Impact model created: ${result.model_name}`, 'success');
            } catch (error) {
                showCanvasToast(`Impact analysis failed: ${error.message}`, 'error');
            }
        }

        function showToastMessage(message, type = 'info') {
            const existing = document.getElementById('edgyToastContainer');
            const container = existing || (() => {
                const div = document.createElement('div');
                div.id = 'edgyToastContainer';
                div.style.position = 'fixed';
                div.style.right = '20px';
                div.style.bottom = '20px';
                div.style.display = 'flex';
                div.style.flexDirection = 'column';
                div.style.gap = '8px';
                div.style.zIndex = '10020';
                document.body.appendChild(div);
                return div;
            })();

            const toast = document.createElement('div');
            const bgMap = {
                info: '#2d2d30',
                success: '#107c10',
                error: '#a4262c',
                warning: '#8a6d3b'
            };
            toast.textContent = message;
            toast.style.background = bgMap[type] || bgMap.info;
            toast.style.color = '#ffffff';
            toast.style.border = '1px solid rgba(255,255,255,0.15)';
            toast.style.borderRadius = '6px';
            toast.style.padding = '10px 12px';
            toast.style.fontSize = '12px';
            toast.style.boxShadow = '0 4px 12px rgba(0,0,0,0.35)';
            toast.style.maxWidth = '320px';
            toast.style.opacity = '0';
            toast.style.transform = 'translateY(6px)';
            toast.style.transition = 'opacity 0.2s ease, transform 0.2s ease';
            container.appendChild(toast);

            requestAnimationFrame(() => {
                toast.style.opacity = '1';
                toast.style.transform = 'translateY(0)';
            });

            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateY(6px)';
                setTimeout(() => toast.remove(), 250);
            }, 2600);
        }

        async function evaluateAllDesignRules() {
            const button = document.getElementById('evaluateAllRulesBtn');
            if (button) {
                button.disabled = true;
                button.textContent = 'Evaluating...';
                button.style.opacity = '0.7';
            }

            const previousRuleProps = getAllRuleGeneratedPropsFromCanvas();
            const previousElementProps = getAllCanvasOccurrencePropsFromCanvas();
            const previousViolations = await fetchDesignRuleViolations();
            showToastMessage('Evaluating all design rules...', 'info');

            try {
                const response = await fetch('/api/analytics/design-rules/evaluate-all', { method: 'POST' });
                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));
                    throw new Error(error.error || 'Failed to evaluate rules');
                }

                const changeSummary = await refreshRuleGeneratedProperties(previousRuleProps, { skipEvaluate: true });
                await new Promise(resolve => setTimeout(resolve, 250));

                const nextViolations = await fetchDesignRuleViolations();
                const violationSummary = summarizeViolationColorChanges(previousViolations, nextViolations);
                const elementPropSummary = summarizeElementPropertyColorChanges(
                    previousElementProps,
                    getAllCanvasOccurrencePropsFromCanvas()
                );
                showEdglyChangeNotification(changeSummary, violationSummary, elementPropSummary);

                loadDesignRulesAndViolations();
                showToastMessage(`Rules evaluated. ${nextViolations.length} active advice item(s).`, 'success');
            } catch (error) {
                showToastMessage(`Rules evaluation failed: ${error.message}`, 'error');
                alert('Error evaluating rules: ' + error.message);
            } finally {
                if (button) {
                    button.disabled = false;
                    button.textContent = 'Evaluate All';
                    button.style.opacity = '1';
                }
            }
        }

        function toggleRepositoryModal(defaultTab = 'repository') {
            const modal = document.getElementById('repositoryModal');
            if (!modal) return;
            const isOpen = modal.style.display === 'flex';
            modal.style.display = isOpen ? 'none' : 'flex';
            if (!isOpen) {
                setRepositoryTab(defaultTab);
            }
        }

        function toggleRepositoryPropertiesModal() {
            openRepositoryTab('properties');
        }

        function openRepositoryTab(tabName) {
            const modal = document.getElementById('repositoryModal');
            if (!modal) return;
            if (modal.style.display !== 'flex') {
                modal.style.display = 'flex';
            }
            setRepositoryTab(tabName);
        }

        function setRepositoryTab(tabName) {
            const tabs = document.querySelectorAll('.repository-tab-btn');
            const panels = document.querySelectorAll('.repository-tab-panel');
            tabs.forEach(tab => {
                const isActive = tab.dataset.tab === tabName;
                tab.classList.toggle('active', isActive);
            });
            panels.forEach(panel => {
                panel.classList.toggle('active', panel.id === `repositoryTab-${tabName}`);
            });

            if (tabName === 'repository') {
                loadRepositoryRecords();
            } else if (tabName === 'analytics') {
                loadAnalytics();
                loadDesignRulesAndViolations();
            } else if (tabName === 'impact') {
                populateImpactAnalysisOptions();
                loadImpactModels();
            } else if (tabName === 'properties') {
                loadRepositoryProperties();
            } else if (tabName === 'models') {
                loadRepositoryModels();
            }
        }

        function isRepositoryTabActive(tabName) {
            const modal = document.getElementById('repositoryModal');
            const panel = document.getElementById(`repositoryTab-${tabName}`);
            return modal && modal.style.display === 'flex' && panel && panel.classList.contains('active');
        }

        async function loadRepositoryProperties() {
            const container = document.getElementById('repositoryPropertiesContent');
            if (!container) return;
            container.innerHTML = '<div class="empty-state">Loading properties...</div>';
            try {
                const response = await fetch('/api/properties/manage');
                if (!response.ok) {
                    throw new Error('Failed to load properties');
                }
                const properties = await response.json();
                renderRepositoryProperties(properties || []);
            } catch (error) {
                console.error('Error loading properties:', error);
                container.innerHTML = `<div class="empty-state">Error loading properties: ${escapeHtml(error.message)}</div>`;
            }
        }

        function getNextModalZIndex() {
            if (typeof window.modalDragZIndex !== 'number') {
                window.modalDragZIndex = 10005;
            }
            window.modalDragZIndex += 1;
            return window.modalDragZIndex;
        }

        function makeModalDraggable(container, handle) {
            if (!container || !handle) return;
            let isDragging = false;
            let offsetX = 0;
            let offsetY = 0;

            handle.classList.add('draggable-handle');

            const startDrag = (event) => {
                if (event.button !== 0) return;
                if (event.target.closest('button, input, select, textarea, a')) return;
                isDragging = true;
                const rect = container.getBoundingClientRect();
                offsetX = event.clientX - rect.left;
                offsetY = event.clientY - rect.top;

                container.style.position = 'absolute';
                container.style.left = `${rect.left}px`;
                container.style.top = `${rect.top}px`;
                container.style.margin = '0';
                container.style.transform = 'none';
                container.style.zIndex = getNextModalZIndex();

                document.addEventListener('pointermove', onDrag);
                document.addEventListener('pointerup', stopDrag);
                event.preventDefault();
            };

            const onDrag = (event) => {
                if (!isDragging) return;
                container.style.left = `${event.clientX - offsetX}px`;
                container.style.top = `${event.clientY - offsetY}px`;
            };

            const stopDrag = () => {
                isDragging = false;
                document.removeEventListener('pointermove', onDrag);
                document.removeEventListener('pointerup', stopDrag);
            };

            handle.addEventListener('pointerdown', startDrag);
        }

        function initDraggableModals() {
            const repoModal = document.querySelector('#repositoryModal > div');
            if (repoModal) {
                const repoHandle = repoModal.querySelector('.draggable-handle');
                makeModalDraggable(repoModal, repoHandle);
            }

            document.querySelectorAll('.modal-content').forEach(content => {
                const handle = content.querySelector('.plantuml-header') || content.querySelector('.dialog-title-bar');
                makeModalDraggable(content, handle);
            });

            document.querySelectorAll('.windows-dialog').forEach(dialog => {
                const handle = dialog.querySelector('.dialog-title-bar') || dialog;
                makeModalDraggable(dialog, handle);
            });
        }

        function renderRepositoryProperties(properties) {
            const container = document.getElementById('repositoryPropertiesContent');
            if (!container) return;

            const state = window.repositoryPropertiesState || { editId: null };
            window.repositoryPropertiesState = state;

            const createForm = `
                <div class="repository-properties-toolbar">
                    <input id="repositoryPropertyName" type="text" placeholder="Property name" style="min-width: 160px;">
                    <select id="repositoryPropertyRagType">
                        <option value="">RAG (optional)</option>
                        <option value="positive">Positive</option>
                        <option value="warning">Warning</option>
                        <option value="negative">Negative</option>
                    </select>
                    <input id="repositoryPropertyDescription" type="text" placeholder="Description (optional)" style="flex: 1; min-width: 200px;">
                    <button class="refresh-btn" onclick="createRepositoryProperty()">Create</button>
                </div>
                <div style="color: #808080; font-size: 11px; margin-bottom: 12px;">
                    Rules Engine properties are read-only and marked with a gear icon.
                </div>
            `;

            if (!properties || properties.length === 0) {
                container.innerHTML = `${createForm}<div class="empty-state">No properties found.</div>`;
                return;
            }

            const rows = properties.map(prop => {
                const tagImage = prop.image_url || getTagImageFromRAG(prop.ragtype) || '/images/Tag-Green.svg';
                const ragLabel = prop.ragtype ? prop.ragtype.toUpperCase() : 'N/A';
                const isRules = Boolean(prop.is_rules_generated);
                const gear = isRules ? '<span class="repository-property-gear" title="Rules Engine">&#9881;</span>' : '';
                const isEditing = state.editId === prop.id;

                if (isEditing) {
                    return `
                        <div class="repository-property-row">
                            <div class="repository-property-icon">
                                <img src="${tagImage}" alt="${escapeHtml(prop.propertyname || 'Property')}" 
                                     onerror="this.src='/images/Tag-Green.svg'; this.onerror=null;">
                                ${gear}
                            </div>
                            <div style="flex: 1;">
                                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                    <input id="editPropertyName-${prop.id}" type="text" value="${escapeHtml(prop.propertyname || '')}" style="min-width: 160px;">
                                    <select id="editPropertyRag-${prop.id}">
                                        <option value="" ${!prop.ragtype ? 'selected' : ''}>RAG (optional)</option>
                                        <option value="positive" ${prop.ragtype === 'positive' ? 'selected' : ''}>Positive</option>
                                        <option value="warning" ${prop.ragtype === 'warning' ? 'selected' : ''}>Warning</option>
                                        <option value="negative" ${prop.ragtype === 'negative' ? 'selected' : ''}>Negative</option>
                                    </select>
                                    <input id="editPropertyDesc-${prop.id}" type="text" value="${escapeHtml(prop.description || '')}" style="flex: 1; min-width: 200px;">
                                </div>
                                <div class="repository-property-actions">
                                    <button class="refresh-btn" onclick="saveRepositoryProperty(${prop.id})">Save</button>
                                    <button class="refresh-btn" onclick="cancelRepositoryPropertyEdit()">Cancel</button>
                                </div>
                            </div>
                            <div style="color: #808080; font-size: 11px; min-width: 70px; text-align: right;">
                                ${ragLabel}
                            </div>
                        </div>
                    `;
                }

                return `
                    <div class="repository-property-row">
                        <div class="repository-property-icon">
                            <img src="${tagImage}" alt="${escapeHtml(prop.propertyname || 'Property')}" 
                                 onerror="this.src='/images/Tag-Green.svg'; this.onerror=null;">
                            ${gear}
                        </div>
                        <div style="flex: 1;">
                            <div style="color: #ffffff; font-size: 13px; font-weight: 600;">${escapeHtml(prop.propertyname || 'Property')}</div>
                            <div style="color: #a0a0a0; font-size: 11px; margin-top: 4px;">
                                ${escapeHtml(prop.description || 'No description')}
                            </div>
                            <div class="repository-property-actions">
                                <button class="refresh-btn" onclick="editRepositoryProperty(${prop.id})" ${isRules ? 'disabled' : ''}>Edit</button>
                                <button class="refresh-btn" onclick="deleteRepositoryProperty(${prop.id})" ${isRules ? 'disabled' : ''}>Delete</button>
                            </div>
                        </div>
                        <div style="color: #808080; font-size: 11px; min-width: 70px; text-align: right;">
                            ${ragLabel}
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `${createForm}${rows}`;
            window.repositoryPropertiesState.list = properties;
        }

        async function createRepositoryProperty() {
            const nameInput = document.getElementById('repositoryPropertyName');
            const ragInput = document.getElementById('repositoryPropertyRagType');
            const descInput = document.getElementById('repositoryPropertyDescription');
            if (!nameInput || !ragInput || !descInput) return;

            const propertyname = nameInput.value.trim();
            const ragtype = ragInput.value.trim();
            const description = descInput.value.trim();
            const image_url = getTagImageFromRAG(ragtype) || '';

            if (!propertyname) {
                alert('Please enter a property name');
                return;
            }

            try {
                const response = await fetch('/api/properties', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ propertyname, ragtype, description, image_url })
                });
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to create property');
                }
                nameInput.value = '';
                ragInput.value = '';
                descInput.value = '';
                await loadRepositoryProperties();
            } catch (error) {
                alert(`Error creating property: ${error.message}`);
            }
        }

        function editRepositoryProperty(propertyId) {
            window.repositoryPropertiesState = window.repositoryPropertiesState || {};
            window.repositoryPropertiesState.editId = propertyId;
            renderRepositoryProperties(window.repositoryPropertiesState.list || []);
        }

        function cancelRepositoryPropertyEdit() {
            window.repositoryPropertiesState = window.repositoryPropertiesState || {};
            window.repositoryPropertiesState.editId = null;
            renderRepositoryProperties(window.repositoryPropertiesState.list || []);
        }

        async function saveRepositoryProperty(propertyId) {
            const state = window.repositoryPropertiesState || {};
            const properties = state.list || [];
            const prop = properties.find(p => p.id === propertyId);
            if (!prop) return;

            const nameInput = document.getElementById(`editPropertyName-${propertyId}`);
            const ragInput = document.getElementById(`editPropertyRag-${propertyId}`);
            const descInput = document.getElementById(`editPropertyDesc-${propertyId}`);
            if (!nameInput || !ragInput || !descInput) return;

            const propertyname = nameInput.value.trim();
            const ragtype = ragInput.value.trim();
            const description = descInput.value.trim();
            const image_url = getTagImageFromRAG(ragtype) || '';

            if (!propertyname) {
                alert('Please enter a property name');
                return;
            }

            try {
                const response = await fetch('/api/properties', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        old_propertyname: prop.propertyname || '',
                        old_ragtype: prop.ragtype || '',
                        old_description: prop.description || '',
                        old_image_url: prop.image_url || '',
                        propertyname,
                        ragtype,
                        description,
                        image_url
                    })
                });
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to update property');
                }
                window.repositoryPropertiesState.editId = null;
                await loadRepositoryProperties();
            } catch (error) {
                alert(`Error updating property: ${error.message}`);
            }
        }

        async function deleteRepositoryProperty(propertyId) {
            const state = window.repositoryPropertiesState || {};
            const properties = state.list || [];
            const prop = properties.find(p => p.id === propertyId);
            if (!prop) return;
            if (!confirm(`Delete property "${prop.propertyname}"?`)) {
                return;
            }
            try {
                const response = await fetch('/api/properties', {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        propertyname: prop.propertyname || '',
                        ragtype: prop.ragtype || '',
                        description: prop.description || '',
                        image_url: prop.image_url || ''
                    })
                });
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to delete property');
                }
                await loadRepositoryProperties();
            } catch (error) {
                alert(`Error deleting property: ${error.message}`);
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            loadRecords();
            // Canvas is now the default view (active class set in HTML)
            setTimeout(() => {
                if (typeof initCanvas === 'function') {
                    initCanvas();
                }
                // Update menu item state on load
                if (typeof updateAutoCreateRelationshipsMenuItem === 'function') {
                    updateAutoCreateRelationshipsMenuItem();
                }
                updateEdglyNotificationsToggle();
                updateEdglyBubbleTheme();
                initDraggableModals();
            }, 100);
        });

        // Show/hide sections - make available globally immediately
        window.showSection = function(sectionId) {
            // Hide all sections
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Show selected section
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.add('active');
                
                // Load data when switching to sections that need it
                if (sectionId === 'addElement') {
                    loadRecords();
                    loadAvailableProperties();
                }
                if (sectionId === 'chatbot') {
                    promptForUserName();
                }
                
                // Initialize canvas when showing modeling canvas
                if (sectionId === 'modelingCanvas') {
                    setTimeout(() => {
                        // Initialize canvas if not already initialized
                        if (typeof initCanvas === 'function') {
                            initCanvas();
                        }
                    }, 100);
                }
            }
        }

        // Update dashboard statistics
        async function updateDashboardStats() {
            try {
                const [analyticsResponse] = await Promise.all([
                    fetch('/api/analytics').catch(() => null) // Analytics is optional
                ]);
                
                let analytics = null;
                
                // Get element instances count from analytics
                if (analyticsResponse && analyticsResponse.ok) {
                    analytics = await analyticsResponse.json(); // Read once and store
                    document.getElementById('elementsCount').textContent = analytics.summary.total_elements || 0;
                    document.getElementById('relationshipsCount').textContent = analytics.summary.total_relationships || 0;
                    
                    // Update all analytics displays including charts
                    updateAnalyticsDisplay(analytics);
                } else {
                    // Fallback: try to get from canvas models
                    try {
                        const modelsResponse = await fetch('/api/canvas/models');
                        if (modelsResponse.ok) {
                            const models = await modelsResponse.json();
                            let totalInstances = 0;
                            let totalRelationships = 0;
                            for (const model of models) {
                                const modelResponse = await fetch(`/api/canvas/models/${model.id}`);
                                if (modelResponse.ok) {
                                    const modelData = await modelResponse.json();
                                    totalInstances += (modelData.elements || []).length;
                                    totalRelationships += (modelData.relationships || []).length;
                                }
                            }
                            document.getElementById('elementsCount').textContent = totalInstances || 0;
                            document.getElementById('relationshipsCount').textContent = totalRelationships || 0;
                        }
                    } catch (e) {
                        console.error('Error loading element instances:', e);
                        document.getElementById('elementsCount').textContent = '0';
                        document.getElementById('relationshipsCount').textContent = '0';
                    }
                }
                
                // Update enhanced analytics if available (reuse already-read analytics data)
                if (analytics) {
                    updateAnalyticsDisplay(analytics);
                } else {
                    // Fallback: hide analytics section if API fails
                    const analyticsSection = document.getElementById('analyticsSection');
                    if (analyticsSection) analyticsSection.style.display = 'none';
                }
            } catch (error) {
                console.error('Error updating stats:', error);
                const analyticsSection = document.getElementById('analyticsSection');
                if (analyticsSection) analyticsSection.style.display = 'none';
            }
        }
        
        // Update analytics display
        function updateAnalyticsDisplay(analytics) {
            const section = document.getElementById('analyticsSection');
            if (!section) return;
            
            section.style.display = 'block';
            
            // Update summary stats
            const summary = analytics.summary;
            const completenessEl = document.getElementById('completenessScore');
            if (completenessEl) completenessEl.textContent = summary.completeness_score + '%';
            
            // Update health metrics
            const health = analytics.health_metrics;
            const descCoverage = document.getElementById('descriptionCoverage');
            const descDetail = document.getElementById('descriptionDetail');
            if (descCoverage) descCoverage.textContent = health.description_coverage + '%';
            if (descDetail) descDetail.textContent = `${health.elements_with_description} of ${summary.total_elements} instances`;
            
            const propCoverage = document.getElementById('propertiesCoverage');
            const propDetail = document.getElementById('propertiesDetail');
            if (propCoverage) propCoverage.textContent = health.properties_coverage + '%';
            if (propDetail) propDetail.textContent = `${health.elements_with_properties} of ${summary.total_elements} instances`;
            
            const relCoverage = document.getElementById('relationshipsCoverage');
            const relDetail = document.getElementById('relationshipsDetail');
            if (relCoverage) relCoverage.textContent = health.relationships_coverage + '%';
            if (relDetail) relDetail.textContent = `${health.elements_with_relationships} of ${summary.total_elements} instances`;
            
            const avgRel = document.getElementById('avgRelationships');
            if (avgRel) avgRel.textContent = summary.avg_relationships_per_element.toFixed(2);
            
            // Update charts
            console.log('[Analytics] Distributions:', analytics.distributions);
            if (analytics.distributions) {
                updateFacetChart(analytics.distributions.facets || {});
                updateElementTypeChart(analytics.distributions.element_types || {});
                updateRAGChart(analytics.distributions.rag_status || {});
            } else {
                console.warn('[Analytics] No distributions data found');
                updateFacetChart({});
                updateElementTypeChart({});
                updateRAGChart({});
            }
            
            // Update issues
            const issues = analytics.issues;
            const orphanedCount = document.getElementById('orphanedCount');
            const incompleteCount = document.getElementById('incompleteCount');
            if (orphanedCount) orphanedCount.textContent = issues.orphaned_elements.length;
            if (incompleteCount) incompleteCount.textContent = issues.incomplete_elements.length;
            
            const orphanedList = document.getElementById('orphanedList');
            if (orphanedList) {
                if (issues.orphaned_elements.length > 0) {
                    orphanedList.innerHTML = issues.orphaned_elements.map(e => 
                        `<div style="padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">${escapeHtml(e.name)}</div>`
                    ).join('');
                } else {
                            orphanedList.innerHTML = '<div style="color: #4caf50;">No orphaned instances</div>';
                }
            }
            
            const incompleteList = document.getElementById('incompleteList');
            if (incompleteList) {
                if (issues.incomplete_elements.length > 0) {
                    incompleteList.innerHTML = issues.incomplete_elements.map(e => 
                        `<div style="padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            ${escapeHtml(e.name)} - Missing: ${e.missing.join(', ')}
                        </div>`
                    ).join('');
                } else {
                            incompleteList.innerHTML = '<div style="color: #4caf50;">All instances are complete</div>';
                }
            }
        }
        
        // Simple chart rendering functions
        function updateFacetChart(facetData) {
            const chartDiv = document.getElementById('facetChart');
            if (!chartDiv) {
                console.warn('[FacetChart] Chart div not found');
                return;
            }
            if (!facetData || typeof facetData !== 'object') {
                console.warn('[FacetChart] Invalid data:', facetData);
                chartDiv.innerHTML = '<div style="color: #b0b0d0; text-align: center; padding: 20px;">No data</div>';
                return;
            }
            const total = Object.values(facetData).reduce((a, b) => a + b, 0);
            if (total === 0) {
                chartDiv.innerHTML = '<div style="color: #b0b0d0; text-align: center; padding: 20px;">No data</div>';
                return;
            }
            
            const items = Object.entries(facetData)
                .sort((a, b) => b[1] - a[1])
                .map(([facet, count]) => {
                    const percentage = ((count / total) * 100).toFixed(1);
                    return `
                        <div style="margin-bottom: 10px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span style="color: #e0e0e0;">${escapeHtml(facet)}</span>
                                <span style="color: #b0b0d0;">${count} (${percentage}%)</span>
                            </div>
                            <div style="background: #1a1a2e; border-radius: 4px; height: 8px; overflow: hidden;">
                                <div style="background: #888888; height: 100%; width: ${percentage}%; transition: width 0.3s;"></div>
                            </div>
                        </div>
                    `;
                }).join('');
            
            chartDiv.innerHTML = items;
        }
        
        function updateElementTypeChart(typeData) {
            const chartDiv = document.getElementById('elementTypeChart');
            if (!chartDiv) {
                console.warn('[ElementTypeChart] Chart div not found');
                return;
            }
            if (!typeData || typeof typeData !== 'object') {
                console.warn('[ElementTypeChart] Invalid data:', typeData);
                chartDiv.innerHTML = '<div style="color: #b0b0d0; text-align: center; padding: 20px;">No data</div>';
                return;
            }
            const total = Object.values(typeData).reduce((a, b) => a + b, 0);
            if (total === 0) {
                chartDiv.innerHTML = '<div style="color: #b0b0d0; text-align: center; padding: 20px;">No data</div>';
                return;
            }
            
            const items = Object.entries(typeData)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([type, count]) => {
                    const percentage = ((count / total) * 100).toFixed(1);
                    return `
                        <div style="margin-bottom: 10px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span style="color: #e0e0e0;">${escapeHtml(type)}</span>
                                <span style="color: #b0b0d0;">${count}</span>
                            </div>
                            <div style="background: #1a1a2e; border-radius: 4px; height: 8px; overflow: hidden;">
                                <div style="background: #4caf50; height: 100%; width: ${percentage}%; transition: width 0.3s;"></div>
                            </div>
                        </div>
                    `;
                }).join('');
            
            chartDiv.innerHTML = items;
        }
        
        function updateRAGChart(ragData) {
            const chartDiv = document.getElementById('ragChart');
            if (!chartDiv) return;
            const total = Object.values(ragData).reduce((a, b) => a + b, 0);
            if (total === 0) {
                chartDiv.innerHTML = '<div style="color: #b0b0d0; text-align: center; padding: 20px;">No properties with RAG status</div>';
                return;
            }
            
            const colors = {
                'negative': '#ff6b6b',
                'warning': '#ffa500',
                'positive': '#4caf50',
                'none': '#808080'
            };
            
            const labels = {
                'negative': 'Negative',
                'warning': 'Warning',
                'positive': 'Positive',
                'none': 'None'
            };
            
            const items = Object.entries(ragData)
                .filter(([_, count]) => count > 0)
                .map(([rag, count]) => {
                    const percentage = ((count / total) * 100).toFixed(1);
                    return `
                        <div style="margin-bottom: 10px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span style="color: #e0e0e0;">${labels[rag]}</span>
                                <span style="color: #b0b0d0;">${count} (${percentage}%)</span>
                            </div>
                            <div style="background: #1a1a2e; border-radius: 4px; height: 8px; overflow: hidden;">
                                <div style="background: ${colors[rag]}; height: 100%; width: ${percentage}%; transition: width 0.3s;"></div>
                            </div>
                        </div>
                    `;
                }).join('');
            
            chartDiv.innerHTML = items || '<div style="color: #b0b0d0; text-align: center; padding: 20px;">No RAG data</div>';
        }

        // Handle form submission
        // Form submission removed - elements are now constants, cannot be added via form

        // CSV Import Functions
        function downloadCSVTemplate() {
            const csvContent = 'name,element,facet,enterprise,description\n"Example Capability","Capability","Architecture","Enterprise1","Example description"\n"Example Process","Process","Architecture","Enterprise1","Another example"';
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'elements_template.csv';
            a.click();
            window.URL.revokeObjectURL(url);
        }
        
        function parseCSV(text) {
            const lines = text.split('\n').filter(line => line.trim() !== '');
            if (!lines.length) return [];
            const headers = lines[0].split(',').map(h => h.trim());
            return lines.slice(1).map(line => {
                const values = [];
                let current = '';
                let inQuotes = false;
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') {
                        if (inQuotes && line[i + 1] === '"') {
                            current += '"';
                            i++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        values.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                values.push(current.trim());
                const record = {};
                headers.forEach((header, idx) => {
                    record[header] = values[idx] ? values[idx].replace(/^"|"$/g, '') : '';
                });
                return record;
            });
        }

        function renderDesignRulesSection(rules, violations) {
            const section = document.getElementById('designRulesSection');
            if (!section) return;
            
            const isDarkTheme = document.body.classList.contains('dark-theme');
            const textColor = isDarkTheme ? '#e0e0e0' : '#202020';
            const bgColor = isDarkTheme ? '#1e1e1e' : '#ffffff';
            const gridColor = isDarkTheme ? '#3e3e42' : '#e5e5e5';
            const cardBgColor = isDarkTheme ? '#252526' : '#fafafa';
            
            // Count violations by severity
            const warningCount = violations.filter(v => v.severity === 'warning').length;
            const negativeCount = violations.filter(v => v.severity === 'negative').length;
            const positiveCount = violations.filter(v => v.severity === 'positive').length;
            
            // Update summary cards next to the gauge (top-down layout)
            const summaryCardsContainer = document.getElementById('designRulesSummaryCards');
            if (summaryCardsContainer) {
                summaryCardsContainer.innerHTML = `
                    <div style="background: ${cardBgColor}; border: 1px solid ${gridColor}; border-radius: 4px; padding: 12px;">
                        <div style="display: flex; align-items: center; gap: 8px; width: 100%;">
                        <div style="font-size: 11px; color: ${textColor}; opacity: 0.8;">Active Rules</div>
                            <div style="font-size: 24px; font-weight: 700; color: #0078d4; text-align: right; margin-left: auto;">${rules.filter(r => r.active).length}</div>
                    </div>
                    </div>
                    <div style="background: ${cardBgColor}; border: 1px solid ${gridColor}; border-radius: 4px; padding: 12px;">
                        <div style="display: flex; align-items: center; gap: 8px; width: 100%;">
                        <div style="font-size: 11px; color: ${textColor}; opacity: 0.8;">Warnings</div>
                            <div style="font-size: 24px; font-weight: 700; color: #FFE400; text-align: right; margin-left: auto;">${warningCount}</div>
                    </div>
                    </div>
                    <div style="background: ${cardBgColor}; border: 1px solid ${gridColor}; border-radius: 4px; padding: 12px;">
                        <div style="display: flex; align-items: center; gap: 8px; width: 100%;">
                        <div style="font-size: 11px; color: ${textColor}; opacity: 0.8;">Negatives</div>
                            <div style="font-size: 24px; font-weight: 700; color: #FF5100; text-align: right; margin-left: auto;">${negativeCount}</div>
                    </div>
                    </div>
                    <div style="background: ${cardBgColor}; border: 1px solid ${gridColor}; border-radius: 4px; padding: 12px;">
                        <div style="display: flex; align-items: center; gap: 8px; width: 100%;">
                        <div style="font-size: 11px; color: ${textColor}; opacity: 0.8;">Positives</div>
                            <div style="font-size: 24px; font-weight: 700; color: #20ED00; text-align: right; margin-left: auto;">${positiveCount}</div>
                        </div>
                    </div>
                `;
            }
            
            let html = '';

            html += `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <h5 style="color: ${textColor}; font-size: 13px; font-weight: 600; margin: 0;">Design Rules</h5>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <button id="evaluateAllRulesBtn" onclick="evaluateAllDesignRules()" style="padding: 6px 12px; font-size: 12px; background: #2d2d30; border: 1px solid ${gridColor}; color: ${textColor}; border-radius: 4px; cursor: pointer;" onmouseover="this.style.background='#3a3a3f'" onmouseout="this.style.background='#2d2d30'">Evaluate All</button>
                        <button onclick="showDesignRuleConfigModal()" style="padding: 6px 12px; font-size: 12px; background: #3e3e42; border: 1px solid #3e3e42; color: #e0e0e0; border-radius: 4px; cursor: pointer;" onmouseover="this.style.background='#4e4e52'" onmouseout="this.style.background='#3e3e42'">+ Add Rule</button>
                    </div>
                </div>
            `;
            
            // Rules list
            if (rules.length === 0) {
                html += `<div style="text-align: center; padding: 20px; color: ${textColor}; opacity: 0.6;">No design rules configured. Click "Add Rule" to create one.</div>`;
            } else {
                html += `<div style="margin-bottom: 20px;"><h5 style="color: ${textColor}; font-size: 13px; font-weight: 600; margin: 0 0 12px 0;">Configured Rules</h5>`;
                html += '<div id="designRulesList" style="display: flex; flex-direction: column; gap: 8px;">';
                
                rules.forEach(rule => {
                    const ruleViolations = violations.filter(v => v.rule_id === rule.id);
                    const ruleWarningCount = ruleViolations.filter(v => v.severity === 'warning').length;
                    const ruleNegativeCount = ruleViolations.filter(v => v.severity === 'negative').length;
                    const rulePositiveCount = ruleViolations.filter(v => v.severity === 'positive').length;
                    
                    html += `
                        <div style="background: ${cardBgColor}; border: 1px solid ${gridColor}; border-radius: 4px; padding: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                                <div style="flex: 1;">
                                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                        <strong style="color: ${textColor}; font-size: 13px;">${escapeHtml(rule.name)}</strong>
                                        ${rule.active ? '<span style="background: #107c10; color: #ffffff; padding: 2px 6px; border-radius: 3px; font-size: 10px;">Active</span>' : '<span style="background: #808080; color: #ffffff; padding: 2px 6px; border-radius: 3px; font-size: 10px;">Inactive</span>'}
                                    </div>
                                    ${rule.description ? `<div style="color: ${textColor}; opacity: 0.8; font-size: 12px; margin-bottom: 4px;">${escapeHtml(rule.description)}</div>` : ''}
                                    <div style="color: ${textColor}; opacity: 0.7; font-size: 11px;">
                                        ${rule.subject_element_type} ${rule.relationship_type ? rule.relationship_type : ''} ${rule.target_element_type || ''}
                                    </div>
                                </div>
                            <div style="display: flex; gap: 6px;">
                                <button onclick="editDesignRule(${rule.id})" style="padding: 4px 8px; font-size: 11px; background: transparent; color: ${textColor}; border: 1px solid ${gridColor}; border-radius: 3px; cursor: pointer;">Edit</button>
                                <button onclick="deleteDesignRule(${rule.id})" style="padding: 4px 8px; font-size: 11px; background: transparent; color: #FF5100; border: 1px solid ${gridColor}; border-radius: 3px; cursor: pointer;">Delete</button>
                            </div>
                            </div>
                            ${ruleViolations.length > 0 ? `
                                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid ${gridColor}; font-size: 11px; color: ${textColor};">
                                    ${ruleWarningCount > 0 ? `<span style="color: #FFE400;">${ruleWarningCount} warning(s)</span>` : ''}
                                    ${ruleWarningCount > 0 && ruleNegativeCount > 0 ? ' | ' : ''}
                                    ${ruleNegativeCount > 0 ? `<span style="color: #FF5100;">${ruleNegativeCount} negative(s)</span>` : ''}
                                    ${(ruleWarningCount > 0 || ruleNegativeCount > 0) && rulePositiveCount > 0 ? ' | ' : ''}
                                    ${rulePositiveCount > 0 ? `<span style="color: #20ED00;">${rulePositiveCount} positive(s)</span>` : ''}
                                </div>
                            ` : ''}
                        </div>
                    `;
                });
                
                html += '</div></div>';
            }
            
            // Advice section (formerly Violations)
            if (violations.length > 0) {
                html += `<div><h5 style="color: ${textColor}; font-size: 13px; font-weight: 600; margin: 0 0 12px 0;">Advice</h5>`;
                html += '<div id="designViolationsList" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto;">';
                
                // Group violations by severity
                const warningViolations = violations.filter(v => v.severity === 'warning');
                const negativeViolations = violations.filter(v => v.severity === 'negative');
                
                if (warningViolations.length > 0) {
                    html += `<div style="margin-bottom: 12px;"><h6 style="color: #FFE400; font-size: 12px; font-weight: 600; margin: 0 0 8px 0;">Warnings (${warningViolations.length})</h6>`;
                    warningViolations.forEach(violation => {
                        html += `
                            <div style="background: ${cardBgColor}; border: 1px solid ${gridColor}; border-radius: 4px; padding: 8px; font-size: 12px;">
                                <div style="color: ${textColor};"><strong>${escapeHtml(violation.element_instance_name)}</strong> (${violation.element_type})</div>
                                <div style="color: ${textColor}; opacity: 0.7; font-size: 11px; margin-top: 4px;">
                                    Rule: ${escapeHtml(violation.rule_name)} | Count: ${violation.current_value} (threshold: ${violation.threshold_value}+)
                                </div>
                            </div>
                        `;
                    });
                    html += '</div>';
                }
                
                if (negativeViolations.length > 0) {
                    html += `<div><h6 style="color: #FF5100; font-size: 12px; font-weight: 600; margin: 0 0 8px 0;">Negatives (${negativeViolations.length})</h6>`;
                    negativeViolations.forEach(violation => {
                        html += `
                            <div style="background: ${cardBgColor}; border: 1px solid ${gridColor}; border-radius: 4px; padding: 8px; font-size: 12px;">
                                <div style="color: ${textColor};"><strong>${escapeHtml(violation.element_instance_name)}</strong> (${violation.element_type})</div>
                                <div style="color: ${textColor}; opacity: 0.7; font-size: 11px; margin-top: 4px;">
                                    Rule: ${escapeHtml(violation.rule_name)} | Count: ${violation.current_value} (threshold: ${violation.threshold_value}+)
                                </div>
                            </div>
                        `;
                    });
                    html += '</div>';
                }
                
                html += '</div></div>';
            }
            
            // Positive section (below Advice)
            const positiveViolations = violations.filter(v => v.severity === 'positive');
            if (positiveViolations.length > 0) {
                html += `<div style="margin-top: 20px;"><h5 style="color: #20ED00; font-size: 13px; font-weight: 600; margin: 0 0 12px 0;">Positive (${positiveViolations.length})</h5>`;
                html += '<div id="designPositivesList" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto;">';
                
                positiveViolations.forEach(violation => {
                    html += `
                        <div style="background: ${cardBgColor}; border: 1px solid ${gridColor}; border-radius: 4px; padding: 8px; font-size: 12px;">
                            <div style="color: ${textColor};"><strong>${escapeHtml(violation.element_instance_name)}</strong> (${violation.element_type})</div>
                            <div style="color: ${textColor}; opacity: 0.7; font-size: 11px; margin-top: 4px;">
                                Rule: ${escapeHtml(violation.rule_name)} | Count: ${violation.current_value} (threshold: ${violation.threshold_value}+)
                            </div>
                        </div>
                    `;
                });
                
                html += '</div></div>';
            }
            
            section.innerHTML = html;
        }
        
        function createRepositoryAdviceMeterChart(violations, rules = []) {
            const ctx = document.getElementById('repositoryAdviceMeterChart');
            if (!ctx) return;
            
            const isDarkTheme = document.body.classList.contains('dark-theme');
            const textColor = isDarkTheme ? '#e0e0e0' : '#202020';
            const bgColor = isDarkTheme ? '#1e1e1e' : '#ffffff';
            const gridColor = isDarkTheme ? '#3e3e42' : '#e5e5e5';
            const cardBgColor = isDarkTheme ? '#252526' : '#fafafa';
            
            // Count violations by severity
            const positiveCount = violations.filter(v => v.severity === 'positive').length;
            const warningCount = violations.filter(v => v.severity === 'warning').length;
            const negativeCount = violations.filter(v => v.severity === 'negative').length;
            const total = positiveCount + warningCount + negativeCount;
            const activeRulesCount = rules.filter(r => r.active).length;
            
            // Calculate score (0-100): Positive increases, Negative decreases, Warning neutral
            // Score = (positive * 100 - negative * 100) / max(total, 1) + 50, clamped to 0-100
            let score = 50; // Start at neutral (50)
            if (total > 0) {
                score = 50 + ((positiveCount * 50) - (negativeCount * 50)) / Math.max(total, 1);
                score = Math.max(0, Math.min(100, score)); // Clamp to 0-100
            }
            
            // Destroy existing chart if it exists
            if (window.analyticsCharts && window.analyticsCharts.repositoryAdviceMeter) {
                const chart = window.analyticsCharts.repositoryAdviceMeter;
                if (chart && typeof chart.destroy === 'function') {
                    try {
                        chart.destroy();
                    } catch (e) {
                        console.warn('Error destroying repository advice meter chart:', e);
                    }
                }
            }
            
            if (!window.analyticsCharts) {
                window.analyticsCharts = {};
            }
            
            // Draw gauge manually using canvas for full control
            // Zones: Red (0-33%), Yellow (33-66%), Green (66-100%) - left to right
            const drawGauge = () => {
                const canvas = ctx;
                const rect = canvas.getBoundingClientRect();
                const width = rect.width || 500;
                const containerHeight = rect.height || 220;
                
                // Reserve space for score text at the bottom (about 50px)
                const scoreTextHeight = 50;
                const gaugeHeight = containerHeight - scoreTextHeight;
                
                // Set canvas size (use device pixel ratio for crisp rendering)
                const dpr = window.devicePixelRatio || 1;
                canvas.width = width * dpr;
                canvas.height = containerHeight * dpr;
                const context = canvas.getContext('2d');
                context.scale(dpr, dpr);
                
                // Recalculate dimensions after scaling
                const centerX = width / 2;
                const centerY = gaugeHeight; // Bottom center for semi-circle (above score text area)
                const radius = (width / 2) * 0.85; // Use width for stretched semi-circle
                const lineWidth = radius * 0.3; // 30% of radius for gauge thickness
                const innerRadius = radius - lineWidth;
                
                // Clear canvas
                context.clearRect(0, 0, width, containerHeight);
                
                // Draw gauge zones: red cap  gradient  green cap
                const startAngle = -Math.PI; // Left (9 o'clock)
                const endAngle = 0; // Right (3 o'clock)
                const capFraction = 0.07; // small fixed caps at each end
                const totalAngle = Math.PI;
                const capAngle = totalAngle * capFraction;
                
                // Red cap (left)
                context.beginPath();
                context.arc(centerX, centerY, radius, startAngle, startAngle + capAngle, false);
                context.arc(centerX, centerY, innerRadius, startAngle + capAngle, startAngle, true);
                context.closePath();
                context.fillStyle = '#FF5100';
                context.fill();
                
                // Gradient middle
                context.beginPath();
                context.arc(centerX, centerY, radius, startAngle + capAngle, endAngle - capAngle, false);
                context.arc(centerX, centerY, innerRadius, endAngle - capAngle, startAngle + capAngle, true);
                context.closePath();
                const gradient = context.createLinearGradient(centerX - radius, 0, centerX + radius, 0);
                gradient.addColorStop(0, '#FF5100');
                gradient.addColorStop(0.5, '#FFE400');
                gradient.addColorStop(1, '#20ED00');
                context.fillStyle = gradient;
                context.fill();
                
                // Green cap (right)
                context.beginPath();
                context.arc(centerX, centerY, radius, endAngle - capAngle, endAngle, false);
                context.arc(centerX, centerY, innerRadius, endAngle, endAngle - capAngle, true);
                context.closePath();
                context.fillStyle = '#20ED00';
                context.fill();
                
                // Calculate needle angle: score 0 = left (-180), score 100 = right (0)
                const needleAngle = startAngle + (score / 100) * Math.PI;
                const needleLength = radius * 0.75;
                
                // Draw needle
                context.save();
                context.translate(centerX, centerY);
                context.rotate(needleAngle);
                context.beginPath();
                context.moveTo(0, 0);
                context.lineTo(needleLength, 0);
                context.lineWidth = 3;
                context.strokeStyle = textColor;
                context.lineCap = 'round';
                context.stroke();
                
                // Draw center circle (pivot)
                context.beginPath();
                context.arc(0, 0, 8, 0, 2 * Math.PI);
                context.fillStyle = textColor;
                context.fill();
                context.strokeStyle = bgColor;
                context.lineWidth = 2;
                context.stroke();
                context.restore();
                
                // Draw score text below gauge (within canvas bounds)
                context.fillStyle = textColor;
                context.font = 'bold 20px sans-serif';
                context.textAlign = 'center';
                context.textBaseline = 'top';
                const scoreY = gaugeHeight + 12; // Position score text in reserved area
                context.fillText(Math.round(score), centerX, scoreY);
                context.font = '12px sans-serif';
                context.fillText('Advice Score', centerX, scoreY + 24);
            
            // Indicate left-to-right meaning for the gauge scale
            context.font = '11px sans-serif';
            context.textAlign = 'left';
            context.fillText('0 = Poor', centerX - radius, scoreY + 24);
            context.textAlign = 'right';
            context.fillText('100 = Good', centerX + radius, scoreY + 24);
            };
            
            // Initial draw
            drawGauge();
            
            // Handle resize
            const resizeObserver = new ResizeObserver(() => {
                drawGauge();
            });
            resizeObserver.observe(ctx);
            
            // Store resize observer for cleanup
            if (!window.analyticsCharts.gaugeResizeObserver) {
                window.analyticsCharts.gaugeResizeObserver = resizeObserver;
            }
            
            // Update summary cards next to the gauge (top-down layout)
            const summaryCardsContainer = document.getElementById('designRulesSummaryCards');
            if (summaryCardsContainer) {
                summaryCardsContainer.innerHTML = `
                    <div style="background: ${cardBgColor}; border: 1px solid ${gridColor}; border-radius: 4px; padding: 8px; text-align: center;">
                        <div style="font-size: 18px; font-weight: 700; color: #0078d4; margin-bottom: 2px;">${activeRulesCount}</div>
                        <div style="font-size: 10px; color: ${textColor}; opacity: 0.8;">Active Rules</div>
                    </div>
                    <div style="background: ${cardBgColor}; border: 1px solid ${gridColor}; border-radius: 4px; padding: 8px; text-align: center;">
                        <div style="font-size: 18px; font-weight: 700; color: #FFE400; margin-bottom: 2px;">${warningCount}</div>
                        <div style="font-size: 10px; color: ${textColor}; opacity: 0.8;">Warnings</div>
                    </div>
                    <div style="background: ${cardBgColor}; border: 1px solid ${gridColor}; border-radius: 4px; padding: 8px; text-align: center;">
                        <div style="font-size: 18px; font-weight: 700; color: #FF5100; margin-bottom: 2px;">${negativeCount}</div>
                        <div style="font-size: 10px; color: ${textColor}; opacity: 0.8;">Negatives</div>
                    </div>
                    <div style="background: ${cardBgColor}; border: 1px solid ${gridColor}; border-radius: 4px; padding: 8px; text-align: center;">
                        <div style="font-size: 18px; font-weight: 700; color: #20ED00; margin-bottom: 2px;">${positiveCount}</div>
                        <div style="font-size: 10px; color: ${textColor}; opacity: 0.8;">Positives</div>
                    </div>
                `;
            }
            
            // Add legend directly underneath the chart
            const legendContainer = document.getElementById('gaugeLegendContainer');
            if (legendContainer) {
                legendContainer.innerHTML = `
                    <div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <div style="width: 12px; height: 12px; background: #FF5100; border-radius: 2px;"></div>
                            <span style="color: ${textColor}; font-size: 12px;">Negative (${negativeCount})</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <div style="width: 12px; height: 12px; background: #FFE400; border-radius: 2px;"></div>
                            <span style="color: ${textColor}; font-size: 12px;">Warning (${warningCount})</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <div style="width: 12px; height: 12px; background: #20ED00; border-radius: 2px;"></div>
                            <span style="color: ${textColor}; font-size: 12px;">Positive (${positiveCount})</span>
                        </div>
                    </div>
                `;
            }
        }
        
        async function showDesignRuleConfigModal(ruleId = null) {
            const isDarkTheme = document.body.classList.contains('dark-theme');
            const textColor = isDarkTheme ? '#e0e0e0' : '#202020';
            const bgColor = isDarkTheme ? '#2d2d30' : '#ffffff';
            const gridColor = isDarkTheme ? '#3e3e42' : '#e5e5e5';
            const inputBg = isDarkTheme ? '#1e1e1e' : '#ffffff';
            
            // Fetch element types and relationship types
            let elementTypes = [];
            let relationshipTypes = [];
            let existingRule = null;
            let records = [];
            
            try {
                const recordsResponse = await fetch('/api/records');
                if (recordsResponse.ok) {
                    records = await recordsResponse.json();
                }
                // Get unique element types (records + current canvas)
                    const uniqueTypes = new Set();
                    records.forEach(r => {
                    const elementType = r.element || r.element_type || r.element_type_name || r.element_name;
                    if (elementType) uniqueTypes.add(elementType);
                });
                if (Array.isArray(canvasState?.elements)) {
                    canvasState.elements.forEach(elem => {
                        const elementType = elem.element_type || elem.element || elem.element_type_name || elem.element_name;
                        if (elementType) uniqueTypes.add(elementType);
                    });
                }
                elementTypes = Array.from(uniqueTypes).sort();
                
                const relTypesResponse = await fetch('/api/relationship-types');
                if (relTypesResponse.ok) {
                    relationshipTypes = await relTypesResponse.json();
                }
                
                if (ruleId) {
                    const ruleResponse = await fetch(`/api/analytics/design-rules/${ruleId}`);
                    if (ruleResponse.ok) {
                        existingRule = await ruleResponse.json();
                    }
                }
            } catch (error) {
                console.error('Error loading data for rule modal:', error);
            }
            
            const modalHTML = `
                <div id="designRuleConfigModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10012; display: flex; align-items: center; justify-content: center;">
                    <div style="background: ${bgColor}; padding: 30px; border-radius: 8px; min-width: 700px; max-width: 900px; border: 1px solid ${gridColor}; box-shadow: 0 8px 32px rgba(0,0,0,0.5); max-height: 90vh; overflow-y: auto;">
                        <h3 style="color: ${textColor}; margin-bottom: 20px;">${ruleId ? 'Edit Design Rule' : 'Create Design Rule'}</h3>
                        <form id="designRuleForm" onsubmit="saveDesignRule(event, ${ruleId || 'null'})">
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; color: ${textColor}; margin-bottom: 5px; font-size: 13px;">Rule Name *</label>
                                <input type="text" id="ruleName" value="${existingRule ? escapeHtml(existingRule.name) : ''}" required 
                                       style="width: 100%; padding: 8px; border: 1px solid ${gridColor}; border-radius: 4px; background: ${inputBg}; color: ${textColor}; font-size: 13px;">
                            </div>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; color: ${textColor}; margin-bottom: 5px; font-size: 13px;">Description</label>
                                <textarea id="ruleDescription" rows="2"
                                       style="width: 100%; padding: 8px; border: 1px solid ${gridColor}; border-radius: 4px; background: ${inputBg}; color: ${textColor}; font-size: 13px; resize: vertical;">${existingRule ? escapeHtml(existingRule.description || '') : ''}</textarea>
                            </div>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; color: ${textColor}; margin-bottom: 5px; font-size: 13px;">Subject Element Type *</label>
                                <select id="subjectElementType" required
                                        style="width: 100%; padding: 8px; border: 1px solid ${gridColor}; border-radius: 4px; background: ${inputBg}; color: ${textColor}; font-size: 13px;">
                                    <option value="">Select Element Type</option>
                                    ${elementTypes.map(type => `<option value="${escapeHtml(type)}" ${existingRule && existingRule.subject_element_type === type ? 'selected' : ''}>${escapeHtml(type)}</option>`).join('')}
                                </select>
                            </div>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; color: ${textColor}; margin-bottom: 5px; font-size: 13px;">Relationship Direction</label>
                                <select id="ruleType"
                                        style="width: 100%; padding: 8px; border: 1px solid ${gridColor}; border-radius: 4px; background: ${inputBg}; color: ${textColor}; font-size: 13px;">
                                    <option value="relationship_count_outgoing" ${!existingRule || existingRule.rule_type === 'relationship_count' || existingRule.rule_type === 'relationship_count_outgoing' ? 'selected' : ''}>Subject is Source (outgoing)</option>
                                    <option value="relationship_count_incoming" ${existingRule && existingRule.rule_type === 'relationship_count_incoming' ? 'selected' : ''}>Subject is Target (incoming)</option>
                                </select>
                                <div style="color: ${textColor}; opacity: 0.7; font-size: 11px; margin-top: 4px;">Controls whether the subject is the source or target in the relationship</div>
                            </div>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; color: ${textColor}; margin-bottom: 5px; font-size: 13px;">Relationship Type</label>
                                <select id="relationshipType"
                                        style="width: 100%; padding: 8px; border: 1px solid ${gridColor}; border-radius: 4px; background: ${inputBg}; color: ${textColor}; font-size: 13px;">
                                    <option value="">Any Relationship Type</option>
                                    ${relationshipTypes.map(type => `<option value="${escapeHtml(type)}" ${existingRule && existingRule.relationship_type === type ? 'selected' : ''}>${escapeHtml(type)}</option>`).join('')}
                                </select>
                            </div>
                            
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; color: ${textColor}; margin-bottom: 5px; font-size: 13px;">Target Element Type</label>
                                <select id="targetElementType"
                                        style="width: 100%; padding: 8px; border: 1px solid ${gridColor}; border-radius: 4px; background: ${inputBg}; color: ${textColor}; font-size: 13px;">
                                    <option value="">Select Element Type</option>
                                    ${elementTypes.map(type => `<option value="${escapeHtml(type)}" ${existingRule && existingRule.target_element_type === type ? 'selected' : ''}>${escapeHtml(type)}</option>`).join('')}
                                </select>
                            </div>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; color: ${textColor}; margin-bottom: 5px; font-size: 13px;">Query Logic</label>
                                <div id="ruleConditionsContainer" style="display: flex; flex-direction: column; gap: 8px;"></div>
                                <div style="margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap;">
                                    <button type="button" onclick="addRuleConditionRow()" style="padding: 6px 10px; font-size: 12px; background: #3e3e42; color: #e0e0e0; border: 1px solid #3e3e42; border-radius: 4px; cursor: pointer;" onmouseover="this.style.background='#4e4e52'" onmouseout="this.style.background='#3e3e42'">+ Add Condition</button>
                                    <button type="button" onclick="addRuleConditionRow({ conjunction: 'where' })" style="padding: 6px 10px; font-size: 12px; background: #2f5f9a; color: #ffffff; border: 1px solid #2f5f9a; border-radius: 4px; cursor: pointer;" onmouseover="this.style.background='#3a6fb2'" onmouseout="this.style.background='#2f5f9a'">+ New Group</button>
                                </div>
                                <div style="color: ${textColor}; opacity: 0.7; font-size: 11px; margin-top: 6px;">Use Where/And/Or to build multi-line logic. Each group sets its own assignment.</div>
                            </div>
                            
                            <div style="margin-bottom: 20px;">
                                <label style="display: flex; align-items: center; color: ${textColor}; font-size: 13px; cursor: pointer;">
                                    <input type="checkbox" id="ruleActive" ${existingRule === null || existingRule.active ? 'checked' : ''} 
                                           style="margin-right: 8px; width: 16px; height: 16px; cursor: pointer;">
                                    Active
                                </label>
                            </div>
                            
                            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                                <button type="button" onclick="closeDesignRuleConfigModal()" 
                                        style="padding: 8px 16px; font-size: 13px; background: transparent; color: ${textColor}; border: 1px solid ${gridColor}; border-radius: 4px; cursor: pointer;">Cancel</button>
                                <button type="submit" 
                                        style="padding: 8px 16px; font-size: 13px; background: #0078d4; color: #ffffff; border: none; border-radius: 4px; cursor: pointer;">${ruleId ? 'Update' : 'Create'}</button>
                            </div>
                        </form>
                    </div>
                </div>
            `;
            
            // Remove existing modal if any
            const existingModal = document.getElementById('designRuleConfigModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            const elementTypeImages = {};
            if (Array.isArray(records)) {
                records.forEach(record => {
                    const elementType = record.element || record.element_type || record.element_type_name || record.element_name;
                    if (elementType && record.image_url && !elementTypeImages[elementType]) {
                        elementTypeImages[elementType] = record.image_url;
                    }
                });
            }
            if (Array.isArray(canvasState?.elements)) {
                canvasState.elements.forEach(elem => {
                    const elementType = elem.element_type || elem.element || elem.element_type_name || elem.element_name;
                    if (elementType && elem.image_url && !elementTypeImages[elementType]) {
                        elementTypeImages[elementType] = elem.image_url;
                    }
                });
            }
            window.designRuleModalData = { elementTypes, relationshipTypes, elementTypeImages };
            renderRuleConditions(existingRule && existingRule.conditions ? existingRule.conditions : []);

            const subjectSelect = document.getElementById('subjectElementType');
            if (subjectSelect) {
                subjectSelect.addEventListener('change', () => {
                    const subjectType = subjectSelect.value || 'Element';
                    document.querySelectorAll('.rule-condition-row').forEach(row => {
                        const leftLabel = row.querySelector('.condition-left-label');
                        const leftImage = row.querySelector('.condition-left-image');
                        if (leftLabel) leftLabel.textContent = subjectType || 'Element';
                        if (leftImage) {
                            leftImage.src = elementTypeImages[subjectType] || `/images/Shape-${subjectType || 'Unknown'}.svg`;
                        }
                    });
                });
            }
        }

        function renderRuleConditions(conditions) {
            const container = document.getElementById('ruleConditionsContainer');
            if (!container) return;
            container.innerHTML = '';
            if (!conditions || conditions.length === 0) {
                addRuleConditionRow();
                return;
            }
            conditions.forEach(cond => addRuleConditionRow(cond));
        }

        function addRuleConditionRow(condition = {}) {
            const container = document.getElementById('ruleConditionsContainer');
            if (!container || !window.designRuleModalData) return;
            const elementTypes = window.designRuleModalData.elementTypes || [];
            const relationshipTypes = window.designRuleModalData.relationshipTypes || [];
            const elementTypeImages = window.designRuleModalData.elementTypeImages || {};
            const defaultConjunction = container.children.length === 0 ? 'where' : 'and';
            const conj = (condition.conjunction || defaultConjunction).toLowerCase();
            const operator = (condition.operator || 'eq').toLowerCase();
            const leftCount = condition.left_count !== undefined && condition.left_count !== null ? condition.left_count : '';
            const rightCount = condition.right_count !== undefined && condition.right_count !== null
                ? condition.right_count
                : (condition.count !== undefined && condition.count !== null ? condition.count : '');
            const relType = condition.relationship_type || '';
            const relatedType = condition.related_element_type || '';
            const severity = (condition.severity || 'warning').toLowerCase();
            const propertyTarget = (condition.property_target || 'subject').toLowerCase();
            const textValue = condition.text_value || '';
            const subjectType = condition.subject_element_type || document.getElementById('subjectElementType')?.value || '';
            
            const row = document.createElement('div');
            row.className = 'rule-condition-row';
            row.style.cssText = 'display: grid; grid-template-columns: 70px 70px 180px 120px 70px 70px 180px 120px 90px 120px 24px; gap: 6px; align-items: center;';
            row.innerHTML = `
                <select class="condition-conjunction" style="padding: 6px; font-size: 11px;">
                    <option value="where" ${conj === 'where' ? 'selected' : ''}>Where</option>
                    <option value="and" ${conj === 'and' ? 'selected' : ''}>And</option>
                    <option value="or" ${conj === 'or' ? 'selected' : ''}>Or</option>
                </select>
                <input class="condition-left-count" type="number" min="0" value="${leftCount}" placeholder="#" style="padding: 6px; font-size: 11px;" />
                <div class="condition-left-element" style="display: flex; align-items: center; gap: 6px;">
                    <img class="condition-left-image" src="${escapeHtml(elementTypeImages[subjectType] || `/images/Shape-${subjectType || 'Unknown'}.svg`)}" onerror="this.src='/images/Shape-${subjectType || 'Unknown'}.svg'; this.onerror=null;" style="width: 20px; height: 20px; object-fit: contain; border-radius: 3px; background: #1e1e1e; border: 1px solid #3e3e42; padding: 2px;" />
                    <span class="condition-left-label" style="font-size: 11px; color: #e0e0e0;">${escapeHtml(subjectType || 'Element')}</span>
                </div>
                <select class="condition-relationship-type" style="padding: 6px; font-size: 11px;">
                    <option value="">Any Rel Type</option>
                    ${relationshipTypes.map(type => `<option value="${escapeHtml(type)}" ${relType === type ? 'selected' : ''}>${escapeHtml(type)}</option>`).join('')}
                </select>
                <select class="condition-operator" style="padding: 6px; font-size: 11px;">
                    <option value="eq" ${operator === 'eq' ? 'selected' : ''}>=</option>
                    <option value="gt" ${operator === 'gt' ? 'selected' : ''}>&gt;</option>
                    <option value="lt" ${operator === 'lt' ? 'selected' : ''}>&lt;</option>
                    <option value="gte" ${operator === 'gte' ? 'selected' : ''}>&ge;</option>
                    <option value="lte" ${operator === 'lte' ? 'selected' : ''}>&le;</option>
                    <option value="text" ${operator === 'text' ? 'selected' : ''}>Text</option>
                </select>
                <input class="condition-right-count" type="number" min="0" value="${rightCount}" placeholder="#" style="padding: 6px; font-size: 11px;" />
                <div style="display: flex; align-items: center; gap: 6px;">
                    <img class="condition-element-image" src="${escapeHtml(elementTypeImages[relatedType] || `/images/Shape-${relatedType || 'Unknown'}.svg`)}" onerror="this.src='/images/Shape-${relatedType || 'Unknown'}.svg'; this.onerror=null;" style="width: 20px; height: 20px; object-fit: contain; border-radius: 3px; background: #1e1e1e; border: 1px solid #3e3e42; padding: 2px;" />
                    <select class="condition-related-type" style="padding: 6px; font-size: 11px; flex: 1;">
                        <option value="">Element</option>
                        ${elementTypes.map(type => `<option value="${escapeHtml(type)}" ${relatedType === type ? 'selected' : ''} data-image="${escapeHtml(elementTypeImages[type] || '')}">${escapeHtml(type)}</option>`).join('')}
                    </select>
                </div>
                <input class="condition-text-value" type="text" value="${escapeHtml(textValue)}" placeholder="Text label" style="padding: 6px; font-size: 11px;" />
                <select class="condition-severity" style="padding: 6px; font-size: 11px;">
                    <option value="positive" ${severity === 'positive' ? 'selected' : ''}>Positive</option>
                    <option value="warning" ${severity === 'warning' ? 'selected' : ''}>Warning</option>
                    <option value="negative" ${severity === 'negative' ? 'selected' : ''}>Negative</option>
                </select>
                <select class="condition-target" style="padding: 6px; font-size: 11px;">
                    <option value="subject" ${propertyTarget === 'subject' ? 'selected' : ''}>Subject</option>
                    <option value="targets" ${propertyTarget === 'targets' ? 'selected' : ''}>Targets</option>
                    <option value="sources" ${propertyTarget === 'sources' ? 'selected' : ''}>Sources</option>
                </select>
                <button type="button" onclick="this.closest('.rule-condition-row').remove()" style="padding: 4px; background: transparent; border: 1px solid #3e3e42; color: #c0c0c0; border-radius: 4px; cursor: pointer;"></button>
            `;
            container.appendChild(row);

            const elementSelect = row.querySelector('.condition-related-type');
            const elementImage = row.querySelector('.condition-element-image');
            if (elementSelect && elementImage) {
                const updateImage = () => {
                    const selectedOption = elementSelect.options[elementSelect.selectedIndex];
                    const imageUrl = selectedOption?.getAttribute('data-image');
                    const fallbackType = elementSelect.value || 'Unknown';
                    elementImage.src = imageUrl || `/images/Shape-${fallbackType}.svg`;
                };
                elementSelect.addEventListener('change', updateImage);
                updateImage();
            }

            const operatorSelect = row.querySelector('.condition-operator');
            const rightCountInput = row.querySelector('.condition-right-count');
            const textValueInput = row.querySelector('.condition-text-value');
            if (operatorSelect && rightCountInput && textValueInput) {
                const toggleInputs = () => {
                    const isText = operatorSelect.value === 'text';
                    rightCountInput.style.display = isText ? 'none' : '';
                    textValueInput.style.display = isText ? '' : 'none';
                };
                operatorSelect.addEventListener('change', toggleInputs);
                toggleInputs();
            }
        }

        function serializeRuleConditions() {
            const rows = Array.from(document.querySelectorAll('.rule-condition-row'));
            if (!rows.length) return null;
            const ruleType = document.getElementById('ruleType')?.value || 'relationship_count_outgoing';
            const defaultDirection = ruleType === 'relationship_count_incoming' ? 'incoming' : 'outgoing';
            return rows.map(row => ({
                conjunction: row.querySelector('.condition-conjunction')?.value || 'where',
                direction: row.querySelector('.condition-direction')?.value || defaultDirection,
                operator: row.querySelector('.condition-operator')?.value || 'eq',
                left_count: row.querySelector('.condition-left-count')?.value !== '' ? parseInt(row.querySelector('.condition-left-count')?.value || '0', 10) : null,
                right_count: row.querySelector('.condition-right-count')?.value !== '' ? parseInt(row.querySelector('.condition-right-count')?.value || '0', 10) : null,
                text_value: row.querySelector('.condition-text-value')?.value || '',
                relationship_type: row.querySelector('.condition-relationship-type')?.value || null,
                related_element_type: row.querySelector('.condition-related-type')?.value || null,
                severity: row.querySelector('.condition-severity')?.value || 'warning',
                property_target: row.querySelector('.condition-target')?.value || 'subject'
            }));
        }
        
        function closeDesignRuleConfigModal() {
            const modal = document.getElementById('designRuleConfigModal');
            if (modal) {
                modal.remove();
            }
        }
        
        async function saveDesignRule(event, ruleId) {
            event.preventDefault();
            
            const ruleData = {
                name: document.getElementById('ruleName').value.trim(),
                description: document.getElementById('ruleDescription').value.trim(),
                rule_type: document.getElementById('ruleType').value || 'relationship_count_outgoing',
                subject_element_type: document.getElementById('subjectElementType').value,
                relationship_type: document.getElementById('relationshipType').value || null,
                target_element_type: document.getElementById('targetElementType').value || null,
                conditions: serializeRuleConditions(),
                active: document.getElementById('ruleActive').checked
            };
            
            if (!ruleData.name || !ruleData.subject_element_type) {
                alert('Please fill in all required fields');
                return;
            }
            
            try {
                const url = ruleId ? `/api/analytics/design-rules/${ruleId}` : '/api/analytics/design-rules';
                const method = ruleId ? 'PUT' : 'POST';
                
                const response = await fetch(url, {
                    method: method,
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(ruleData)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to save rule');
                }
                
                closeDesignRuleConfigModal();
                const previousRuleProps = getAllRuleGeneratedPropsFromCanvas();
                const previousElementProps = getAllCanvasOccurrencePropsFromCanvas();
                const previousViolations = await fetchDesignRuleViolations();
                // Always evaluate rules on save, even if no model is active
                try {
                    await fetch('/api/analytics/design-rules/evaluate-all', { method: 'POST' });
                } catch (e) {
                    console.warn('Error evaluating rules after save:', e);
                }
                // Refresh rule-generated properties on the active canvas model (if any)
                const changeSummary = await refreshRuleGeneratedProperties(previousRuleProps, { skipEvaluate: true });
                await new Promise(resolve => setTimeout(resolve, 250));
                const nextViolations = await fetchDesignRuleViolations();
                const violationSummary = summarizeViolationColorChanges(previousViolations, nextViolations);
                const elementPropSummary = summarizeElementPropertyColorChanges(previousElementProps, getAllCanvasOccurrencePropsFromCanvas());
                showEdglyChangeNotification(changeSummary, violationSummary, elementPropSummary);
                // Reload rules/violations so counts reflect current rules
                loadDesignRulesAndViolations();
            } catch (error) {
                alert('Error saving rule: ' + error.message);
            }
        }

        function getRuleGeneratedPropsFromModel(model) {
            return (model.property_instances || []).filter(
                prop => prop.source === 'rules_engine' || prop.rule_id !== null
            );
        }

        function getRuleGeneratedPropsFromCanvas() {
            return canvasState.propertyInstances.filter(
                prop => prop.source === 'rules_engine' || prop.rule_id !== null
            );
        }

        function getRuleGeneratedElementPropsFromModel(model) {
            const props = [];
            (model.elements || []).forEach(element => {
                (element.properties || []).forEach(prop => {
                    if (prop.is_rules_generated || prop.rule_id != null || prop.source === 'rules_engine') {
                        props.push({
                            element_instance_id: element.id,
                            property_id: prop.property_id || prop.id,
                            rule_id: prop.rule_id || null,
                            propertyname: prop.propertyname,
                            ragtype: prop.ragtype,
                            instance_name: prop.instance_name
                        });
                    }
                });
            });
            return props;
        }

        function getRuleGeneratedElementPropsFromCanvas() {
            const props = [];
            canvasState.elements.forEach(element => {
                (element.properties || []).forEach(prop => {
                    if (prop.is_rules_generated || prop.rule_id != null || prop.source === 'rules_engine') {
                        props.push({
                            element_instance_id: element.id,
                            property_id: prop.property_id || prop.id,
                            rule_id: prop.rule_id || null,
                            propertyname: prop.propertyname,
                            ragtype: prop.ragtype,
                            instance_name: prop.instance_name
                        });
                    }
                });
            });
            return props;
        }

        function getAllRuleGeneratedPropsFromCanvas() {
            return [
                ...getRuleGeneratedPropsFromCanvas(),
                ...getRuleGeneratedElementPropsFromCanvas()
            ];
        }

        function getAllElementPropsFromCanvas() {
            const props = [];
            canvasState.elements.forEach(element => {
                (element.properties || []).forEach(prop => {
                    props.push({
                        element_instance_id: element.id,
                        property_id: prop.property_id || prop.id,
                        propertyname: prop.propertyname,
                        ragtype: prop.ragtype,
                        instance_name: prop.instance_name
                    });
                });
            });
            return props;
        }

        function getAllCanvasOccurrencePropsFromCanvas() {
            const combined = [];
            canvasState.propertyInstances.forEach(prop => {
                combined.push({
                    element_instance_id: prop.element_instance_id,
                    property_id: prop.property_id || null,
                    propertyname: prop.propertyname || prop.instance_name || '',
                    ragtype: prop.ragtype,
                    instance_name: prop.instance_name
                });
            });
            combined.push(...getAllElementPropsFromCanvas());
            const unique = new Map();
            combined.forEach(prop => {
                const key = buildElementPropKey(prop);
                if (!unique.has(key)) {
                    unique.set(key, prop);
                }
            });
            return Array.from(unique.values());
        }

        function buildRulePropKey(prop) {
            return `${prop.element_instance_id}|${prop.property_id}|${prop.rule_id || ''}`;
        }

        function summarizeRuleGeneratedPropertyChanges(previousProps, nextProps) {
            const previousMap = new Map();
            previousProps.forEach(prop => previousMap.set(buildRulePropKey(prop), prop));
            const nextMap = new Map();
            nextProps.forEach(prop => nextMap.set(buildRulePropKey(prop), prop));

            const affectedElementIds = new Set();
            let changeCount = 0;

            nextMap.forEach((prop, key) => {
                const prev = previousMap.get(key);
                if (!prev) {
                    changeCount += 1;
                    affectedElementIds.add(prop.element_instance_id);
                    return;
                }
                if (prev.ragtype !== prop.ragtype || prev.propertyname !== prop.propertyname || prev.instance_name !== prop.instance_name) {
                    changeCount += 1;
                    affectedElementIds.add(prop.element_instance_id);
                }
            });

            previousMap.forEach((prop, key) => {
                if (!nextMap.has(key)) {
                    changeCount += 1;
                    affectedElementIds.add(prop.element_instance_id);
                }
            });

            const affectedNames = [];
            affectedElementIds.forEach(elementId => {
                const element = canvasState.elements.find(e => e.id === elementId);
                if (element && element.instance_name) {
                    affectedNames.push(element.instance_name);
                }
            });

            return {
                hasChanges: changeCount > 0,
                changeCount,
                affectedNames
            };
        }

        function buildElementPropKey(prop) {
            const idPart = prop.property_id || '';
            const namePart = prop.propertyname || prop.instance_name || '';
            return `${prop.element_instance_id}|${idPart}|${namePart}`;
        }

        function summarizeElementPropertyColorChanges(previousProps, nextProps) {
            const previousMap = new Map();
            previousProps.forEach(prop => previousMap.set(buildElementPropKey(prop), prop));
            const nextMap = new Map();
            nextProps.forEach(prop => nextMap.set(buildElementPropKey(prop), prop));

            const affectedNames = new Set();
            let changeCount = 0;
            let exampleChange = null;

            nextMap.forEach((prop, key) => {
                const prev = previousMap.get(key);
                if (!prev || prev.ragtype !== prop.ragtype) {
                    changeCount += 1;
                    if (prop.instance_name) {
                        affectedNames.add(prop.instance_name);
                    } else {
                        const element = canvasState.elements.find(e => e.id === prop.element_instance_id);
                        if (element && element.instance_name) {
                            affectedNames.add(element.instance_name);
                        }
                    }
                    if (!exampleChange) {
                        exampleChange = {
                            propertyname: prop.propertyname || 'Property',
                            from: (prev && prev.ragtype) ? prev.ragtype : 'Unrated',
                            to: prop.ragtype || 'Unrated',
                            elementName: prop.instance_name || (canvasState.elements.find(e => e.id === prop.element_instance_id)?.instance_name || 'element')
                        };
                    }
                }
            });

            previousMap.forEach((prop, key) => {
                if (!nextMap.has(key)) {
                    changeCount += 1;
                    if (prop.instance_name) {
                        affectedNames.add(prop.instance_name);
                    } else {
                        const element = canvasState.elements.find(e => e.id === prop.element_instance_id);
                        if (element && element.instance_name) {
                            affectedNames.add(element.instance_name);
                        }
                    }
                    if (!exampleChange) {
                        exampleChange = {
                            propertyname: prop.propertyname || 'Property',
                            from: prop.ragtype || 'Unrated',
                            to: 'Removed',
                            elementName: prop.instance_name || (canvasState.elements.find(e => e.id === prop.element_instance_id)?.instance_name || 'element')
                        };
                    }
                }
            });

            return {
                hasChanges: changeCount > 0,
                changeCount,
                affectedNames: Array.from(affectedNames),
                exampleChange
            };
        }

        function buildViolationKey(violation) {
            const elementKey = violation.element_instance_id || violation.element_instance_name || 'unknown-element';
            return `${elementKey}|${violation.rule_id || violation.rule_name || ''}`;
        }

        function summarizeViolationColorChanges(previousViolations, nextViolations) {
            const previousMap = new Map();
            previousViolations.forEach(v => previousMap.set(buildViolationKey(v), v.severity));
            const nextMap = new Map();
            nextViolations.forEach(v => nextMap.set(buildViolationKey(v), v.severity));

            const previousCounts = {
                positive: previousViolations.filter(v => v.severity === 'positive').length,
                warning: previousViolations.filter(v => v.severity === 'warning').length,
                negative: previousViolations.filter(v => v.severity === 'negative').length
            };
            const nextCounts = {
                positive: nextViolations.filter(v => v.severity === 'positive').length,
                warning: nextViolations.filter(v => v.severity === 'warning').length,
                negative: nextViolations.filter(v => v.severity === 'negative').length
            };

            const affectedNames = new Set();
            let changeCount = 0;

            nextViolations.forEach(v => {
                const key = buildViolationKey(v);
                const prevSeverity = previousMap.get(key);
                if (!prevSeverity || prevSeverity !== v.severity) {
                    changeCount += 1;
                    if (v.element_instance_name) {
                        affectedNames.add(v.element_instance_name);
                    }
                }
            });

            previousViolations.forEach(v => {
                const key = buildViolationKey(v);
                if (!nextMap.has(key)) {
                    changeCount += 1;
                    if (v.element_instance_name) {
                        affectedNames.add(v.element_instance_name);
                    }
                }
            });

            return {
                hasChanges: changeCount > 0,
                changeCount,
                affectedNames: Array.from(affectedNames),
                previousCounts,
                nextCounts
            };
        }

        function showEdglyChangeNotification(ruleSummary, violationSummary, elementPropSummary) {
            if (!edglyNotificationsEnabled) return;
            const hasRuleChanges = ruleSummary && ruleSummary.hasChanges;
            const hasViolationChanges = violationSummary && violationSummary.hasChanges;
            const hasElementPropChanges = elementPropSummary && elementPropSummary.hasChanges;

            if (!hasRuleChanges && !hasViolationChanges && !hasElementPropChanges) {
                // updateEdglyCommentaryBubble('EDGly debug: no rule, violation, or element property color changes detected.', true);
                return;
            }

            let messageParts = [];
            if (hasViolationChanges) {
                const namesSnippet = violationSummary.affectedNames.slice(0, 3).join(', ');
                const extraCount = Math.max(violationSummary.affectedNames.length - 3, 0);
                const suffix = extraCount > 0 ? ` +${extraCount} more` : '';
                const violationMessage = violationSummary.affectedNames.length > 0
                    ? `Hey heads up! Properties changed for ${violationSummary.affectedNames.length} element${violationSummary.affectedNames.length === 1 ? '' : 's'}: ${namesSnippet}${suffix}.`
                    : `Hey heads up! Some element properties just changed.`;
                messageParts.push(violationMessage);
            }

            if (hasElementPropChanges) {
                const example = elementPropSummary.exampleChange;
                if (example) {
                    const elementMessage = `Hey heads up! The ${example.propertyname} property on ${example.elementName} changed from ${example.from} to ${example.to}.`;
                    messageParts.push(elementMessage);
                } else {
                    const elementMessage = `Hey heads up! Some element properties just changed.`;
                    messageParts.push(elementMessage);
                }
            }

            if (hasRuleChanges) {
                const namesSnippet = ruleSummary.affectedNames.slice(0, 3).join(', ');
                const extraCount = Math.max(ruleSummary.affectedNames.length - 3, 0);
                const suffix = extraCount > 0 ? ` +${extraCount} more` : '';
                const ruleMessage = ruleSummary.affectedNames.length > 0
                    ? `Hey heads up! Properties changed for ${ruleSummary.affectedNames.length} element${ruleSummary.affectedNames.length === 1 ? '' : 's'}: ${namesSnippet}${suffix}.`
                    : `Hey heads up! Some element properties just changed.`;
                messageParts.push(ruleMessage);
            }

            // const debugParts = [];
            // if (violationSummary) {
            //     debugParts.push(`violations: ${violationSummary.changeCount} change${violationSummary.changeCount === 1 ? '' : 's'}`);
            //     debugParts.push(`sev ${violationSummary.previousCounts.positive}/${violationSummary.previousCounts.warning}/${violationSummary.previousCounts.negative} -> ${violationSummary.nextCounts.positive}/${violationSummary.nextCounts.warning}/${violationSummary.nextCounts.negative}`);
            // }
            // if (elementPropSummary) {
            //     debugParts.push(`element props: ${elementPropSummary.changeCount} change${elementPropSummary.changeCount === 1 ? '' : 's'}`);
            // }
            // if (ruleSummary) {
            //     debugParts.push(`rules: ${ruleSummary.changeCount} change${ruleSummary.changeCount === 1 ? '' : 's'}`);
            // }
            // const debugSuffix = debugParts.length > 0 ? ` [debug: ${debugParts.join(', ')}]` : '';
            const uniqueMessages = Array.from(new Set(messageParts));
            updateEdglyCommentaryBubble(uniqueMessages.join(' '), true);
            triggerEdglyAttention();
        }

        async function refreshRuleGeneratedProperties(previousRuleProps = null, options = {}) {
            if (!canvasState.currentModelId) return null;
            try {
                if (!options.skipEvaluate) {
                await fetch('/api/analytics/design-rules/evaluate-all', { method: 'POST' });
                }
                const response = await fetch(`/api/canvas/models/${canvasState.currentModelId}`);
                if (!response.ok) return null;
                const model = await response.json();
                const ruleProps = getRuleGeneratedPropsFromModel(model);
                const ruleElementProps = getRuleGeneratedElementPropsFromModel(model);

                // Remove existing rule-generated properties from canvas
                const existingRuleProps = canvasState.propertyInstances.filter(
                    prop => prop.source === 'rules_engine' || prop.rule_id !== null
                );
                existingRuleProps.forEach(prop => {
                    const propDiv = document.getElementById(`property-${prop.id}`);
                    if (propDiv) propDiv.remove();
                });
                canvasState.propertyInstances = canvasState.propertyInstances.filter(
                    prop => !(prop.source === 'rules_engine' || prop.rule_id !== null)
                );

                let maxId = canvasState.propertyInstances.reduce((max, prop) => Math.max(max, prop.id || 0), 0);
                const affectedElements = new Set();
                ruleProps.forEach(prop => {
                    const propInstance = {
                        id: prop.id,
                        property_id: prop.property_id,
                        element_instance_id: prop.element_instance_id,
                        instance_name: prop.instance_name,
                        x_position: prop.x_position,
                        y_position: prop.y_position,
                        width: prop.width,
                        height: prop.height,
                        propertyname: prop.propertyname,
                        ragtype: prop.ragtype,
                        image_url: prop.image_url,
                        source: prop.source,
                        rule_id: prop.rule_id,
                        isDropped: false
                    };
                    canvasState.propertyInstances.push(propInstance);
                    renderPropertyInstance(propInstance);
                    if (prop.id > maxId) {
                        maxId = prop.id;
                    }
                    affectedElements.add(prop.element_instance_id);
                });
                canvasState.nextPropertyInstanceId = Math.max(canvasState.nextPropertyInstanceId, maxId + 1);
                affectedElements.forEach(elementId => updatePropertyPositionsForElement(elementId));
                // Sync element instance properties from model to keep rule-generated properties aligned
                if (model.elements && model.elements.length > 0) {
                    model.elements.forEach(element => {
                        const canvasElement = canvasState.elements.find(e => e.id === element.id);
                        if (canvasElement) {
                            canvasElement.properties = element.properties || canvasElement.properties || [];
                        }
                    });
                }
                if (previousRuleProps) {
                    return summarizeRuleGeneratedPropertyChanges(previousRuleProps, [...ruleProps, ...ruleElementProps]);
                }
                return null;
            } catch (error) {
                console.error('Error refreshing rule-generated properties:', error);
                return null;
            }
        }

        async function fetchDesignRuleViolations() {
            try {
                const response = await fetch('/api/analytics/design-rules/violations');
                if (!response.ok) return [];
                return await response.json();
            } catch (error) {
                console.warn('EDGly debug: unable to fetch violations', error);
                return [];
            }
        }

        async function runEdglyRuleUpdateCheck(previousRuleProps = null, previousViolations = null, previousElementProps = null, options = {}) {
            if (!canvasState.currentModelId) return;
            const priorRuleProps = previousRuleProps || getAllRuleGeneratedPropsFromCanvas();
            const priorViolations = previousViolations || await fetchDesignRuleViolations();
            const priorElementProps = previousElementProps || getAllCanvasOccurrencePropsFromCanvas();

            let changeSummary = null;
            if (options.refreshProperties !== false) {
                changeSummary = await refreshRuleGeneratedProperties(priorRuleProps, { skipEvaluate: true });
                await new Promise(resolve => setTimeout(resolve, 250));
            } else {
                changeSummary = summarizeRuleGeneratedPropertyChanges(priorRuleProps, getAllRuleGeneratedPropsFromCanvas());
            }
            const nextViolations = await fetchDesignRuleViolations();
            const violationSummary = summarizeViolationColorChanges(priorViolations, nextViolations);
            const elementPropSummary = summarizeElementPropertyColorChanges(priorElementProps, getAllCanvasOccurrencePropsFromCanvas());
            showEdglyChangeNotification(changeSummary, violationSummary, elementPropSummary);
        }
        
        function editDesignRule(ruleId) {
            showDesignRuleConfigModal(ruleId);
        }
        
        async function deleteDesignRule(ruleId) {
            if (!confirm('Are you sure you want to delete this rule?')) return;
            
            try {
                const response = await fetch(`/api/analytics/design-rules/${ruleId}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to delete rule');
                }
                
                // Reload rules and violations
                loadDesignRulesAndViolations();
            } catch (error) {
                alert('Error deleting rule: ' + error.message);
            }
        }
        
        async function editRepositoryProperty(propertyname, ragtype, description, image_url) {
            // Create edit form modal
            const editFormHTML = `
                <div id="editPropertyModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10011; display: flex; align-items: center; justify-content: center;">
                    <div style="background: #2d2d30; padding: 30px; border-radius: 8px; min-width: 500px; max-width: 600px; border: 1px solid #3e3e42; box-shadow: 0 8px 32px rgba(0,0,0,0.5);">
                        <h3 style="color: #ffffff; margin-bottom: 20px;">Edit Property</h3>
                        <form id="editPropertyForm" onsubmit="saveRepositoryPropertyEdit(event)">
                            <input type="hidden" id="editOldPropertyname" value="${escapeHtml(propertyname)}">
                            <input type="hidden" id="editOldRagtype" value="${escapeHtml(ragtype || '')}">
                            <input type="hidden" id="editOldDescription" value="${escapeHtml(description || '')}">
                            <input type="hidden" id="editOldImageUrl" value="${escapeHtml(image_url || '')}">
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; color: #cccccc; margin-bottom: 5px; font-size: 13px;">Property Name *</label>
                                <input type="text" id="editPropertyname" value="${escapeHtml(propertyname)}" required 
                                       style="width: 100%; padding: 8px; border: 1px solid #3e3e42; border-radius: 4px; background: #1e1e1e; color: #e0e0e0; font-size: 13px;">
                            </div>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; color: #cccccc; margin-bottom: 5px; font-size: 13px;">RAG Type</label>
                                <select id="editRagtype" onchange="updateEditPropertyTagPreview()" 
                                        style="width: 100%; padding: 8px; border: 1px solid #3e3e42; border-radius: 4px; background: #1e1e1e; color: #e0e0e0; font-size: 13px;">
                                    <option value="">Select RAG Type</option>
                                    <option value="Negative" ${ragtype === 'Negative' ? 'selected' : ''}>Negative</option>
                                    <option value="Warning" ${ragtype === 'Warning' ? 'selected' : ''}>Warning</option>
                                    <option value="Positive" ${ragtype === 'Positive' ? 'selected' : ''}>Positive</option>
                                    <option value="Black" ${ragtype === 'Black' ? 'selected' : ''}>Black</option>
                                </select>
                                <div id="editRagTagPreview" style="margin-top: 8px; ${ragtype ? '' : 'display: none;'}">
                                    <img id="editRagTagPreviewImg" src="${ragtype ? `/images/Tag-${ragtype}.svg` : ''}" alt="RAG Tag" style="width: 64px; height: 64px; border-radius: 4px; object-fit: contain;">
                                </div>
                            </div>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; color: #cccccc; margin-bottom: 5px; font-size: 13px;">Description</label>
                                <textarea id="editDescription" rows="3" 
                                          style="width: 100%; padding: 8px; border: 1px solid #3e3e42; border-radius: 4px; background: #1e1e1e; color: #e0e0e0; font-size: 13px; resize: vertical;">${escapeHtml(description || '')}</textarea>
                            </div>
                            
                            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                                <button type="button" onclick="closeEditPropertyModal()" style="padding: 8px 16px; background: transparent; border: 1px solid #3e3e42; color: #cccccc; border-radius: 4px; cursor: pointer;">Cancel</button>
                                <button type="submit" style="padding: 8px 16px; background: #0078d4; color: #ffffff; border: none; border-radius: 4px; cursor: pointer;">Save Changes</button>
                            </div>
                        </form>
                    </div>
                </div>
            `;
            
            // Remove existing edit modal if any
            const existingModal = document.getElementById('editPropertyModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // Add edit modal to body
            document.body.insertAdjacentHTML('beforeend', editFormHTML);
            
            // Show preview if ragtype exists
            if (ragtype) {
                updateEditPropertyTagPreview();
            }
        }
        
        function updateEditPropertyTagPreview() {
            const ragType = document.getElementById('editRagtype')?.value;
            const previewDiv = document.getElementById('editRagTagPreview');
            const previewImg = document.getElementById('editRagTagPreviewImg');
            
            if (!previewDiv || !previewImg) return;
            
            if (ragType) {
                const tagImage = `/images/Tag-${ragType}.svg`;
                previewImg.src = tagImage;
                previewDiv.style.display = 'block';
            } else {
                previewDiv.style.display = 'none';
            }
        }
        
        function closeEditPropertyModal() {
            const modal = document.getElementById('editPropertyModal');
            if (modal) {
                modal.remove();
            }
        }
        
        async function saveRepositoryPropertyEdit(event) {
            event.preventDefault();
            
            const oldPropertyname = document.getElementById('editOldPropertyname')?.value;
            const oldRagtype = document.getElementById('editOldRagtype')?.value || '';
            const oldDescription = document.getElementById('editOldDescription')?.value || '';
            const oldImageUrl = document.getElementById('editOldImageUrl')?.value || '';
            
            const newPropertyname = document.getElementById('editPropertyname')?.value.trim();
            const newRagtype = document.getElementById('editRagtype')?.value || '';
            const newDescription = document.getElementById('editDescription')?.value.trim() || '';
            
            if (!newPropertyname) {
                alert('Please enter a property name');
                return;
            }
            
            try {
                const response = await fetch('/api/properties', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        old_propertyname: oldPropertyname,
                        old_ragtype: oldRagtype,
                        old_description: oldDescription,
                        old_image_url: oldImageUrl,
                        propertyname: newPropertyname,
                        ragtype: newRagtype,
                        description: newDescription
                    })
                });
                
                const result = await response.json();
                
                if (!response.ok) {
                    throw new Error(result.error || 'Failed to update property');
                }
                
                // Close modal
                closeEditPropertyModal();
                
                // Refresh the properties list
                loadRepositoryAvailableProperties();
                
                alert(`Property updated successfully. ${result.updated_count || 0} record(s) updated.`);
            } catch (error) {
                console.error('Error updating property:', error);
                alert('Error updating property: ' + error.message);
            }
        }
        
        async function deleteRepositoryProperty(propertyname, ragtype, description, image_url) {
            if (!propertyname) {
                alert('Property name is required');
                return;
            }
            
            // Confirm deletion
            const confirmMessage = `Are you sure you want to delete the property "${propertyname}"?\n\nThis will remove it from being available to add to new Element Instances, but will keep any existing uses on the canvas.`;
            if (!confirm(confirmMessage)) {
                return;
            }
            
            try {
                const response = await fetch('/api/properties', {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        propertyname: propertyname,
                        ragtype: ragtype || '',
                        description: description || '',
                        image_url: image_url || ''
                    })
                });
                
                const result = await response.json();
                
                if (!response.ok) {
                    if (response.status === 409 && result.in_use) {
                        alert(`Cannot delete property: ${result.error}\n\nHistorical uses are preserved.`);
                    } else {
                        throw new Error(result.error || 'Failed to delete property');
                    }
                    return;
                }
                
                // Refresh the properties list
                loadRepositoryAvailableProperties();
                
                alert(`Property deleted successfully. ${result.deleted_count || 0} record(s) removed.\n\nHistorical uses on the canvas are preserved.`);
            } catch (error) {
                console.error('Error deleting property:', error);
                alert('Error deleting property: ' + error.message);
            }
        }
        
        async function loadRepositoryRecords() {
            try {
                const recordsList = document.getElementById('repositoryModalRecordsList');
                if (recordsList) {
                    recordsList.innerHTML = '<div class="empty-state">Loading element types...</div>';
                }
                
                // Fetch element types only (no instances yet)
                const elementTypesResponse = await fetch('/api/records');
                if (!elementTypesResponse.ok) throw new Error('Failed to load element types');
                const elementTypes = await elementTypesResponse.json();
                
                // Store element types for lazy loading
                window.repositoryElementTypes = elementTypes;
                
                // Render element types only (without instances)
                renderRepositoryModalElementTypes(elementTypes);
            } catch (error) {
                const recordsList = document.getElementById('repositoryModalRecordsList');
                if (recordsList) {
                    recordsList.innerHTML = `<div class="empty-state">Error loading element types: ${error.message}</div>`;
                }
            }
        }

        async function loadRepositoryModels() {
            const container = document.getElementById('repositoryModelsContent');
            if (!container) return;
            container.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <h4 style="margin: 0; color: #ffffff; font-size: 14px;">Saved Models</h4>
                    <button class="refresh-btn" onclick="loadRepositoryModels()" style="padding: 6px 12px; font-size: 12px;">Refresh</button>
                </div>
                <div class="empty-state">Loading models...</div>
            `;
            try {
                const response = await fetch('/api/canvas/models');
                if (!response.ok) throw new Error('Failed to load models');
                const models = await response.json();
                if (!models || models.length === 0) {
                    container.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <h4 style="margin: 0; color: #ffffff; font-size: 14px;">Saved Models</h4>
                            <button class="refresh-btn" onclick="loadRepositoryModels()" style="padding: 6px 12px; font-size: 12px;">Refresh</button>
                        </div>
                        <div class="empty-state">No saved models found.</div>
                    `;
                    return;
                }

                const listHtml = models.map(model => {
                    const updated = model.updated_at ? new Date(model.updated_at).toLocaleString() : 'Unknown';
                    const description = model.description ? escapeHtml(model.description) : 'No description';
                    const thumbnail = getStoredModelThumbnail(model.id);
                    return `
                        <div style="display: flex; gap: 12px; padding: 12px; background: #1e1e1e; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; margin-bottom: 10px; align-items: center;">
                            <div style="width: 88px; height: 64px; background: #2d2d44; border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; display: flex; align-items: center; justify-content: center; overflow: hidden;">
                                <img src="${thumbnail || '/images/diagram-modeller.png'}" alt="Model thumbnail" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.style.display='none';">
                            </div>
                            <div style="flex: 1; min-width: 0;">
                                <div style="color: #ffffff; font-size: 14px; font-weight: 600; margin-bottom: 4px;">${escapeHtml(model.name || 'Untitled Model')}</div>
                                <div style="color: #b0b0d0; font-size: 12px; margin-bottom: 6px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${description}</div>
                                <div style="color: #808090; font-size: 11px;">Updated: ${updated}</div>
                            </div>
                            <div style="display: flex; gap: 6px; align-items: center;">
                                <button class="refresh-btn" onclick="openRepositoryModel(${model.id})" style="padding: 6px 10px; font-size: 11px;">Open</button>
                                <button class="refresh-btn" onclick="editRepositoryModel(${model.id})" style="padding: 6px 10px; font-size: 11px;">Edit</button>
                                <button class="refresh-btn" onclick="deleteRepositoryModel(${model.id})" style="padding: 6px 10px; font-size: 11px; color: #ff6b6b; border-color: rgba(255,107,107,0.4);">Delete</button>
                            </div>
                        </div>
                    `;
                }).join('');

                container.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <h4 style="margin: 0; color: #ffffff; font-size: 14px;">Saved Models</h4>
                        <button class="refresh-btn" onclick="loadRepositoryModels()" style="padding: 6px 12px; font-size: 12px;">Refresh</button>
                    </div>
                    ${listHtml}
                `;
            } catch (error) {
                container.innerHTML = `<div class="empty-state">Error loading models: ${error.message}</div>`;
            }
        }

        async function openRepositoryModel(modelId) {
            if (!modelId) return;
            toggleRepositoryModal();
            await loadCanvasModel(modelId);
        }

        async function editRepositoryModel(modelId) {
            if (!modelId) return;
            toggleRepositoryModal();
            await loadCanvasModel(modelId);
            saveCanvasModel();
        }

        async function deleteRepositoryModel(modelId) {
            if (!modelId) return;
            if (!confirm('Are you sure you want to delete this model?')) return;
            try {
                const response = await fetch(`/api/canvas/models/${modelId}`, { method: 'DELETE' });
                if (!response.ok) {
                    const error = await response.json().catch(() => ({ error: 'Unknown error' }));
                    throw new Error(error.error || 'Failed to delete model');
                }
                loadRepositoryModels();
            } catch (error) {
                alert(`Error deleting model: ${error.message}`);
            }
        }
        
        async function loadRepositoryElementTypeInstances(typeId, typeName) {
            try {
                const instancesResponse = await fetch(`/api/canvas/element-instances/by-type/${typeId}`);
                if (!instancesResponse.ok) {
                    console.error(`Failed to load instances for ${typeName}`);
                    return [];
                }
                
                const instances = await instancesResponse.json();
                
                // Group unique instances by name and count occurrences
                const uniqueInstances = {};
                instances.forEach(inst => {
                    const key = inst.instance_name;
                    if (!uniqueInstances[key]) {
                        uniqueInstances[key] = {
                            instance_name: inst.instance_name,
                            element_type_id: inst.element_type_id,
                            element_type: inst.element_type || typeName,
                            description: inst.description || '',
                            properties: [],
                            occurrenceCount: 0,
                            models: []
                        };
                    }
                    uniqueInstances[key].occurrenceCount++;
                    if (inst.model_name && !uniqueInstances[key].models.includes(inst.model_name)) {
                        uniqueInstances[key].models.push(inst.model_name);
                    }
                    // Use description from first occurrence if not already set
                    if (!uniqueInstances[key].description && inst.description) {
                        uniqueInstances[key].description = inst.description;
                    }
                    if (inst.properties && inst.properties.length > 0) {
                        inst.properties.forEach(prop => {
                            if (!uniqueInstances[key].properties.some(existing => existing.property_id === prop.property_id)) {
                                uniqueInstances[key].properties.push(prop);
                            }
                        });
                    }
                });
                
                return Object.values(uniqueInstances);
            } catch (err) {
                console.error(`Error loading instances for type ${typeName}:`, err);
                return [];
            }
        }
        
        function renderRepositoryModalElementTypes(elementTypes) {
            const recordsList = document.getElementById('repositoryModalRecordsList');
            if (!recordsList) return;
            
            if (!elementTypes || elementTypes.length === 0) {
                recordsList.innerHTML = '<div class="empty-state">No element types found.</div>';
                return;
            }
            
            const sortedTypes = elementTypes.sort((a, b) => (a.element || '').localeCompare(b.element || ''));
            
            recordsList.innerHTML = sortedTypes.map(elementType => {
                const typeId = `repository-modal-element-type-${elementType.id}`;
                const typeName = elementType.element || 'Unknown';
                
                return `
                    <div class="element-type-group" style="margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; background: rgba(255,255,255,0.02);">
                        <div class="element-type-header" 
                             onclick="toggleRepositoryModalElementType('${typeId}', ${elementType.id}, '${escapeHtml(typeName)}')"
                             style="display: flex; align-items: center; gap: 12px; padding: 12px 15px; cursor: pointer; user-select: none; transition: background 0.2s;"
                             onmouseover="this.style.background='rgba(255,255,255,0.05)'"
                             onmouseout="this.style.background='transparent'">
                            <span class="expand-icon" id="repository-modal-icon-${typeId}" style="font-size: 12px; color: #808080; transition: transform 0.2s;"></span>
                            ${elementType.image_url ? `
                            <img src="${escapeHtml(elementType.image_url)}" alt="${escapeHtml(typeName)}" style="width: 32px; height: 32px; object-fit: contain;" />
                            ` : ''}
                            <div style="flex: 1;">
                                <div style="font-size: 16px; font-weight: 600; color: #ffffff;">
                                    ${escapeHtml(typeName)}
                                </div>
                                <div style="font-size: 11px; color: #888;">
                                    Click to load instances
                                </div>
                            </div>
                        </div>
                        <div class="element-type-instances" id="${typeId}" style="display: none; padding: 8px 0;">
                            <div style="padding: 20px; text-align: center; color: #888; font-size: 12px;">Loading instances...</div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function renderRepositoryModalInstances(typeId, instances) {
            const instancesDiv = document.getElementById(typeId);
            if (!instancesDiv) return;
            
            if (!instances || instances.length === 0) {
                instancesDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: #888; font-size: 12px;">No instances found</div>';
                return;
            }
            
            const instancesHtml = instances.map(instance => {
                const propertiesHtml = instance.properties && instance.properties.length > 0
                    ? `<div style="margin-top: 8px; padding-left: 20px;">
                        <div style="font-size: 11px; color: #888; margin-bottom: 4px;">Properties:</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                            ${instance.properties.map(prop => {
                                const tagImage = prop.image_url || `/images/Tag-${prop.ragtype || 'Green'}.svg`;
                                const gearIcon = prop.source === 'rules_engine'
                                    ? '<span style="display: inline-flex; align-items: center; justify-content: center; width: 14px; height: 14px; background: #ffffff; color: #000000; border-radius: 50%; font-size: 11px; box-shadow: 0 0 2px rgba(0,0,0,0.4);" title="Rules Engine">&#9881;</span>'
                                    : '';
                                return `
                                    <div style="display: flex; align-items: center; gap: 4px; padding: 2px 6px; background: rgba(255,255,255,0.1); border-radius: 4px;">
                                        <img src="${escapeHtml(tagImage)}" alt="${escapeHtml(prop.propertyname || 'Property')}" style="width: 12px; height: 12px; object-fit: contain;">
                                        <span style="font-size: 10px; color: #b0b0d0;">${escapeHtml(prop.propertyname || prop.instance_name || 'Property')}</span>
                                        ${gearIcon}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                       </div>`
                    : '<div style="margin-top: 8px; padding-left: 20px; font-size: 11px; color: #666;">No properties</div>';
                
                return `
                    <div class="instance-item" style="padding: 10px 15px; border-left: 2px solid rgba(255,255,255,0.1); margin-left: 20px; margin-top: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                                <div style="font-size: 14px; font-weight: 500; color: #ffffff; margin-bottom: 4px;">
                                    ${escapeHtml(instance.instance_name || 'Unnamed')}
                                </div>
                                <div style="font-size: 11px; color: #888;">
                                    Occurrences: <span style="color: #667eea; font-weight: 600;">${instance.occurrenceCount || 0}</span> 
                                    ${instance.models && instance.models.length > 0 
                                        ? `(${instance.models.slice(0, 3).map(m => escapeHtml(m)).join(', ')}${instance.models.length > 3 ? '...' : ''})`
                                        : ''}
                                </div>
                                ${instance.description ? `
                                <div style="font-size: 11px; color: #888; margin-top: 6px; font-style: italic; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.05);">
                                    ${escapeHtml(instance.description)}
                                </div>
                                ` : ''}
                                ${propertiesHtml}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            instancesDiv.innerHTML = instancesHtml;
        }
        
        function renderRepositoryModalRecordsGroupedByType(instancesByType) {
            const recordsList = document.getElementById('repositoryModalRecordsList');
            if (!recordsList) return;
            
            if (!instancesByType || Object.keys(instancesByType).length === 0) {
                recordsList.innerHTML = '<div class="empty-state">No element instances found.</div>';
                return;
            }
            
            const sortedTypes = Object.keys(instancesByType).sort();
            let totalInstances = 0;
            
            recordsList.innerHTML = sortedTypes.map(typeName => {
                const typeData = instancesByType[typeName];
                const typeId = `repository-modal-element-type-${typeData.element_type_id}`;
                totalInstances += typeData.instances.length;
                
                const instancesHtml = typeData.instances.map(instance => {
                    const propertiesHtml = instance.properties && instance.properties.length > 0
                        ? `<div style="margin-top: 8px; padding-left: 20px;">
                            <div style="font-size: 11px; color: #888; margin-bottom: 4px;">Properties:</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                ${instance.properties.map(prop => {
                                    const tagImage = prop.image_url || `/images/Tag-${prop.ragtype || 'Green'}.svg`;
                                    return `
                                        <div style="display: flex; align-items: center; gap: 4px; padding: 2px 6px; background: rgba(255,255,255,0.1); border-radius: 4px;">
                                            <img src="${escapeHtml(tagImage)}" alt="${escapeHtml(prop.propertyname || 'Property')}" style="width: 12px; height: 12px; object-fit: contain;">
                                            <span style="font-size: 10px; color: #b0b0d0;">${escapeHtml(prop.propertyname || prop.instance_name || 'Property')}</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                           </div>`
                        : '<div style="margin-top: 8px; padding-left: 20px; font-size: 11px; color: #666;">No properties</div>';
                    
                    return `
                        <div class="instance-item" style="padding: 10px 15px; border-left: 2px solid rgba(255,255,255,0.1); margin-left: 20px; margin-top: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div style="flex: 1;">
                                    <div style="font-size: 14px; font-weight: 500; color: #ffffff; margin-bottom: 4px;">
                                        ${escapeHtml(instance.instance_name || 'Unnamed')}
                                    </div>
                                    <div style="font-size: 11px; color: #888;">
                                        Occurrences: <span style="color: #667eea; font-weight: 600;">${instance.occurrenceCount || 0}</span> 
                                        ${instance.models && instance.models.length > 0 
                                            ? `(${instance.models.slice(0, 3).map(m => escapeHtml(m)).join(', ')}${instance.models.length > 3 ? '...' : ''})`
                                            : ''}
                                    </div>
                                    ${instance.description ? `
                                    <div style="font-size: 11px; color: #888; margin-top: 6px; font-style: italic; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.05);">
                                        ${escapeHtml(instance.description)}
                                    </div>
                                    ` : ''}
                                    ${propertiesHtml}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
                return `
                    <div class="element-type-group" style="margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; background: rgba(255,255,255,0.02);">
                        <div class="element-type-header" 
                             onclick="toggleRepositoryModalElementType('${typeId}')"
                             style="display: flex; align-items: center; gap: 12px; padding: 12px 15px; cursor: pointer; user-select: none; transition: background 0.2s;"
                             onmouseover="this.style.background='rgba(255,255,255,0.05)'"
                             onmouseout="this.style.background='transparent'">
                            <span class="expand-icon" id="repository-modal-icon-${typeId}" style="font-size: 12px; color: #808080; transition: transform 0.2s;"></span>
                            ${typeData.image_url ? `
                            <img src="${escapeHtml(typeData.image_url)}" alt="${escapeHtml(typeName)}" style="width: 32px; height: 32px; object-fit: contain;" />
                            ` : ''}
                            <div style="flex: 1;">
                                <div style="font-size: 16px; font-weight: 600; color: #ffffff;">
                                    ${escapeHtml(typeName)}
                                </div>
                                <div style="font-size: 11px; color: #888;">
                                    ${typeData.instances.length} instance${typeData.instances.length !== 1 ? 's' : ''}
                                </div>
                            </div>
                        </div>
                        <div class="element-type-instances" id="${typeId}" style="display: none; padding: 8px 0;">
                            ${instancesHtml}
                        </div>
                    </div>
                `;
            }).join('');
            
            updateRepositoryModalFilterCount(totalInstances);
        }
        
        async function toggleRepositoryModalElementType(typeId, elementTypeId, typeName) {
            const instancesDiv = document.getElementById(typeId);
            const icon = document.getElementById(`repository-modal-icon-${typeId}`);
            
            if (!instancesDiv || !icon) return;
            
            if (instancesDiv.style.display === 'none') {
                // Expand - load instances if not already loaded
                instancesDiv.style.display = 'block';
                icon.style.transform = 'rotate(90deg)';
                
                // Check if instances are already loaded
                const existingInstances = instancesDiv.querySelectorAll('.instance-item');
                if (existingInstances.length === 0 || instancesDiv.textContent.includes('Loading instances')) {
                    // Load instances
                    const instances = await loadRepositoryElementTypeInstances(elementTypeId, typeName);
                    renderRepositoryModalInstances(typeId, instances);
                }
            } else {
                // Collapse
                instancesDiv.style.display = 'none';
                icon.style.transform = 'rotate(0deg)';
            }
        }
        
// Load available properties for selection
        async function loadAvailableProperties() {
            try {
                const response = await fetch('/api/properties');
                if (!response.ok) {
                    throw new Error('Failed to load properties');
                }
                
                const properties = await response.json();
                const propertiesList = document.getElementById('propertiesCheckboxList');
                
                if (properties.length === 0) {
                    propertiesList.innerHTML = '<div class="empty-state" style="padding: 10px; text-align: center; color: #888;">No properties available. Create properties for existing elements first.</div>';
                    return;
                }
                
                propertiesList.innerHTML = properties.map(prop => {
                    // Get tag image based on RAG type
                    const tagImage = getTagImageFromRAG(prop.ragtype) || prop.image_url;
                    const propData = JSON.stringify({
                        ragtype: prop.ragtype,
                        propertyname: prop.propertyname,
                        description: prop.description,
                        image_url: tagImage || prop.image_url
                    });
                    const ragTypeBadge = prop.ragtype ? `<span style="background: #404060; color: #e0e0e0; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 8px;">${escapeHtml(prop.ragtype)}</span>` : '';
                    const usageInfo = prop.usage_count > 1 ? `<span style="color: #888; font-size: 11px; margin-left: 8px;">(used ${prop.usage_count} times)</span>` : '';
                    return `
                        <label style="display: flex; align-items: center; padding: 8px; background: #2d2d44; border-radius: 4px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#353550'" onmouseout="this.style.background='#2d2d44'">
                            <input type="checkbox" value='${escapeHtml(propData)}' style="margin-right: 10px; cursor: pointer;">
                            ${tagImage ? `<img src="${escapeHtml(tagImage)}" alt="RAG Tag" style="width: 64px; height: 64px; border-radius: 4px; margin-right: 10px; object-fit: contain;">` : ''}
                            <div style="flex: 1;">
                                <div style="color: #e0e0e0; font-weight: 500; font-size: 13px;">
                                    ${escapeHtml(prop.propertyname || 'Unnamed Property')}
                                    ${ragTypeBadge}
                                    ${usageInfo}
                                </div>
                                ${prop.description ? `<div style="color: #b0b0d0; font-size: 11px; margin-top: 4px;">${escapeHtml(prop.description.substring(0, 100))}${prop.description.length > 100 ? '...' : ''}</div>` : ''}
                            </div>
                        </label>
                    `;
                }).join('');
            } catch (error) {
                document.getElementById('propertiesCheckboxList').innerHTML = 
                    `<div class="empty-state" style="padding: 10px; text-align: center; color: #f44336;">Error loading properties: ${error.message}</div>`;
            }
        }

        // Update relationship dropdowns with current records, filtered by enterprise if selected

        // Delete element instance (removed - instances should be deleted from canvas models)
        async function deleteRecord(id) {
            // Element instances are managed through canvas models, not directly deletable here
            alert('Element instances are managed through the Modeling Canvas. Please delete instances from the canvas model.');
        }

        // Show success/error messages
        function showMessage(message, type) {
            const successMsg = document.getElementById('successMessage');
            const errorMsg = document.getElementById('errorMessage');
            
            if (type === 'success') {
                successMsg.textContent = message;
                successMsg.style.display = 'block';
                errorMsg.style.display = 'none';
                setTimeout(() => {
                    successMsg.style.display = 'none';
                }, 3000);
            } else {
                errorMsg.textContent = message;
                errorMsg.style.display = 'block';
                successMsg.style.display = 'none';
                setTimeout(() => {
                    errorMsg.style.display = 'none';
                }, 5000);
            }
        }

        // Relationship form removed - relationships are now defined in database only
        // Removed relationship form submission handler and all related functions

        // Helper function to display PlantUML diagram in modal
        function displayPlantUMLDiagram(plantumlCode, encoded, elementsCount, relationshipsCount, title = 'PlantUML Diagram', elementNames = [], enterpriseFilter = null, elementIds = [], diagramType = 'all', diagramId = null, includeRelated = null) {
            // Store code for copying
            window.plantumlCodeToCopy = plantumlCode;
            
            // Store diagram state for regeneration and saving
            // Store base code without theme and library for switching
            let baseCode = plantumlCode;
            // Remove theme directive if present
            baseCode = baseCode.replace(/!theme\s+\w+\n/g, '');
            // Remove library include to get base code
            baseCode = baseCode.replace(/!include\s+<edgy\/edgy\d*>\n/g, '');
            
            // Detect current theme from code
            let currentTheme = 'default';
            const themeMatch = plantumlCode.match(/!theme\s+(\w+)/);
            if (themeMatch) {
                currentTheme = themeMatch[1].toLowerCase();
            }
            
            // Detect current library from code
            let currentLibrary = 'edgy/edgy';
            const libraryMatch = plantumlCode.match(/!include\s+<edgy\/(edgy\d*)>/);
            if (libraryMatch) {
                currentLibrary = `edgy/${libraryMatch[1]}`;
            }
            
            window.currentDiagramState = {
                plantumlCode: baseCode, // Store base code without theme/library
                originalCode: plantumlCode, // Store original with theme/library
                encoded: encoded,
                elementNames: elementNames,
                elementIds: elementIds,
                enterpriseFilter: enterpriseFilter,
                title: title,
                elementsCount: elementsCount,
                relationshipsCount: relationshipsCount,
                currentTheme: currentTheme, // Track current theme
                currentLibrary: currentLibrary, // Track current library
                useFacets: false, // Track facet containers setting (default false)
                diagramType: diagramType, // Track diagram type: 'all', 'architecture', 'identity', 'from-chat'
                diagramId: diagramId, // Store diagram ID if viewing a saved diagram
                includeRelationships: true, // Always include relationships
                includeRelated: includeRelated !== null ? includeRelated : false // Store include related flag
            };
            
            // Use encoded version from server (proper PlantUML encoding) with ~1 prefix
            const encodedWithPrefix = `~1${encoded}`;
            const plantumlUrl = `https://www.plantuml.com/plantuml/svg/${encodedWithPrefix}`;
            const plantumlEditorUrl = `https://www.plantuml.com/plantuml/uml/${encodedWithPrefix}`;
            const plantumlPngUrl = `https://www.plantuml.com/plantuml/png/${encodedWithPrefix}`;
            
            // Display in diagram view (main app screen) instead of modal
            const diagramContent = document.getElementById('diagramViewContent');
            const mainContentArea = document.getElementById('mainContentArea');
            
            // Switch to diagram view section
            if (typeof window.showSection === 'function') {
                window.showSection('diagramView');
            }
            
            // Hide main content area and show diagram preview
            if (mainContentArea) {
                mainContentArea.style.display = 'none';
            }
            
            if (diagramContent) {
                diagramContent.style.display = 'block';
                
                // Build diagram controls header
                const diagramControlsHeader = `
                <div style="background: #2d2d44; border-radius: 8px; padding: 20px; margin-bottom: 20px; border: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
                            <div style="flex: 1; min-width: 200px;">
                                ${diagramId ? `
                                    <input type="text" id="diagramTitleInput" value="${escapeHtml(title)}" 
                                           style="background: #1a1a2e; border: 1px solid #404060; border-radius: 6px; padding: 8px 12px; color: #ffffff; font-size: 18px; font-weight: 600; width: 100%; max-width: 400px;"
                                           onkeypress="if(event.key === 'Enter') updateDiagramTitle(${diagramId})"
                                           onblur="updateDiagramTitle(${diagramId})">
                                ` : `<h2 style="margin: 0; color: #ffffff;">${escapeHtml(title)}</h2>`}
                                <p style="color: #b0b0d0; font-size: 13px; margin-top: 5px; margin-bottom: 0;">
                                    <strong>Elements:</strong> ${elementsCount} | <strong>Relationships:</strong> ${relationshipsCount}
                                </p>
                            </div>
                        <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <label style="color: #b0b0d0; font-size: 13px;">Theme:</label>
                                <select id="diagramTheme" onchange="changeDiagramTheme()" style="padding: 6px 12px; border-radius: 6px; border: 1px solid #404060; background: #1a1a2e; color: #e0e0e0; font-size: 13px; cursor: pointer;">
                                    <option value="default">Default</option>
                                    <option value="blueprint">Blueprint</option>
                                </select>
                            </div>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <label style="color: #b0b0d0; font-size: 13px;">Library:</label>
                                <select id="diagramLibrary" onchange="changeDiagramLibrary()" style="padding: 6px 12px; border-radius: 6px; border: 1px solid #404060; background: #1a1a2e; color: #e0e0e0; font-size: 13px; cursor: pointer;">
                                    <option value="edgy/edgy">edgy/edgy</option>
                                    <option value="edgy/edgy2">edgy/edgy2</option>
                                </select>
                            </div>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <label style="color: #b0b0d0; font-size: 13px; display: flex; align-items: center; gap: 6px; cursor: pointer;">
                                    <input type="checkbox" id="diagramUseFacets" onchange="changeDiagramFacets()" style="width: 16px; height: 16px; cursor: pointer;">
                                        <span>Show Facets</span>
                                </label>
                            </div>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <label style="color: #b0b0d0; font-size: 13px; display: flex; align-items: center; gap: 6px; cursor: pointer;">
                                        <input type="checkbox" id="diagramIncludeNotes" onchange="regenerateDiagramWithSettings()" style="width: 16px; height: 16px; cursor: pointer;">
                                        <span>Include Notes</span>
                                    </label>
                                    <label style="color: #b0b0d0; font-size: 13px; display: flex; align-items: center; gap: 6px; cursor: pointer;">
                                        <input type="checkbox" id="diagramIncludeProperties" onchange="regenerateDiagramWithSettings()" style="width: 16px; height: 16px; cursor: pointer;">
                                        <span>Include Properties</span>
                                    </label>
                        </div>
                    </div>
                        </div>
                    </div>
                `;
                
                // Update diagram content with controls header and diagram preview
                diagramContent.innerHTML = diagramControlsHeader + `
                    <div style="background: #2d2d44; border-radius: 8px; padding: 20px; border: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                            <label style="color: #b0b0d0; font-size: 13px;">Zoom:</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <button class="refresh-btn" onclick="zoomDiagram('out')" style="padding: 6px 12px; font-size: 12px;"><span>-</span></button>
                                <input type="range" id="diagramZoomSlider" min="25" max="200" value="100" step="5" oninput="zoomDiagram('slider', this.value)" style="width: 120px; cursor: pointer;">
                                <span id="diagramZoomPercent" style="color: #b0b0d0; font-size: 13px; min-width: 45px; text-align: right;">100%</span>
                                <button class="refresh-btn" onclick="zoomDiagram('in')" style="padding: 6px 12px; font-size: 12px;"><span>+</span></button>
                                <button class="refresh-btn" onclick="zoomDiagram('reset')" style="padding: 6px 12px; font-size: 12px;"><span>Reset</span></button>
                            </div>
                        </div>
                        <div id="diagramZoomContainer" style="position: relative; overflow: hidden; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 10px; background: #1a1a2e; cursor: grab; height: 600px;" onmousedown="startPan(event)" onmousemove="doPan(event)" onmouseup="endPan()" onmouseleave="endPan()" onwheel="handleDiagramWheel(event)">
                            <div id="diagramPanWrapper" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); transition: transform 0.1s ease;">
                                <img id="diagramPreview" src="${plantumlUrl}" alt="PlantUML Diagram Preview" style="max-width: none; height: auto; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; transition: transform 0.2s ease; transform-origin: center center; user-select: none; pointer-events: none;" onerror="this.style.display='none'; document.getElementById('diagramError').style.display='block';" onload="initDiagramInteraction()">
                            </div>
                        </div>
                        <div style="margin-top: 10px; text-align: center; color: #888; font-size: 12px;">
                             Tip: Use mouse wheel to zoom, click and drag to pan
                        </div>
                        <div id="diagramError" style="display: none; color: #f44336; padding: 20px; background: #1a1a2e; border-radius: 6px; margin-top: 20px;">
                        Unable to load diagram preview. Please use the PlantUML editor link below.
                    </div>
                        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                            ${!diagramId ? `<button class="refresh-btn" onclick="saveCurrentDiagram()"><span>Save Diagram</span></button>` : `<button class="refresh-btn" onclick="updateCurrentDiagram(${diagramId})"><span>Save Changes</span></button>`}
                            <button class="refresh-btn" onclick="showSavedDiagramsList()"><span>Back to Diagrams</span></button>
                            <a href="${plantumlEditorUrl}" target="_blank" class="refresh-btn" style="text-decoration: none; padding: 10px 20px;"><span>Open in PlantUML Editor</span></a>
                            <a href="${plantumlUrl}" target="_blank" class="refresh-btn" style="text-decoration: none; padding: 10px 20px;"><span>Download SVG</span></a>
                            <a href="${plantumlPngUrl}" target="_blank" class="refresh-btn" style="text-decoration: none; padding: 10px 20px;"><span>Download PNG</span></a>
                    </div>
                </div>
            `;
            }
            
            // Set initial theme, library, useFacets, and includeRelationships in controls after a short delay to ensure DOM is ready
            setTimeout(() => {
                const themeSelect = document.getElementById('diagramTheme');
                const librarySelect = document.getElementById('diagramLibrary');
                const useFacetsCheckbox = document.getElementById('diagramUseFacets');
                if (window.currentDiagramState) {
                    if (themeSelect) {
                        themeSelect.value = window.currentDiagramState.currentTheme || 'default';
                    }
                    if (librarySelect) {
                        librarySelect.value = window.currentDiagramState.currentLibrary || 'edgy/edgy';
                    }
                    if (useFacetsCheckbox) {
                        useFacetsCheckbox.checked = window.currentDiagramState.useFacets === true; // Default to false
                    }
                    
                    // Show/hide relationships checkbox based on diagram type
                    // Only show for 'from-chat' diagrams or when relationships are available
                    const diagramType = window.currentDiagramState.diagramType || 'all';
                    const hasRelationships = (window.currentDiagramState.relationshipsCount || 0) > 0;
                    const showRelationshipsToggle = diagramType === 'from-chat' || hasRelationships;
                    
                    if (includeRelationshipsLabel) {
                        includeRelationshipsLabel.style.display = showRelationshipsToggle ? 'flex' : 'none';
                    }
                    
                }
                
                // Note: Add Element dropdown is no longer used since we moved to Diagram Assistant only
                // Diagram Assistant chat interface handles adding/removing elements
            }, 100);
        }
        
        // Store all available elements for filtering
        let allAvailableElementsForDiagram = [];
        
        // Load elements for the add element dropdown
        async function loadElementsForDiagramDropdown() {
            const select = document.getElementById('addElementToDiagramSelect');
            if (!select) return;
            
            try {
                // Get current diagram state to filter by enterprise
                const state = window.currentDiagramState || {};
                const enterpriseFilter = state.enterpriseFilter || null;
                const currentElementNames = state.elementNames || [];
                
                // Get all elements from repository
                const response = await fetch('/api/records');
                if (!response.ok) {
                    throw new Error('Failed to load elements');
                }
                
                const allElements = await response.json();
                
                // Filter by enterprise if specified
                const availableElements = enterpriseFilter 
                    ? allElements.filter(e => (e.enterprise || '').toLowerCase() === enterpriseFilter.toLowerCase())
                    : allElements;
                
                // Filter out elements already in the diagram
                const elementsNotInDiagram = availableElements.filter(e => !currentElementNames.includes(e.name));
                
                // Store for filtering
                allAvailableElementsForDiagram = elementsNotInDiagram;
                
                // Populate dropdown (will be filtered if search term exists)
                populateElementDropdown(elementsNotInDiagram);
                
            } catch (error) {
                console.error('Error loading elements for dropdown:', error);
                select.innerHTML = '<option value="">Error loading elements</option>';
                allAvailableElementsForDiagram = [];
            }
        }
        
        // Populate dropdown with elements (optionally filtered)
        function populateElementDropdown(elements, searchTerm = '') {
            const select = document.getElementById('addElementToDiagramSelect');
            if (!select) return;
            
            // Clear dropdown
            select.innerHTML = '<option value="">Select an element to add...</option>';
            
            if (elements.length === 0) {
                select.innerHTML = '<option value="">No elements available to add</option>';
                return;
            }
            
            // Filter by search term if provided
            let filteredElements = elements;
            if (searchTerm && searchTerm.trim()) {
                const searchLower = searchTerm.toLowerCase().trim();
                filteredElements = elements.filter(element => {
                    const elementName = (element.name || '').toLowerCase();
                    const elementType = (element.element || '').toLowerCase();
                    const facetName = (element.facet || '').toLowerCase();
                    return elementName.includes(searchLower) || 
                           elementType.includes(searchLower) || 
                           facetName.includes(searchLower);
                });
            }
            
            if (filteredElements.length === 0) {
                select.innerHTML = '<option value="">No matching elements found</option>';
                return;
            }
            
            // Sort elements by name
            filteredElements.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
            
            // Group by facet for better organization
            const elementsByFacet = {};
            filteredElements.forEach(element => {
                const facet = element.facet || 'Other';
                if (!elementsByFacet[facet]) {
                    elementsByFacet[facet] = [];
                }
                elementsByFacet[facet].push(element);
            });
            
            // Add optgroups for each facet
            Object.keys(elementsByFacet).sort().forEach(facet => {
                const optgroup = document.createElement('optgroup');
                optgroup.label = facet;
                
                elementsByFacet[facet].forEach(element => {
                    const option = document.createElement('option');
                    option.value = element.name;
                    option.textContent = `${element.name}${element.element ? ` (${element.element})` : ''}`;
                    optgroup.appendChild(option);
                });
                
                select.appendChild(optgroup);
            });
        }
        
        // Filter dropdown based on search input
        function filterElementDropdown() {
            const searchInput = document.getElementById('addElementSearchInput');
            const searchTerm = searchInput ? searchInput.value : '';
            
            // Re-populate dropdown with filtered elements
            populateElementDropdown(allAvailableElementsForDiagram, searchTerm);
        }
        
        // Add selected element to diagram and regenerate
        async function addSelectedElementToDiagram() {
            const select = document.getElementById('addElementToDiagramSelect');
            if (!select || !select.value) {
                alert('Please select an element to add');
                return;
            }
            
            const elementName = select.value;
            
            try {
                // Get current diagram state
                const diagramState = window.currentDiagramState || {};
                const elementNames = diagramState.elementNames || [];
                const enterpriseFilter = diagramState.enterpriseFilter || null;
                const diagramId = diagramState.diagramId || null;
                const currentTitle = diagramState.title || 'PlantUML Diagram';
                
                // Check if element is already in diagram
                if (elementNames.includes(elementName)) {
                    alert(`The element "${elementName}" is already in the diagram.`);
                    return;
                }
                
                // Add element name to the list
                const updatedElementNames = [...elementNames, elementName];
                
                // Regenerate diagram with new element
                // Preserve relationships flag from current state
                const currentState = window.currentDiagramState || {};
                const diagramResponse = await fetch('/api/plantuml/from-chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        element_names: updatedElementNames,
                        enterprise: enterpriseFilter,
                        include_relationships: true, // Always include relationships
                        use_facets: false, // Default to false - show elements and relationships only
                        include_notes: false, // Default to false - elements and relationships only
                        include_properties: false // Default to false - elements and relationships only
                    })
                });
                
                if (!diagramResponse.ok) {
                    const error = await diagramResponse.json();
                    alert(`Error regenerating diagram: ${error.error || 'Failed to regenerate diagram'}`);
                    return;
                }
                
                const diagramData = await diagramResponse.json();
                
                // Redisplay diagram with new element (preserve diagramId if viewing a saved diagram)
                // Preserve relationships flags when redisplaying
                displayPlantUMLDiagram(
                    diagramData.plantuml,
                    diagramData.encoded,
                    diagramData.elements_count,
                    diagramData.relationships_count,
                    currentTitle, // Use current title instead of data.title to preserve original
                    updatedElementNames,
                    enterpriseFilter,
                    diagramData.element_ids || [],
                    'from-chat', // Use from-chat diagramType to preserve relationship flags
                    diagramId, // Preserve diagramId so title remains editable
                    true, // Always include relationships
                    currentState.includeRelated || false // Preserve include related flag
                );
                
                // Clear search input and reload dropdown to refresh available elements (excludes the one just added)
                const searchInput = document.getElementById('addElementSearchInput');
                if (searchInput) {
                    searchInput.value = '';
                }
                await loadElementsForDiagramDropdown();
                
            } catch (error) {
                console.error('Error adding element to diagram:', error);
                alert(`Error: ${error.message}`);
            }
        }

        // Diagram Assistant - Simple help responses
        async function sendDiagramChatMessage() {
            const input = document.getElementById('diagramChatInput');
            const message = input.value.trim();
            
            if (!message) {
                return;
            }
            
            // Clear input
            input.value = '';
            
            // Add user message to chat
            addDiagramChatMessage('user', message);
            
            // Show thinking indicator
            const thinkingId = addDiagramChatMessage('assistant', 'Processing your request...', true);
            
            try {
                // First, check if this is an add/remove command
                const action = parseDiagramChatCommand(message);
                
                if (action) {
                    // Handle add/remove commands directly (for diagram manipulation)
                    await handleDiagramAddRemoveCommand(action, thinkingId);
                    return;
                }
                
                // Otherwise, provide simple help responses
                const response = getDiagramAssistantResponse(message);
                updateDiagramChatMessage(thinkingId, 'assistant', response);
                
            } catch (error) {
                console.error('Error processing diagram chat message:', error);
                updateDiagramChatMessage(thinkingId, 'assistant', `Error: ${error.message}`);
            }
        }
        
        // Simple response function for Diagram Assistant
        function getDiagramAssistantResponse(message) {
            const lowerMessage = message.toLowerCase().trim();
            
            // Help topics
            if (lowerMessage.includes('how to add') || lowerMessage.includes('add element') || lowerMessage.includes('add elements')) {
                return 'To add elements to your diagram:\n\n' +
                       '1. Use the "Add Element to Diagram" dropdown above to select an element from your repository\n' +
                       '2. Or type "Add [Element Name]" in this chat (e.g., "Add Product ABC")\n' +
                       '3. The diagram will automatically regenerate with the new element';
            }
            
            if (lowerMessage.includes('how to remove') || lowerMessage.includes('remove element') || lowerMessage.includes('remove elements')) {
                return 'To remove elements from your diagram:\n\n' +
                       '1. Type "Remove [Element Name]" in this chat (e.g., "Remove Product ABC")\n' +
                       '2. The diagram will automatically regenerate without that element';
            }
            
            if (lowerMessage.includes('how to save') || lowerMessage.includes('save diagram')) {
                return 'To save your diagram:\n\n' +
                       '1. Click the "Save Diagram" button (or "Save Changes" if editing an existing diagram)\n' +
                       '2. Enter a name for your diagram\n' +
                       '3. The diagram will be saved and appear in your Saved Diagrams list';
            }
            
            if (lowerMessage.includes('how to zoom') || lowerMessage.includes('zoom')) {
                return 'To zoom your diagram:\n\n' +
                       '1. Use the zoom controls above the diagram preview\n' +
                       '2. Click the + button to zoom in\n' +
                       '3. Click the - button to zoom out\n' +
                       '4. Use the slider or click Reset to return to 100%';
            }
            
            if (lowerMessage.includes('how to download') || lowerMessage.includes('download diagram')) {
                return 'To download your diagram:\n\n' +
                       '1. Click the "Download Diagram" button\n' +
                       '2. The diagram will be downloaded as a PNG image file';
            }
            
            if (lowerMessage.includes('facets') || lowerMessage.includes('show facets')) {
                return 'To show or hide facets in your diagram:\n\n' +
                       '1. Check or uncheck the "Use Facets" checkbox in the Diagram Preview controls\n' +
                       '2. Facets group related elements together visually';
            }
            
            if (lowerMessage.includes('relationships') || lowerMessage.includes('show relationships')) {
                return 'To show or hide relationships in your diagram:\n\n' +
                       'Relationships are always shown in diagrams to display how elements connect to each other.';
            }
            
            if (lowerMessage.includes('notes') || lowerMessage.includes('properties')) {
                return 'To include notes or properties in your diagram:\n\n' +
                       '1. Check the "Include Notes" checkbox to show element descriptions\n' +
                       '2. Check the "Include Properties" checkbox to show element properties\n' +
                       '3. Notes and properties appear as annotations next to elements';
            }
            
            if (lowerMessage.includes('theme') || lowerMessage.includes('change theme')) {
                return 'To change the diagram theme:\n\n' +
                       '1. Select a theme from the "Theme" dropdown in Diagram Preview\n' +
                       '2. Available themes include: Default, Dark, Light, and more\n' +
                       '3. The diagram will regenerate with the new theme';
            }
            
            if (lowerMessage.includes('library') || lowerMessage.includes('change library')) {
                return 'To change the diagram library:\n\n' +
                       '1. Select a library from the "Library" dropdown in Diagram Preview\n' +
                       '2. Available libraries include: EDGY, Architecture, Identity\n' +
                       '3. The diagram will regenerate with the new library';
            }
            
            if (lowerMessage.includes('saved diagrams') || lowerMessage.includes('view saved')) {
                return 'To view your saved diagrams:\n\n' +
                       '1. Click the "Visualise Repository" button in the sidebar\n' +
                       '2. Your saved diagrams will appear in the list\n' +
                       '3. Click on any diagram thumbnail to open it';
            }
            
            if (lowerMessage.includes('enterprise') || lowerMessage.includes('repository') || lowerMessage.includes('filter')) {
                return 'To filter by Enterprise/Repository:\n\n' +
                       '1. The diagram uses the enterprise filter from your current diagram state\n' +
                       '2. When you create or open a diagram, it filters elements by the selected enterprise\n' +
                       '3. You can change the filter when creating new diagrams';
            }
            
            // Default response
            return 'I can help you with:\n\n' +
                   ' Adding elements to diagrams ("Add [Element Name]")\n' +
                   ' Removing elements from diagrams ("Remove [Element Name]")\n' +
                   ' Saving and downloading diagrams\n' +
                   ' Zooming and viewing diagrams\n' +
                   ' Showing/hiding facets and relationships\n' +
                   ' Including notes and properties\n' +
                   ' Changing themes and libraries\n' +
                   ' Viewing saved diagrams\n\n' +
                   'Try asking: "How do I add elements?" or "How do I save a diagram?"';
        }
        
        // Handle add/remove commands for diagram elements (backward compatibility)
        async function handleDiagramAddRemoveCommand(action, thinkingId) {
            try {
                // Get current diagram state
                const state = window.currentDiagramState || {};
                const currentElementNames = state.elementNames || [];
                const enterpriseFilter = state.enterpriseFilter || null;
                
                // Get available elements from repository
                const elementsResponse = await fetch('/api/records');
                if (!elementsResponse.ok) {
                    throw new Error('Failed to load elements');
                }
                const allElements = await elementsResponse.json();
                
                // Filter by enterprise if specified
                const availableElements = enterpriseFilter 
                    ? allElements.filter(e => (e.enterprise || '').toLowerCase() === enterpriseFilter.toLowerCase())
                    : allElements;
                
                // Find matching element
                const matchingElement = findMatchingElement(action.elementName, availableElements);
                
                if (!matchingElement) {
                    updateDiagramChatMessage(thinkingId, 'assistant', `I couldn't find an element named "${action.elementName}" in the repository. Please check the spelling or ensure the element exists.`);
                    return;
                }
                
                let updatedElementNames;
                let responseMessage;
                
                if (action.type === 'add') {
                    // Check if already in diagram
                    if (currentElementNames.includes(matchingElement.name)) {
                        updateDiagramChatMessage(thinkingId, 'assistant', `The element "${matchingElement.name}" is already in the diagram.`);
                        return;
                    }
                    
                    // Add element
                    updatedElementNames = [...currentElementNames, matchingElement.name];
                    responseMessage = `Added "${matchingElement.name}" to the diagram. Regenerating...`;
                } else if (action.type === 'remove') {
                    // Check if in diagram
                    if (!currentElementNames.includes(matchingElement.name)) {
                        updateDiagramChatMessage(thinkingId, 'assistant', `The element "${matchingElement.name}" is not currently in the diagram.`);
                        return;
                    }
                    
                    // Remove element
                    updatedElementNames = currentElementNames.filter(name => name !== matchingElement.name);
                    responseMessage = `Removed "${matchingElement.name}" from the diagram. Regenerating...`;
                }
                
                updateDiagramChatMessage(thinkingId, 'assistant', responseMessage);
                
                // Regenerate diagram with updated elements
                const currentState = window.currentDiagramState || {};
                const diagramResponse = await fetch('/api/plantuml/from-chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        element_names: updatedElementNames,
                        enterprise: enterpriseFilter,
                        include_relationships: true, // Always include relationships
                        use_facets: false, // Default to false - show elements and relationships only
                        include_notes: false, // Default to false - elements and relationships only
                        include_properties: false // Default to false - elements and relationships only
                    })
                });
                
                if (!diagramResponse.ok) {
                    const error = await diagramResponse.json();
                    updateDiagramChatMessage(thinkingId, 'assistant', `Error regenerating diagram: ${error.error || 'Failed to regenerate diagram'}`);
                    return;
                }
                
                const diagramData = await diagramResponse.json();
                
                // Update diagram display
                displayPlantUMLDiagram(
                    diagramData.plantuml,
                    diagramData.encoded,
                    diagramData.elements_count,
                    diagramData.relationships_count,
                    state.title || 'PlantUML Diagram',
                    updatedElementNames,
                    enterpriseFilter,
                    diagramData.element_ids || [],
                    state.diagramType || 'from-chat',
                    state.diagramId || null,
                    true, // Always include relationships
                    currentState.includeRelated || false
                );
                
                updateDiagramChatMessage(thinkingId, 'assistant', `Successfully ${action.type === 'add' ? 'added' : 'removed'} "${matchingElement.name}". The diagram has been updated.`);
                
            } catch (error) {
                console.error('Error handling add/remove command:', error);
                updateDiagramChatMessage(thinkingId, 'assistant', `Error: ${error.message}`);
            }
        }
        
        function parseDiagramChatCommand(message) {
            const lowerMessage = message.toLowerCase().trim();
            
            // Skip if message looks like a question (contains question mark or question words)
            if (message.includes('?') || 
                /^(what|how|when|where|why|who|which|show|tell|list|explain|describe|find|can you|tell me|i want to know)/i.test(lowerMessage)) {
                return null;
            }
            
            // Only match very specific, short commands for diagram manipulation
            // Match: "Add [Element Name]" where Element Name is short (max 50 chars) and simple
            const addPatterns = [
                /^add\s+(?:the\s+)?(?:element\s+)?([A-Za-z0-9\s]{1,50})$/i,
                /^include\s+(?:the\s+)?(?:element\s+)?([A-Za-z0-9\s]{1,50})$/i,
                /^insert\s+(?:the\s+)?(?:element\s+)?([A-Za-z0-9\s]{1,50})$/i,
            ];
            
            // Match: "Remove [Element Name]" where Element Name is short (max 50 chars) and simple
            const removePatterns = [
                /^remove\s+(?:the\s+)?(?:element\s+)?([A-Za-z0-9\s]{1,50})$/i,
                /^delete\s+(?:the\s+)?(?:element\s+)?([A-Za-z0-9\s]{1,50})$/i,
                /^exclude\s+(?:the\s+)?(?:element\s+)?([A-Za-z0-9\s]{1,50})$/i,
            ];
            
            // Try add patterns - must match at start of message and be short
            for (const pattern of addPatterns) {
                const match = message.match(pattern);
                if (match && match[1]) {
                    const elementName = match[1].trim();
                    // Additional validation: element name should be simple (no question words, no punctuation except spaces)
                    if (elementName.length > 0 && 
                        elementName.length <= 50 &&
                        !/[?.,!;:]/.test(elementName) &&
                        !/^(what|how|when|where|why|who|which|show|tell|list|explain|describe|find|all|are|is|the|a|an)/i.test(elementName)) {
                        return {
                            type: 'add',
                            elementName: elementName
                        };
                    }
                }
            }
            
            // Try remove patterns - must match at start of message and be short
            for (const pattern of removePatterns) {
                const match = message.match(pattern);
                if (match && match[1]) {
                    const elementName = match[1].trim();
                    // Additional validation: element name should be simple (no question words, no punctuation except spaces)
                    if (elementName.length > 0 && 
                        elementName.length <= 50 &&
                        !/[?.,!;:]/.test(elementName) &&
                        !/^(what|how|when|where|why|who|which|show|tell|list|explain|describe|find|all|are|is|the|a|an)/i.test(elementName)) {
                        return {
                            type: 'remove',
                            elementName: elementName
                        };
                    }
                }
            }
            
            return null;
        }
        
        function findMatchingElement(searchName, elements) {
            const lowerSearch = searchName.toLowerCase().trim();
            
            // Try exact match first (case-insensitive)
            let match = elements.find(e => e.name && e.name.toLowerCase() === lowerSearch);
            if (match) return match;
            
            // Try partial match
            match = elements.find(e => e.name && e.name.toLowerCase().includes(lowerSearch));
            if (match) return match;
            
            // Try reverse (search name contains element name)
            match = elements.find(e => e.name && lowerSearch.includes(e.name.toLowerCase()));
            if (match) return match;
            
            return null;
        }
        
        function addDiagramChatMessage(role, message, isTemporary = false) {
            const chatContainer = document.getElementById('diagramChatMessages');
            if (!chatContainer) return null;
            
            // Clear "No messages yet" if present
            const noMessages = chatContainer.querySelector('div[style*="font-style: italic"]');
            if (noMessages) {
                noMessages.remove();
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `margin-bottom: 10px; padding: 10px; border-radius: 6px; ${role === 'user' ? 'background: #1e1e1e; text-align: right;' : 'background: #2a2a2a; text-align: left;'}`;
            
            const messageContent = document.createElement('div');
            messageContent.style.cssText = `color: ${role === 'user' ? '#ffffff' : '#e0e0e0'}; font-size: 13px; word-wrap: break-word;`;
            messageContent.textContent = message;
            messageDiv.appendChild(messageContent);
            
            chatContainer.appendChild(messageDiv);
            
            // Scroll to bottom
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            // Return ID for temporary messages (for updating)
            if (isTemporary) {
                messageDiv.setAttribute('data-temp-id', Date.now().toString());
                return messageDiv.getAttribute('data-temp-id');
            }
            
            return null;
        }
        
        function updateDiagramChatMessage(tempId, role, newMessage) {
            const chatContainer = document.getElementById('diagramChatMessages');
            if (!chatContainer) return;
            
            const messageDiv = chatContainer.querySelector(`div[data-temp-id="${tempId}"]`);
            
            if (messageDiv) {
                const messageContent = messageDiv.querySelector('div');
                if (messageContent) {
                    // Support line breaks in messages
                    messageContent.innerHTML = escapeHtml(newMessage).replace(/\n/g, '<br>');
                }
                messageDiv.removeAttribute('data-temp-id');
            } else {
                // If not found, just add as new message
                addDiagramChatMessage(role, newMessage);
            }
            
            // Scroll to bottom
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
        

        // Load enterprises for the dropdown
        async function loadEnterprises() {
            try {
                const response = await fetch('/api/enterprises');
                if (!response.ok) {
                    console.error('Failed to load enterprises:', response.status, response.statusText);
                    return;
                }
                const enterprises = await response.json();
                
                if (!Array.isArray(enterprises)) {
                    console.error('Invalid enterprises data:', enterprises);
                    return;
                }
                
                // Populate PlantUML enterprise selector
                const select = document.getElementById('enterpriseSelect');
                if (select) {
                    // Keep "All Enterprises" option, then add enterprise options
                    select.innerHTML = '<option value="">All Enterprises</option>';
                    enterprises.forEach(enterprise => {
                        if (enterprise) {  // Only add non-empty enterprise names
                            const option = document.createElement('option');
                            option.value = enterprise;
                            option.textContent = enterprise;
                            select.appendChild(option);
                        }
                    });
                }
                
                // Populate chatbot enterprise selector
                const chatbotSelect = document.getElementById('chatbotEnterpriseSelect');
                if (chatbotSelect) {
                    // Keep "All Enterprises" option, then add enterprise options
                    chatbotSelect.innerHTML = '<option value="">All Enterprises</option>';
                    enterprises.forEach(enterprise => {
                        if (enterprise) {  // Only add non-empty enterprise names
                            const option = document.createElement('option');
                            option.value = enterprise;
                            option.textContent = enterprise;
                            chatbotSelect.appendChild(option);
                        }
                    });
                }
                
                // Populate relationship enterprise selectors
                const relationshipEnterpriseSelect = document.getElementById('relationshipEnterpriseSelect');
                if (relationshipEnterpriseSelect) {
                    relationshipEnterpriseSelect.innerHTML = '<option value="">All Enterprises</option>';
                    enterprises.forEach(enterprise => {
                        if (enterprise) {
                            const option = document.createElement('option');
                            option.value = enterprise;
                            option.textContent = enterprise;
                            relationshipEnterpriseSelect.appendChild(option);
                        }
                    });
                }
                
                const relationshipsEnterpriseSelect = document.getElementById('relationshipsEnterpriseSelect');
                if (relationshipsEnterpriseSelect) {
                    relationshipsEnterpriseSelect.innerHTML = '<option value="">All Enterprises</option>';
                    enterprises.forEach(enterprise => {
                        if (enterprise) {
                            const option = document.createElement('option');
                            option.value = enterprise;
                            option.textContent = enterprise;
                            relationshipsEnterpriseSelect.appendChild(option);
                        }
                    });
                }
                if (chatbotSelect) {
                    chatbotSelect.innerHTML = '<option value="">All Enterprises</option>';
                    enterprises.forEach(enterprise => {
                        if (enterprise) {  // Only add non-empty enterprise names
                            const option = document.createElement('option');
                            option.value = enterprise;
                            option.textContent = enterprise;
                            chatbotSelect.appendChild(option);
                        }
                    });
                }
                
                console.log(`Loaded ${enterprises.length} enterprises for dropdown`);
            } catch (error) {
                console.error('Error loading enterprises:', error);
            }
        }

        // Generate PlantUML diagram (all relationships)
        // Visualise Repository functions removed - functionality no longer needed

        // Load saved diagrams for main screen
        async function loadSavedDiagramsForMain() {
            try {
                const url = '/api/diagrams';
                console.log('[Diagrams] loadSavedDiagramsForMain: Starting request to', url);
                
                // Add timeout to prevent indefinite hanging (10 seconds)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    console.error('[Diagrams] loadSavedDiagramsForMain: Request timeout - aborting');
                    controller.abort();
                }, 10000);
                
                const fetchStartTime = Date.now();
                const response = await fetch(url, {
                    signal: controller.signal,
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    }
                });
                const fetchTime = Date.now() - fetchStartTime;
                console.log(`[Diagrams] loadSavedDiagramsForMain: Fetch completed in ${fetchTime}ms, status: ${response.status}`);
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`Failed to load saved diagrams: ${response.status} ${response.statusText}`);
                }
                
                console.log('[Diagrams] loadSavedDiagramsForMain: Parsing JSON response...');
                const jsonStartTime = Date.now();
                const diagrams = await response.json();
                const jsonTime = Date.now() - jsonStartTime;
                console.log(`[Diagrams] loadSavedDiagramsForMain: JSON parsed in ${jsonTime}ms, got ${diagrams.length} diagrams`);
                const diagramsList = document.getElementById('savedDiagramsMainList');
                
                if (!diagramsList) return;
                
                if (diagrams.length === 0) {
                    diagramsList.innerHTML = '<div class="empty-state" style="padding: 40px; text-align: center; color: #888; font-size: 14px; grid-column: 1 / -1;">No saved diagrams yet. Generate and save a diagram to see it here.</div>';
                    return;
                }
                
                // Generate thumbnail URLs for all diagrams first
                const diagramsWithThumbnails = diagrams.map(diagram => {
                    let thumbnailUrl = '';
                    if (diagram.encoded_url) {
                        let encoded = diagram.encoded_url;
                        // Handle backwards compatibility - extract encoded from URL if needed
                        if (encoded.includes('plantuml.com')) {
                            const match = encoded.match(/plantuml\/[^\/]+\/~?1?([^\/\?]+)/);
                            if (match) {
                                encoded = match[1];
                                // Remove ~1 prefix if present (we'll add it back)
                                if (encoded.startsWith('~1')) {
                                    encoded = encoded.substring(2);
                                }
                            }
                        } else {
                            // It's the raw encoded string, remove ~1 prefix if present
                            if (encoded.startsWith('~1')) {
                                encoded = encoded.substring(2);
                            }
                        }
                        // Add ~1 prefix for PlantUML compressed format
                        if (encoded) {
                            const encodedWithPrefix = `~1${encoded}`;
                            thumbnailUrl = `https://www.plantuml.com/plantuml/svg/${encodedWithPrefix}`;
                        }
                    }
                    return { ...diagram, thumbnailUrl };
                });
                    
                // Display in a grid layout for main screen
                diagramsList.innerHTML = diagramsWithThumbnails.map(diagram => {
                    const isActive = window.lastViewedDiagramId === diagram.id;
                    return `
                        <div class="record-card" 
                             onclick="viewSavedDiagram(${diagram.id})"
                             style="cursor: pointer; border-left: 4px solid ${isActive ? '#4CAF50' : '#404060'}; padding: 15px; transition: transform 0.2s, box-shadow 0.2s; background: ${isActive ? '#3d3d54' : '#2d2d44'};"
                             onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.4)';"
                             onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='';">
                            ${diagram.thumbnailUrl ? `
                            <div style="width: 100%; margin-bottom: 12px; text-align: center; background: #1a1a2e; padding: 10px; border-radius: 6px;">
                                <img src="${diagram.thumbnailUrl}" 
                                     alt="Diagram Thumbnail" 
                                     style="max-width: 100%; max-height: 150px; width: auto; height: auto; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);"
                                     onerror="this.style.display='none';">
                                </div>
                            ` : `
                            <div style="width: 100%; margin-bottom: 12px; text-align: center; background: #1a1a2e; padding: 40px 20px; border-radius: 6px; color: #888;">
                                No preview available
                                </div>
                            `}
                            <div style="text-align: center;">
                                <div style="color: #e0e0e0; font-weight: 500; font-size: 14px; word-wrap: break-word;">
                                    ${escapeHtml(diagram.title || 'Untitled Diagram')}
                            </div>
                                    </div>
                                    </div>
                    `;
                }).join('');
            } catch (error) {
                const diagramsList = document.getElementById('savedDiagramsMainList');
                if (diagramsList) {
                    const errorMsg = error.name === 'AbortError' 
                        ? 'Request timed out. The database may be locked or slow. Please try again.'
                        : `Error loading saved diagrams: ${error.message}`;
                    diagramsList.innerHTML = `<div class="empty-state" style="padding: 40px; text-align: center; color: #f44336; font-size: 14px; grid-column: 1 / -1;">${errorMsg}</div>`;
                }
                console.error('[Diagrams] Error loading saved diagrams:', error);
            }
        }

        // Show saved diagrams list (hide diagram preview and other content)
        function showSavedDiagramsList() {
            // Save chat messages before switching sections
            saveChatMessages();
            
            const mainContentArea = document.getElementById('mainContentArea');
            const diagramViewContent = document.getElementById('diagramViewContent');
            // Hide diagram preview
            if (diagramViewContent) {
                diagramViewContent.style.display = 'none';
            }
            
            // Show main content area (make sure it's visible)
            if (mainContentArea) {
                mainContentArea.style.display = 'block';
                mainContentArea.innerHTML = `
                    <div id="savedDiagramsMainSection">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h3 style="color: #ffffff; margin: 0; font-size: 18px; display: flex; align-items: center; gap: 10px;">
                                <img src="/images/save-diagram.png" alt="Saved Diagrams" style="width: 32px; height: 32px; vertical-align: middle; object-fit: contain;">
                                <span>Saved Diagrams</span>
                            </h3>
                            <button class="refresh-btn" onclick="loadSavedDiagramsForMain()">
                                <span>Refresh</span>
                            </button>
                                    </div>
                        <div id="savedDiagramsMainList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 20px;">
                            <div class="empty-state" style="padding: 40px; text-align: center; color: #888; font-size: 14px; grid-column: 1 / -1;">Loading saved diagrams...</div>
                                        </div>
                                    </div>
                `;
            }
            
            // Reload diagrams to refresh the list
            loadSavedDiagramsForMain();
        }
        
        // Load Add Element content into main area
        function loadAddElementInMain() {
            // Save chat messages before switching sections
            saveChatMessages();
            
            const mainContentArea = document.getElementById('mainContentArea');
            const diagramViewContent = document.getElementById('diagramViewContent');
            const sourceSection = document.getElementById('addElement');
            
            // Hide diagram preview
            if (diagramViewContent) {
                diagramViewContent.style.display = 'none';
            }
            
            // Get content HTML from source section (excluding the back button)
            if (sourceSection && mainContentArea) {
                mainContentArea.style.display = 'block';
                // Temporarily show the section to get its content
                const wasHidden = !sourceSection.classList.contains('active');
                sourceSection.classList.add('active');
                
                // Clone the section and remove back button
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = sourceSection.innerHTML;
                const backButton = tempDiv.querySelector('.back-to-dashboard');
                if (backButton) {
                    backButton.remove();
                }
                
                // Create back to diagrams button
                const backToDiagramsBtn = '<button class="refresh-btn" onclick="showSavedDiagramsList()" style="margin-bottom: 20px;"><span>Back to Diagrams</span></button>';
                
                mainContentArea.innerHTML = backToDiagramsBtn + tempDiv.innerHTML;
                
                // Hide the source section again if it was hidden
                if (wasHidden) {
                    sourceSection.classList.remove('active');
                }
                
                // Load data for Add Element
                loadRecords();
                loadAvailableProperties();
            }
        }
        
        // Load Create Relationship content into main area
        // loadCreateRelationshipInMain and loadVisualiseInMain functions removed - features no longer needed
        
        // Load Manage Enterprises content into main area
        
        // Global storage for chat messages to persist across section switches
        let savedChatMessages = null;
        let savedEnterpriseFilter = null;
        
        // Function to save chat messages before switching sections
        function saveChatMessages() {
            const mainContentArea = document.getElementById('mainContentArea');
            if (mainContentArea) {
                const existingChatMessages = mainContentArea.querySelector('#chatMessages');
                if (existingChatMessages) {
                    const allMessages = existingChatMessages.querySelectorAll('.chat-message');
                    if (allMessages.length > 1) { // More than just the welcome message
                        savedChatMessages = Array.from(allMessages).slice(1).map(msg => msg.outerHTML).join('');
                        
                        // Also save the Enterprise filter selection
                        const enterpriseSelect = document.getElementById('chatbotEnterpriseSelect');
                        if (enterpriseSelect) {
                            savedEnterpriseFilter = enterpriseSelect.value;
                            console.log('[Chat] Saved', allMessages.length - 1, 'chat messages and Enterprise filter:', savedEnterpriseFilter || 'All Enterprises');
                        } else {
                            console.log('[Chat] Saved', allMessages.length - 1, 'chat messages (Enterprise select not found)');
                        }
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Function to restore chat messages when switching back to chatbot
        function restoreChatMessages() {
            if (savedChatMessages) {
                const mainContentArea = document.getElementById('mainContentArea');
                if (mainContentArea) {
                    const chatMessagesContainer = mainContentArea.querySelector('#chatMessages');
                    if (chatMessagesContainer) {
                        // Check if messages are already restored (avoid duplicates)
                        const existingMessages = chatMessagesContainer.querySelectorAll('.chat-message');
                        if (existingMessages.length <= 1) { // Only welcome message exists
                            // Append saved messages after the welcome message
                            chatMessagesContainer.insertAdjacentHTML('beforeend', savedChatMessages);
                            console.log('[Chat] Restored', savedChatMessages.split('class="chat-message').length - 1, 'chat messages');
                            
                            // Note: Enterprise filter is restored in loadChatbotInMain() after loadEnterprises() completes
                            
                            // Scroll to bottom to show latest messages
                            setTimeout(() => {
                                chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
                            }, 100);
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // Load Chatbot content into main area
        function loadChatbotInMain() {
            const mainContentArea = document.getElementById('mainContentArea');
            const diagramViewContent = document.getElementById('diagramViewContent');
            const sourceSection = document.getElementById('chatbot');
            
            // Hide diagram preview
            if (diagramViewContent) {
                diagramViewContent.style.display = 'none';
            }
            
            // Get content HTML from source section (excluding the back button)
            if (sourceSection && mainContentArea) {
                mainContentArea.style.display = 'block';
                
                // PRESERVE CHAT MESSAGES: Save current messages before replacing content
                const hadMessages = saveChatMessages();
                
                // Temporarily show the section to get its content
                const wasHidden = !sourceSection.classList.contains('active');
                sourceSection.classList.add('active');
                
                // Clone the section and remove back button
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = sourceSection.innerHTML;
                const backButton = tempDiv.querySelector('.back-to-dashboard');
                if (backButton) {
                    backButton.remove();
                }
                
                // Create back to diagrams button
                const backToDiagramsBtn = '<button class="refresh-btn" onclick="showSavedDiagramsList()" style="margin-bottom: 20px;"><span>Back to Diagrams</span></button>';
                
                mainContentArea.innerHTML = backToDiagramsBtn + tempDiv.innerHTML;
                
                // RESTORE CHAT MESSAGES: Restore saved messages if they exist
                restoreChatMessages();
                
                // Hide the source section again if it was hidden
                if (wasHidden) {
                    sourceSection.classList.remove('active');
                }
                
                // Load data for Chatbot
                loadEnterprises();
                
                // Restore Enterprise filter after enterprises are loaded
                if (savedEnterpriseFilter !== null) {
                    setTimeout(() => {
                        const enterpriseSelect = document.getElementById('chatbotEnterpriseSelect');
                        if (enterpriseSelect) {
                            enterpriseSelect.value = savedEnterpriseFilter;
                            console.log('[Chat] Restored Enterprise filter after loadEnterprises:', savedEnterpriseFilter || 'All Enterprises');
                        }
                    }, 200); // Wait for loadEnterprises to complete
                }
                
                // Only prompt for username if this is the first time (no saved messages)
                if (!hadMessages) {
                promptForUserName();
                }
            }
        }
        
        // Load saved diagrams
        async function loadSavedDiagrams() {
            try {
                const enterpriseSelect = document.getElementById('enterpriseSelect');
                const enterprise = enterpriseSelect ? enterpriseSelect.value : '';
                const url = enterprise ? `/api/diagrams?enterprise=${encodeURIComponent(enterprise)}` : '/api/diagrams';
                console.log('[Diagrams] loadSavedDiagrams: Starting request to', url);
                
                // Add timeout to prevent indefinite hanging (10 seconds)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    console.error('[Diagrams] loadSavedDiagrams: Request timeout - aborting');
                    controller.abort();
                }, 10000);
                
                const fetchStartTime = Date.now();
                const response = await fetch(url, {
                    signal: controller.signal,
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    }
                });
                const fetchTime = Date.now() - fetchStartTime;
                console.log(`[Diagrams] loadSavedDiagrams: Fetch completed in ${fetchTime}ms, status: ${response.status}`);
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`Failed to load saved diagrams: ${response.status} ${response.statusText}`);
                }
                
                console.log('[Diagrams] loadSavedDiagrams: Parsing JSON response...');
                const jsonStartTime = Date.now();
                const diagrams = await response.json();
                const jsonTime = Date.now() - jsonStartTime;
                console.log(`[Diagrams] loadSavedDiagrams: JSON parsed in ${jsonTime}ms, got ${diagrams.length} diagrams`);
                const diagramsList = document.getElementById('savedDiagramsList');
                
                if (diagrams.length === 0) {
                    diagramsList.innerHTML = '<div class="empty-state">No saved diagrams yet. Generate and save a diagram to see it here.</div>';
                    return;
                }
                
                // Generate thumbnail URLs for all diagrams first
                const diagramsWithThumbnails = diagrams.map(diagram => {
                    let thumbnailUrl = '';
                    if (diagram.encoded_url) {
                        let encoded = diagram.encoded_url;
                        // Handle backwards compatibility - extract encoded from URL if needed
                        if (encoded.includes('plantuml.com')) {
                            const match = encoded.match(/plantuml\/[^\/]+\/~?1?([^\/\?]+)/);
                            if (match) {
                                encoded = match[1];
                                // Remove ~1 prefix if present (we'll add it back)
                                if (encoded.startsWith('~1')) {
                                    encoded = encoded.substring(2);
                                }
                            }
                        } else {
                            // It's the raw encoded string, remove ~1 prefix if present
                            if (encoded.startsWith('~1')) {
                                encoded = encoded.substring(2);
                            }
                        }
                        // Add ~1 prefix for PlantUML compressed format
                        if (encoded) {
                            const encodedWithPrefix = `~1${encoded}`;
                            thumbnailUrl = `https://www.plantuml.com/plantuml/svg/${encodedWithPrefix}`;
                        }
                    }
                    return { ...diagram, thumbnailUrl };
                });
                
                // Update the list container to use a grid layout
                diagramsList.style.display = 'grid';
                diagramsList.style.gridTemplateColumns = 'repeat(auto-fill, minmax(200px, 1fr))';
                diagramsList.style.gap = '20px';
                
                diagramsList.innerHTML = diagramsWithThumbnails.map(diagram => {
                    return `
                        <div class="record-card" 
                             onclick="viewSavedDiagram(${diagram.id})"
                             style="cursor: pointer; border-left: 4px solid #4CAF50; padding: 15px; transition: transform 0.2s, box-shadow 0.2s;"
                             onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.4)';"
                             onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='';">
                            ${diagram.thumbnailUrl ? `
                            <div style="width: 100%; margin-bottom: 12px; text-align: center; background: #1a1a2e; padding: 10px; border-radius: 6px;">
                                <img src="${diagram.thumbnailUrl}" 
                                             alt="Diagram Thumbnail" 
                                     style="max-width: 100%; max-height: 150px; width: auto; height: auto; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);"
                                     onerror="this.style.display='none';">
                                    </div>
                            ` : `
                            <div style="width: 100%; margin-bottom: 12px; text-align: center; background: #1a1a2e; padding: 40px 20px; border-radius: 6px; color: #888;">
                                No preview available
                                </div>
                            `}
                            <div style="text-align: center;">
                                <div style="color: #e0e0e0; font-weight: 500; font-size: 14px; word-wrap: break-word;">
                                    ${escapeHtml(diagram.title || 'Untitled Diagram')}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            } catch (error) {
                const errorMsg = error.name === 'AbortError' 
                    ? 'Request timed out. The database may be locked or slow. Please try again.'
                    : `Error loading saved diagrams: ${error.message}`;
                const diagramsList = document.getElementById('savedDiagramsList');
                if (diagramsList) {
                    diagramsList.innerHTML = `<div class="empty-state">${errorMsg}</div>`;
                }
                console.error('[Diagrams] Error loading saved diagrams:', error);
            }
        }

        // View a saved diagram
        async function viewSavedDiagram(diagramId) {
            try {
                // Include enterprise filter for repository scoping validation
                const enterpriseSelect = document.getElementById('enterpriseSelect');
                const enterprise = enterpriseSelect ? enterpriseSelect.value : '';
                const url = enterprise ? `/api/diagrams/${diagramId}?enterprise=${encodeURIComponent(enterprise)}` : `/api/diagrams/${diagramId}`;
                
                const response = await fetch(url);
                if (!response.ok) {
                    const error = await response.json();
                    if (response.status === 403) {
                        alert(`Repository scoping violation: ${error.error || 'This diagram does not belong to the selected repository'}`);
                    } else {
                        throw new Error(error.error || 'Failed to load diagram');
                    }
                    return;
                }
                
                const diagram = await response.json();
                
                // Extract element names from the diagram's elements array
                const elementNames = diagram.elements ? diagram.elements.map(e => e.name) : [];
                
                // Get encoded value - it's stored in encoded_url field as the raw encoded string
                // (We now store just the encoded string, not the full URL)
                let encoded = diagram.encoded_url || '';
                
                // If it looks like a full URL (for backwards compatibility with old saved diagrams),
                // extract the encoded part
                if (encoded && encoded.includes('plantuml.com')) {
                    const match = encoded.match(/plantuml\/[^\/]+\/~?1?([^\/\?]+)/);
                    if (match) {
                        encoded = match[1];
                        // Remove ~1 prefix if present
                        if (encoded.startsWith('~1')) {
                            encoded = encoded.substring(2);
                        }
                    }
                }
                
                // If we still don't have encoded value but have plantuml_code, regenerate the diagram
                if (!encoded && diagram.plantuml_code) {
                    console.log('No encoded value found, regenerating diagram...');
                    await regenerateSavedDiagram(diagramId);
                    return;
                }
                
                // Store last viewed diagram ID
                window.lastViewedDiagramId = diagramId;
                localStorage.setItem('lastViewedDiagramId', diagramId.toString());
                
                // Display the diagram with diagram ID for editing
                displayPlantUMLDiagram(
                    diagram.plantuml_code,
                    encoded,
                    diagram.elements_count || 0,
                    diagram.relationships_count || 0,
                    diagram.title || 'Saved Diagram',
                    elementNames,
                    diagram.enterprise_filter || null,
                    diagram.elements ? diagram.elements.map(e => e.id) : [],
                    'all', // diagramType
                    diagramId // diagramId for editing
                );
            } catch (error) {
                alert(`Error viewing diagram: ${error.message}`);
            }
        }

        // Regenerate a saved diagram (regenerate based on stored element IDs)
        async function regenerateSavedDiagram(diagramId) {
            try {
                // First get the diagram to get its element IDs
                const diagramResponse = await fetch(`/api/diagrams/${diagramId}`);
                if (!diagramResponse.ok) {
                    throw new Error('Failed to load diagram');
                }
                
                const diagram = await diagramResponse.json();
                const elementIds = diagram.elements ? diagram.elements.map(e => e.id) : [];
                const elementNames = diagram.elements ? diagram.elements.map(e => e.name) : [];
                
                // Regenerate using the stored element names and enterprise filter
                // Preserve relationships flag - if the original diagram had relationships, include them
                const includeRelationships = (diagram.relationships_count || 0) > 0;
                
                const regenerateResponse = await fetch('/api/plantuml/from-chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        element_names: elementNames,
                        enterprise: diagram.enterprise_filter || null,
                        include_relationships: true, // Always include relationships
                        use_facets: true, // Default to using facets
                        include_notes: true, // Include notes by default
                        include_properties: true // Include properties by default
                    })
                });
                
                if (!regenerateResponse.ok) {
                    const error = await regenerateResponse.json();
                    alert(`Error regenerating diagram: ${error.error || 'Failed to regenerate diagram'}`);
                    return;
                }
                
                const newDiagramData = await regenerateResponse.json();
                
                // Display the regenerated diagram (preserve diagramId so title remains editable)
                // Pass includeRelationships flag to preserve it in the state
                displayPlantUMLDiagram(
                    newDiagramData.plantuml,
                    newDiagramData.encoded,
                    newDiagramData.elements_count,
                    newDiagramData.relationships_count,
                    diagram.title || 'Regenerated Diagram',
                    elementNames,
                    diagram.enterprise_filter || null,
                    newDiagramData.element_ids || [],
                    'from-chat', // Use from-chat diagramType to preserve relationship flags
                    diagramId, // Preserve diagramId for editing
                    true, // Always include relationships
                    false // includeRelated - false by default
                );
            } catch (error) {
                alert(`Error regenerating diagram: ${error.message}`);
            }
        }

        // Delete a saved diagram
        async function deleteSavedDiagram(diagramId) {
            if (!confirm('Are you sure you want to delete this saved diagram?')) {
                return;
            }
            
            try {
                // Include enterprise filter for repository scoping validation
                const enterpriseSelect = document.getElementById('enterpriseSelect');
                const enterprise = enterpriseSelect ? enterpriseSelect.value : '';
                const url = enterprise ? `/api/diagrams/${diagramId}?enterprise=${encodeURIComponent(enterprise)}` : `/api/diagrams/${diagramId}`;
                
                const response = await fetch(url, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    if (response.status === 403) {
                        alert(`Repository scoping violation: ${error.error || 'This diagram does not belong to the selected repository'}`);
                    } else {
                    alert(`Error deleting diagram: ${error.error || 'Failed to delete diagram'}`);
                    }
                    return;
                }
                
                // Reload diagrams list
                await loadSavedDiagrams();
                alert('Diagram deleted successfully!');
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }

        // Update diagram title (legacy function - now calls updateCurrentDiagram for saved diagrams)
        async function updateDiagramTitle(diagramId) {
            const titleInput = document.getElementById('diagramTitleInput');
            if (!titleInput) {
                return;
            }
            
            const newTitle = titleInput.value.trim();
            if (!newTitle) {
                alert('Diagram title cannot be empty');
                titleInput.value = window.currentDiagramState?.title || 'Untitled Diagram';
                return;
            }
            
            // Don't update if title hasn't changed
            if (newTitle === (window.currentDiagramState?.title || '')) {
                return;
            }
            
            // For saved diagrams, update the full diagram state with new title
            if (window.currentDiagramState && window.currentDiagramState.diagramId) {
                window.currentDiagramState.title = newTitle;
                // Use the full update function to save title along with any other changes
                await updateCurrentDiagram(diagramId, false); // false = don't show "changes saved" alert
                return;
            }
            
            // Legacy code path (shouldn't normally be reached)
            try {
                const response = await fetch(`/api/diagrams/${diagramId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        title: newTitle
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert(`Error updating diagram title: ${error.error || 'Failed to update title'}`);
                    titleInput.value = window.currentDiagramState?.title || 'Untitled Diagram';
                    return;
                }
                
                const updatedDiagram = await response.json();
                
                if (window.currentDiagramState) {
                    window.currentDiagramState.title = updatedDiagram.title;
                }
                
                await loadSavedDiagrams();
                
                const originalBg = titleInput.style.backgroundColor;
                titleInput.style.backgroundColor = '#4CAF50';
                setTimeout(() => {
                    titleInput.style.backgroundColor = originalBg;
                }, 300);
            } catch (error) {
                alert(`Error updating diagram title: ${error.message}`);
                titleInput.value = window.currentDiagramState?.title || 'Untitled Diagram';
            }
        }

        // Update current diagram (save changes to an existing saved diagram)
        async function updateCurrentDiagram(diagramId, showSuccessAlert = true) {
            const state = window.currentDiagramState;
            if (!state || !state.plantumlCode) {
                alert('No diagram changes to save');
                return;
            }
            
            // Get current title from input if available
            const titleInput = document.getElementById('diagramTitleInput');
            const title = titleInput ? titleInput.value.trim() : (state.title || 'Untitled Diagram');
            
            if (!title) {
                alert('Diagram title cannot be empty');
                if (titleInput) {
                    titleInput.value = state.title || 'Untitled Diagram';
                }
                return;
            }
            
            try {
                const encoded = state.encoded || '';
                
                // Prepare update data with all current state
                const updateData = {
                    title: title,
                    plantuml_code: state.plantumlCode,
                    encoded: encoded,
                    elements_count: state.elementsCount || 0,
                    relationships_count: state.relationshipsCount || 0,
                    enterprise_filter: state.enterpriseFilter || null,
                    element_ids: state.elementIds || []
                };
                
                const response = await fetch(`/api/diagrams/${diagramId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updateData)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert(`Error updating diagram: ${error.error || 'Failed to update diagram'}`);
                    return;
                }
                
                const updatedDiagram = await response.json();
                
                // Reload main screen diagrams to reflect updates
                loadSavedDiagramsForMain();
                
                // Update the stored state with the response
                if (window.currentDiagramState) {
                    window.currentDiagramState.title = updatedDiagram.title;
                    window.currentDiagramState.diagramId = updatedDiagram.id;
                }
                
                // Reload diagrams list to show updated diagram
                await loadSavedDiagrams();
                // Also reload main screen diagrams
                loadSavedDiagramsForMain();
                
                if (showSuccessAlert) {
                    // Show brief success feedback
                    const saveBtn = event?.target || document.querySelector('[onclick*="updateCurrentDiagram"]');
                    if (saveBtn) {
                        const originalText = saveBtn.querySelector('span')?.textContent || saveBtn.textContent;
                        const originalBg = saveBtn.style.backgroundColor;
                        saveBtn.style.backgroundColor = '#4CAF50';
                        if (saveBtn.querySelector('span')) {
                            saveBtn.querySelector('span').textContent = ' Saved!';
                        } else {
                            saveBtn.textContent = ' Saved!';
                        }
                        setTimeout(() => {
                            saveBtn.style.backgroundColor = originalBg;
                            if (saveBtn.querySelector('span')) {
                                saveBtn.querySelector('span').textContent = originalText;
                            } else {
                                saveBtn.textContent = originalText;
                            }
                        }, 2000);
                    }
                } else {
                    // Silent update for title-only changes
                    if (titleInput) {
                        const originalBg = titleInput.style.backgroundColor;
                        titleInput.style.backgroundColor = '#4CAF50';
                        setTimeout(() => {
                            titleInput.style.backgroundColor = originalBg;
                        }, 300);
                    }
                }
            } catch (error) {
                console.error('Error updating diagram:', error);
                alert(`Error: ${error.message}`);
            }
        }

        // Close PlantUML modal
        function closePlantUMLModal() {
            document.getElementById('plantumlModal').style.display = 'none';
        }

        // Save current diagram
        async function saveCurrentDiagram() {
            const state = window.currentDiagramState;
            if (!state || !state.plantumlCode) {
                alert('No diagram to save');
                return;
            }
            
            try {
                const encoded = state.encoded || '';
                const encodedWithPrefix = `~1${encoded}`;
                const plantumlUrl = `https://www.plantuml.com/plantuml/svg/${encodedWithPrefix}`;
                
                const response = await fetch('/api/diagrams', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        plantuml_code: state.plantumlCode,
                        title: state.title || 'PlantUML Diagram',
                        enterprise_filter: state.enterpriseFilter || null,
                        encoded: encoded,  // Store the raw encoded string
                        encoded_url: plantumlUrl,  // Store full URL for reference
                        elements_count: state.elementsCount || 0,
                        relationships_count: state.relationshipsCount || 0,
                        element_ids: state.elementIds || []
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert(`Error saving diagram: ${error.error || 'Failed to save diagram'}`);
                    return;
                }
                
                const savedDiagram = await response.json();
                // Update the diagram state with the new ID
                if (window.currentDiagramState) {
                    window.currentDiagramState.diagramId = savedDiagram.id;
                }
                window.lastViewedDiagramId = savedDiagram.id;
                localStorage.setItem('lastViewedDiagramId', savedDiagram.id.toString());
                
                // Reload main screen diagrams
                loadSavedDiagramsForMain();
                
                alert(`Diagram saved successfully! (ID: ${savedDiagram.id})`);
            } catch (error) {
                console.error('Error saving diagram:', error);
                alert(`Error: ${error.message}`);
            }
        }

        // Helper function to get tag image based on RAG type
        function getTagImageFromRAG(ragType) {
            if (!ragType) return null;
            const ragLower = ragType.toLowerCase().trim();
            // Check for new values first (Negative, Warning, Positive)
            if (ragLower === 'negative' || ragLower.startsWith('negative')) {
                return '/images/Tag-Red.svg';
            } else if (ragLower === 'warning' || ragLower.startsWith('warning')) {
                return '/images/Tag-Yellow.svg';
            } else if (ragLower === 'positive' || ragLower.startsWith('positive')) {
                return '/images/Tag-Green.svg';
            }
            // Backward compatibility with old values
            if (ragLower === 'red' || ragLower.startsWith('red')) {
                return '/images/Tag-Red.svg';
            } else if (ragLower === 'amber' || ragLower === 'yellow' || ragLower.startsWith('amber') || ragLower.startsWith('yellow')) {
                return '/images/Tag-Yellow.svg';
            } else if (ragLower === 'green' || ragLower.startsWith('green')) {
                return '/images/Tag-Green.svg';
            } else if (ragLower === 'black' || ragLower.startsWith('black')) {
                return '/images/Tag-Black.svg';
            }
            return null;
        }

        // Element Details functions
        async function showElementInstanceDetails(instanceId) {
            try {
                // Find the instance in allRecords
                let instance = allRecords.find(r => r.id === instanceId);
                if (!instance) {
                    // If not found, reload records and try again
                    await loadRecords();
                    instance = allRecords.find(r => r.id === instanceId);
                    if (!instance) {
                        throw new Error('Element instance not found');
                    }
                }
                
                // Set modal title
                document.getElementById('elementDetailsModalTitle').textContent = `Instance Details: ${instance.instance_name || 'Instance'}`;
                
                // Fetch properties for the element type (properties are assigned to element types, not instances)
                const propertiesResponse = await fetch(`/api/elements/${instance.element_type_id}/properties`);
                const properties = propertiesResponse.ok ? await propertiesResponse.json() : [];
                
                // Fetch rule violations for this element instance
                let violations = [];
                try {
                    const violationsResponse = await fetch(`/api/analytics/design-rules/violations?element_instance_id=${instanceId}`);
                    if (violationsResponse.ok) {
                        violations = await violationsResponse.json();
                    }
                } catch (error) {
                    console.error('Error loading violations:', error);
                }
                
                // Display element instance details and properties
                displayElementInstanceDetailsCard(instance, properties, violations);
                
                // Initialize property form fields after DOM update
                setTimeout(() => {
                    updatePropertyTypeFieldsInstance();
                }, 100);
                
                // Show modal
                document.getElementById('elementDetailsModal').style.display = 'block';
            } catch (error) {
                alert(`Error loading element instance details: ${error.message}`);
            }
        }
        
        // Keep old function for backward compatibility
        async function showElementDetails(elementId) {
            return showElementInstanceDetails(elementId);
        }
        
        // Save element instance description from repository modal
        async function saveElementInstanceDescriptionRepository(instanceId) {
            const descriptionInput = document.getElementById('elementInstanceDescriptionRepository');
            const description = descriptionInput ? descriptionInput.value.trim() : '';
            
            try {
                const response = await fetch(`/api/canvas/element-instances/${instanceId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ description: description })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to save description');
                }
                
                // Update the instance in allRecords if it exists
                const instanceIndex = allRecords.findIndex(r => r.id === instanceId);
                if (instanceIndex !== -1) {
                    allRecords[instanceIndex].description = description;
                }
                
                alert('Element instance description saved successfully');
                // Reload the instance details to show updated data
                await showElementInstanceDetails(instanceId);
            } catch (error) {
                alert('Error saving description: ' + error.message);
            }
        }

        function displayElementInstanceDetailsCard(instance, properties, violations = []) {
            const facetIcon = instance.facet ? getFacetIcon(instance.facet) : null;
            const content = document.getElementById('elementDetailsContent');
            const isDarkTheme = document.body.classList.contains('dark-theme');
            const cardBg = isDarkTheme ? '#2d2d30' : '#ffffff';
            const textColor = isDarkTheme ? '#e0e0e0' : '#202020';
            const borderColor = isDarkTheme ? '#3e3e42' : '#e5e5e5';
            const labelColor = isDarkTheme ? '#cccccc' : '#202020';
            const descColor = isDarkTheme ? '#b0b0d0' : '#666666';
            
            content.innerHTML = `
                <!-- Element Instance Information Card -->
                <div style="background: ${cardBg}; border-radius: 8px; padding: 20px; margin-bottom: 20px; border: 1px solid ${borderColor};">
                    <h3 style="color: ${textColor}; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                        ${instance.image_url ? `<img src="${escapeHtml(instance.image_url)}" alt="Instance" style="width: 48px; height: 48px; object-fit: contain;">` : ''}
                        <span>Element Instance Information</span>
                    </h3>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                        <div class="record-field">
                            <strong>Instance ID:</strong> <span>#${instance.id}</span>
                        </div>
                        <div class="record-field">
                            <strong>Instance Name:</strong> <span>${escapeHtml(instance.instance_name || 'N/A')}</span>
                        </div>
                        <div class="record-field">
                            <strong>Element Type:</strong> <span>${escapeHtml(instance.element_type || 'N/A')}</span>
                        </div>
                        ${instance.enterprise ? `
                        <div class="record-field">
                            <strong>Enterprise:</strong> <span>${escapeHtml(instance.enterprise)}</span>
                        </div>
                        ` : ''}
                        ${instance.facet ? `
                        <div class="record-field">
                            <strong>Facet:</strong> <span>
                                ${facetIcon ? `<img src="${facetIcon}" alt="${escapeHtml(instance.facet)}" onerror="this.style.display='none';" style="width: 24px; height: 24px; vertical-align: middle; margin-right: 6px; object-fit: contain;">` : ''}
                                ${escapeHtml(instance.facet)}
                            </span>
                        </div>
                        ` : ''}
                        ${instance.model_name ? `
                        <div class="record-field">
                            <strong>Model:</strong> <span>${escapeHtml(instance.model_name)}</span>
                        </div>
                        ` : ''}
                        <div class="record-field">
                            <strong>Position:</strong> <span>(${instance.x_position || 0}, ${instance.y_position || 0})</span>
                        </div>
                        <div class="record-field">
                            <strong>Created:</strong> <span>${new Date(instance.created_at).toLocaleString()}</span>
                        </div>
                        ${instance.updated_at ? `
                        <div class="record-field">
                            <strong>Updated:</strong> <span>${new Date(instance.updated_at).toLocaleString()}</span>
                    </div>
                    ` : ''}
                    </div>
                </div>
                
                <!-- Rule Violations Card -->
                ${violations && violations.length > 0 ? `
                <div style="background: ${cardBg}; border-radius: 8px; padding: 20px; margin-bottom: 20px; border: 1px solid ${borderColor};">
                    <h3 style="color: ${textColor}; margin-bottom: 15px;">Design Rule Violations (${violations.length})</h3>
                    <div style="display: grid; gap: 12px;">
                        ${violations.map(violation => {
                            const severityColor = violation.severity === 'negative' ? '#d13438' : '#ffaa44';
                            const severityBg = violation.severity === 'negative' ? 'rgba(209, 52, 56, 0.1)' : 'rgba(255, 170, 68, 0.1)';
                            return `
                            <div style="background: ${severityBg}; border-radius: 6px; padding: 12px; border-left: 4px solid ${severityColor};">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <span style="background: ${severityColor}; color: #ffffff; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; text-transform: uppercase;">${escapeHtml(violation.severity)}</span>
                                    <strong style="color: ${textColor}; font-size: 14px;">${escapeHtml(violation.rule_name)}</strong>
                                </div>
                                <div style="color: ${descColor}; font-size: 13px;">
                                    Current value: <strong style="color: ${textColor};">${violation.current_value}</strong> (threshold: ${violation.threshold_value}+)
                                </div>
                            </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                ` : ''}
                
                <!-- Element Instance Properties Card -->
                <div style="background: ${cardBg}; border-radius: 8px; padding: 20px; border: 1px solid ${borderColor};">
                    <h3 style="color: ${textColor}; margin-bottom: 15px;">Properties Assigned to Instance (${properties.length})</h3>
                    <p style="color: ${descColor}; font-size: 13px; margin-bottom: 15px;">These properties are inherited from the element type "${escapeHtml(instance.element_type || 'Unknown')}"</p>
                    ${properties.length === 0 ? `
                    <div class="empty-state">No properties assigned to this element type.</div>
                    ` : `
                    <div style="display: grid; gap: 12px;">
                        ${properties.map(prop => {
                            const tagImage = getTagImageFromRAG(prop.ragtype) || prop.image_url;
                            const ragTypeBadge = prop.ragtype ? `<span style="background: #404060; color: #e0e0e0; padding: 4px 8px; border-radius: 4px; font-size: 11px; margin-right: 8px;">${escapeHtml(prop.ragtype)}</span>` : '';
                            const gearIcon = prop.source === 'rules_engine'
                                ? '<span style="display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; background: #ffffff; color: #000000; border-radius: 50%; font-size: 12px; box-shadow: 0 0 2px rgba(0,0,0,0.4);" title="Rules Engine">&#9881;</span>'
                                : '';
                            return `
                            <div style="background: ${isDarkTheme ? '#1e1e1e' : '#f5f5f5'}; border-radius: 8px; padding: 15px; border: 1px solid ${borderColor};">
                                <div style="display: flex; align-items: start; gap: 15px;">
                                    ${tagImage ? `
                                    <div style="flex-shrink: 0;">
                                        <img src="${escapeHtml(tagImage)}" alt="RAG Tag" style="width: 64px; height: 64px; border-radius: 4px; object-fit: contain;">
                                    </div>
                                    ` : ''}
                                    <div style="flex: 1; min-width: 0;">
                                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                            <strong style="color: ${textColor}; font-size: 14px;">${escapeHtml(prop.propertyname || 'Unnamed Property')}</strong>
                                            ${gearIcon}
                                            ${ragTypeBadge}
                                        </div>
                                        ${prop.description ? `
                                        <div style="color: ${descColor}; font-size: 13px; line-height: 1.5;">
                                            ${escapeHtml(prop.description)}
                                        </div>
                                        ` : ''}
                                    </div>
                                </div>
                            </div>
                            `;
                        }).join('')}
                    </div>
                    `}
                </div>
                
                <!-- Create New Property Section -->
                <div style="background: ${cardBg}; border-radius: 8px; padding: 20px; margin-top: 20px; border: 1px solid ${borderColor};">
                    <h3 style="color: ${textColor}; margin-bottom: 15px;">Create New Property for Element Type</h3>
                    <p style="color: ${descColor}; font-size: 13px; margin-bottom: 15px;">Add a new property to the element type "${escapeHtml(instance.element_type || 'Unknown')}". This property will be available for all instances of this element type.</p>
                    <form id="addPropertyFormInstance" onsubmit="addPropertyFromInstance(event, ${instance.element_type_id})">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                            <div>
                                <label style="display: block; color: #b0b0d0; margin-bottom: 5px; font-size: 13px;">Property Type</label>
                                <select id="propertyTypeInstance" onchange="updatePropertyTypeFieldsInstance()" style="width: 100%; padding: 8px; border: 1px solid #404060; border-radius: 4px; background: #1a1a2e; color: #e0e0e0; font-size: 13px;">
                                    <option value="text">Text</option>
                                    <option value="numeric">Numeric</option>
                                    <option value="date">Date</option>
                                    <option value="link">Link (URL)</option>
                                </select>
                            </div>
                            <div>
                                <label style="display: block; color: #b0b0d0; margin-bottom: 5px; font-size: 13px;">RAG Type</label>
                                <select id="propertyRagTypeInstance" onchange="updatePropertyTagPreviewInstance()" style="width: 100%; padding: 8px; border: 1px solid #404060; border-radius: 4px; background: #1a1a2e; color: #e0e0e0; font-size: 13px;">
                                    <option value="">Select RAG Type</option>
                                    <option value="Negative">Negative</option>
                                    <option value="Warning">Warning</option>
                                    <option value="Positive">Positive</option>
                                    <option value="Black">Black</option>
                                </select>
                                <div id="ragTagPreviewInstance" style="margin-top: 8px; display: none;">
                                    <img id="ragTagPreviewImgInstance" src="" alt="RAG Tag" style="width: 64px; height: 64px; border-radius: 4px; object-fit: contain;">
                                </div>
                            </div>
                            <div>
                                <label style="display: block; color: #b0b0d0; margin-bottom: 5px; font-size: 13px;">Property Name *</label>
                                <input type="text" id="propertyNameInstance" required style="width: 100%; padding: 8px; border: 1px solid #404060; border-radius: 4px; background: #1a1a2e; color: #e0e0e0; font-size: 13px;">
                            </div>
                            <div>
                                <label style="display: block; color: #b0b0d0; margin-bottom: 5px; font-size: 13px;">Image URL (Optional - auto-set from RAG type)</label>
                                <input type="text" id="propertyImageUrlInstance" readonly style="width: 100%; padding: 8px; border: 1px solid #404060; border-radius: 4px; background: #2d2d44; color: #b0b0d0; font-size: 13px; cursor: not-allowed;" placeholder="Auto-set based on RAG type">
                            </div>
                        </div>
                        <div id="propertyTypeSpecificFieldsInstance" style="margin-bottom: 15px;">
                            <!-- Type-specific fields will be shown here -->
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; color: #b0b0d0; margin-bottom: 5px; font-size: 13px;">Description</label>
                            <textarea id="propertyDescriptionInstance" rows="3" style="width: 100%; padding: 8px; border: 1px solid #404060; border-radius: 4px; background: #1a1a2e; color: #e0e0e0; font-size: 13px; resize: vertical;"></textarea>
                        </div>
                        <button type="submit" style="background: #808080; color: #ffffff; border: none; padding: 10px 20px; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: pointer; width: 100%;">
                            <span>Create New Property</span>
                        </button>
                    </form>
                </div>
            `;
        }
        
        // Keep old function for backward compatibility
        function displayElementDetailsCard(element, properties) {
            return displayElementInstanceDetailsCard(element, properties);
        }
        
        // Add property from instance details modal
        async function addPropertyFromInstance(event, elementTypeId) {
            event.preventDefault();
            
            const ragType = document.getElementById('propertyRagTypeInstance').value.trim();
            const propertyName = document.getElementById('propertyNameInstance').value.trim();
            const description = document.getElementById('propertyDescriptionInstance').value.trim();
            
            // Automatically set image URL based on RAG type
            const tagImage = getTagImageFromRAG(ragType);
            const imageUrl = tagImage || document.getElementById('propertyImageUrlInstance').value.trim();
            
            if (!propertyName) {
                alert('Please enter a property name');
                return;
            }
            
            try {
                // Get property type and type-specific data
                const propertyType = document.getElementById('propertyTypeInstance')?.value || 'text';
                const propertyData = {
                    ragtype: ragType || null,
                    propertyname: propertyName,
                    description: description || null,
                    image_url: imageUrl || null,
                    property_type: propertyType
                };
                
                // Add type-specific data
                if (propertyType === 'numeric') {
                    const minValue = document.getElementById('propertyMinValueInstance')?.value;
                    const maxValue = document.getElementById('propertyMaxValueInstance')?.value;
                    const unit = document.getElementById('propertyUnitInstance')?.value;
                    if (minValue) propertyData.min_value = parseFloat(minValue);
                    if (maxValue) propertyData.max_value = parseFloat(maxValue);
                    if (unit) propertyData.unit = unit;
                } else if (propertyType === 'date') {
                    const dateValue = document.getElementById('propertyDateValueInstance')?.value;
                    const hasReminder = document.getElementById('propertyHasReminderInstance')?.checked;
                    const reminderDays = document.getElementById('propertyReminderDaysInstance')?.value;
                    if (dateValue) propertyData.default_value = dateValue;
                    if (hasReminder && reminderDays) {
                        propertyData.has_reminder = true;
                        propertyData.reminder_days = parseInt(reminderDays);
                    }
                } else if (propertyType === 'link') {
                    const linkUrl = document.getElementById('propertyLinkUrlInstance')?.value;
                    if (linkUrl) propertyData.link_url = linkUrl;
                }
                
                const response = await fetch(`/api/elements/${elementTypeId}/properties`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(propertyData)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert(`Error adding property: ${error.error || 'Failed to add property'}`);
                    return;
                }
                
                // Reload the element instance details to show the new property
                const instance = allRecords.find(r => r.element_type_id === elementTypeId);
                if (instance) {
                    await showElementInstanceDetails(instance.id);
                }
                
                // Reset form
                document.getElementById('addPropertyFormInstance').reset();
            } catch (error) {
                console.error('Error adding property:', error);
                alert(`Error: ${error.message}`);
            }
        }
        
        // Update property type fields for instance form
        function updatePropertyTypeFieldsInstance() {
            const propertyType = document.getElementById('propertyTypeInstance')?.value || 'text';
            const fieldsContainer = document.getElementById('propertyTypeSpecificFieldsInstance');
            if (!fieldsContainer) return;
            
            fieldsContainer.innerHTML = '';
            
            if (propertyType === 'numeric') {
                fieldsContainer.innerHTML = `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                        <div>
                            <label style="display: block; color: #b0b0d0; margin-bottom: 5px; font-size: 13px;">Min Value</label>
                            <input type="number" id="propertyMinValueInstance" step="any" style="width: 100%; padding: 8px; border: 1px solid #404060; border-radius: 4px; background: #1a1a2e; color: #e0e0e0; font-size: 13px;">
                        </div>
                        <div>
                            <label style="display: block; color: #b0b0d0; margin-bottom: 5px; font-size: 13px;">Max Value</label>
                            <input type="number" id="propertyMaxValueInstance" step="any" style="width: 100%; padding: 8px; border: 1px solid #404060; border-radius: 4px; background: #1a1a2e; color: #e0e0e0; font-size: 13px;">
                        </div>
                        <div>
                            <label style="display: block; color: #b0b0d0; margin-bottom: 5px; font-size: 13px;">Unit</label>
                            <input type="text" id="propertyUnitInstance" placeholder="e.g., kg, m, %" style="width: 100%; padding: 8px; border: 1px solid #404060; border-radius: 4px; background: #1a1a2e; color: #e0e0e0; font-size: 13px;">
                        </div>
                    </div>
                `;
            } else if (propertyType === 'date') {
                fieldsContainer.innerHTML = `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div>
                            <label style="display: block; color: #b0b0d0; margin-bottom: 5px; font-size: 13px;">Default Date</label>
                            <input type="date" id="propertyDateValueInstance" style="width: 100%; padding: 8px; border: 1px solid #404060; border-radius: 4px; background: #1a1a2e; color: #e0e0e0; font-size: 13px;">
                        </div>
                        <div>
                            <label style="display: flex; align-items: center; gap: 8px; color: #b0b0d0; margin-bottom: 5px; font-size: 13px; margin-top: 25px;">
                                <input type="checkbox" id="propertyHasReminderInstance" style="width: auto;">
                                <span>Enable Reminder</span>
                            </label>
                            <input type="number" id="propertyReminderDaysInstance" placeholder="Days before" min="1" style="width: 100%; padding: 8px; border: 1px solid #404060; border-radius: 4px; background: #1a1a2e; color: #e0e0e0; font-size: 13px; margin-top: 5px;">
                        </div>
                    </div>
                `;
            } else if (propertyType === 'link') {
                fieldsContainer.innerHTML = `
                    <div>
                        <label style="display: block; color: #b0b0d0; margin-bottom: 5px; font-size: 13px;">Default URL</label>
                        <input type="url" id="propertyLinkUrlInstance" placeholder="https://example.com" style="width: 100%; padding: 8px; border: 1px solid #404060; border-radius: 4px; background: #1a1a2e; color: #e0e0e0; font-size: 13px;">
                    </div>
                `;
            }
        }
        
        // Update property tag preview for instance form
        function updatePropertyTagPreviewInstance() {
            const ragType = document.getElementById('propertyRagTypeInstance')?.value;
            const previewDiv = document.getElementById('ragTagPreviewInstance');
            const previewImg = document.getElementById('ragTagPreviewImgInstance');
            const imageUrlInput = document.getElementById('propertyImageUrlInstance');
            
            if (!ragType || !previewDiv || !previewImg || !imageUrlInput) return;
            
            const tagImage = getTagImageFromRAG(ragType);
            if (tagImage) {
                previewImg.src = tagImage;
                previewDiv.style.display = 'block';
                imageUrlInput.value = tagImage;
            } else {
                previewDiv.style.display = 'none';
                imageUrlInput.value = '';
            }
        }

        function closeElementDetailsModal() {
            document.getElementById('elementDetailsModal').style.display = 'none';
        }

        // Element Properties functions
        async function showElementProperties(elementId, elementName) {
            document.getElementById('propertyElementId').value = elementId;
            document.getElementById('propertiesModalTitle').textContent = `Properties: ${elementName}`;
            document.getElementById('propertiesModal').style.display = 'block';
            await Promise.all([
                loadElementProperties(elementId),
                loadAvailablePropertiesForElement(elementId)
            ]);
        }

        function closePropertiesModal() {
            document.getElementById('propertiesModal').style.display = 'none';
            document.getElementById('addPropertyForm').reset();
        }

        async function loadElementProperties(elementId) {
            try {
                const response = await fetch(`/api/elements/${elementId}/properties`);
                if (!response.ok) {
                    throw new Error('Failed to load properties');
                }
                
                const properties = await response.json();
                const propertiesList = document.getElementById('propertiesList');
                
                if (properties.length === 0) {
                    propertiesList.innerHTML = '<div class="empty-state">No properties yet. Add one above!</div>';
                    return;
                }
                
                propertiesList.innerHTML = properties.map(prop => {
                    // Get tag image based on RAG type
                    const tagImage = getTagImageFromRAG(prop.ragtype) || prop.image_url;
                    const ragTypeBadge = prop.ragtype ? `<span style="background: #404060; color: #e0e0e0; padding: 4px 8px; border-radius: 4px; font-size: 11px; margin-right: 8px;">${escapeHtml(prop.ragtype)}</span>` : '';
                    return `
                    <div style="background: #2d2d44; border-radius: 8px; padding: 15px; margin-bottom: 10px; border: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                ${tagImage ? `<img src="${escapeHtml(tagImage)}" alt="RAG Tag" style="width: 64px; height: 64px; border-radius: 4px; object-fit: contain;">` : ''}
                                <div>
                                    <h4 style="color: #ffffff; margin: 0 0 5px 0;">${escapeHtml(prop.propertyname || 'Unnamed Property')}</h4>
                                    ${ragTypeBadge}
                                </div>
                            </div>
                            <button class="delete-btn" onclick="deleteProperty(${prop.id}, ${elementId})"><span>Delete</span>
                            </button>
                        </div>
                        ${prop.description ? `<p style="color: #b0b0d0; margin: 10px 0; font-size: 13px;">${escapeHtml(prop.description)}</p>` : ''}
                        <div style="color: #888; font-size: 11px; margin-top: 10px;">Created: ${new Date(prop.created_at).toLocaleString()}</div>
                    </div>
                `;
                }).join('');
            } catch (error) {
                document.getElementById('propertiesList').innerHTML = 
                    `<div class="empty-state">Error loading properties: ${error.message}</div>`;
            }
        }

        async function loadAvailablePropertiesForElement(elementId) {
            try {
                // Get all available properties
                const allPropsResponse = await fetch('/api/properties');
                if (!allPropsResponse.ok) {
                    throw new Error('Failed to load available properties');
                }
                const allProperties = await allPropsResponse.json();
                
                // Get current element's properties to exclude them
                const currentPropsResponse = await fetch(`/api/elements/${elementId}/properties`);
                const currentProperties = currentPropsResponse.ok ? await currentPropsResponse.json() : [];
                const currentPropertyNames = new Set(currentProperties.map(p => p.propertyname?.toLowerCase()));
                
                // Filter out properties already assigned to this element
                const availableProperties = allProperties.filter(prop => 
                    prop.propertyname && !currentPropertyNames.has(prop.propertyname.toLowerCase())
                );
                
                const availableList = document.getElementById('availablePropertiesList');
                
                if (availableProperties.length === 0) {
                    availableList.innerHTML = '<div class="empty-state" style="padding: 10px; text-align: center; color: #888;">No additional properties available. All existing properties are already assigned to this element.</div>';
                    return;
                }
                
                availableList.innerHTML = availableProperties.map(prop => {
                    const propData = JSON.stringify({
                        ragtype: prop.ragtype,
                        propertyname: prop.propertyname,
                        description: prop.description,
                        image_url: prop.image_url
                    });
                    const ragTypeBadge = prop.ragtype ? `<span style="background: #404060; color: #e0e0e0; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 8px;">${escapeHtml(prop.ragtype)}</span>` : '';
                    const usageInfo = prop.usage_count > 1 ? `<span style="color: #888; font-size: 11px; margin-left: 8px;">(used by ${prop.usage_count} element${prop.usage_count === 1 ? '' : 's'})</span>` : '';
                    return `
                        <label style="display: flex; align-items: center; padding: 8px; background: #1a1a2e; border-radius: 4px; cursor: pointer; transition: background 0.2s; border: 1px solid #404060;" onmouseover="this.style.background='#2d2d44'; this.style.borderColor='#505070'" onmouseout="this.style.background='#1a1a2e'; this.style.borderColor='#404060'">
                            <input type="checkbox" value='${escapeHtml(propData)}' style="margin-right: 10px; cursor: pointer;">
                            <div style="flex: 1;">
                                <div style="color: #e0e0e0; font-weight: 500; font-size: 13px;">
                                    ${escapeHtml(prop.propertyname || 'Unnamed Property')}
                                    ${ragTypeBadge}
                                    ${usageInfo}
                                </div>
                                ${prop.description ? `<div style="color: #b0b0d0; font-size: 11px; margin-top: 4px;">${escapeHtml(prop.description.substring(0, 100))}${prop.description.length > 100 ? '...' : ''}</div>` : ''}
                            </div>
                        </label>
                    `;
                }).join('');
            } catch (error) {
                document.getElementById('availablePropertiesList').innerHTML = 
                    `<div class="empty-state" style="padding: 10px; text-align: center; color: #f44336;">Error loading properties: ${error.message}</div>`;
            }
        }

        async function assignSelectedProperties() {
            const elementId = parseInt(document.getElementById('propertyElementId').value);
            if (!elementId) {
                alert('Element ID not found');
                return;
            }
            
            // Get selected properties
            const checkboxes = document.querySelectorAll('#availablePropertiesList input[type="checkbox"]:checked');
            if (checkboxes.length === 0) {
                alert('Please select at least one property to assign');
                return;
            }
            
            const selectedProperties = [];
            checkboxes.forEach(checkbox => {
                const propData = JSON.parse(checkbox.value);
                // Ensure image_url is set based on RAG type
                const tagImage = getTagImageFromRAG(propData.ragtype) || propData.image_url;
                selectedProperties.push({
                    ragtype: propData.ragtype || null,
                    propertyname: propData.propertyname,
                    description: propData.description || null,
                    image_url: tagImage || null
                });
            });
            
            try {
                // Assign each property
                let successCount = 0;
                let errorCount = 0;
                
                for (const prop of selectedProperties) {
                    try {
                        const response = await fetch(`/api/elements/${elementId}/properties`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(prop)
                        });
                        
                        if (response.ok) {
                            successCount++;
                        } else {
                            errorCount++;
                        }
                    } catch (error) {
                        errorCount++;
                    }
                }
                
                // Reload both lists
                await Promise.all([
                    loadElementProperties(elementId),
                    loadAvailablePropertiesForElement(elementId)
                ]);
                
                if (errorCount === 0) {
                    alert(`Successfully assigned ${successCount} propert${successCount === 1 ? 'y' : 'ies'} to this element!`);
                } else {
                    alert(`Assigned ${successCount} propert${successCount === 1 ? 'y' : 'ies'}, but ${errorCount} failed.`);
                }
            } catch (error) {
                console.error('Error assigning properties:', error);
                alert(`Error: ${error.message}`);
            }
        }

        // Update tag preview when RAG type changes
        function updatePropertyTagPreview() {
            const ragType = document.getElementById('propertyRagType').value;
            const tagImage = getTagImageFromRAG(ragType);
            const previewDiv = document.getElementById('ragTagPreview');
            const previewImg = document.getElementById('ragTagPreviewImg');
            const imageUrlInput = document.getElementById('propertyImageUrl');
            
            if (tagImage) {
                previewImg.src = tagImage;
                previewDiv.style.display = 'block';
                imageUrlInput.value = tagImage;
            } else {
                previewDiv.style.display = 'none';
                imageUrlInput.value = '';
            }
        }

        async function addProperty(event) {
            event.preventDefault();
            
            const elementId = parseInt(document.getElementById('propertyElementId').value);
            const ragType = document.getElementById('propertyRagType').value.trim();
            const propertyName = document.getElementById('propertyName').value.trim();
            const description = document.getElementById('propertyDescription').value.trim();
            
            // Automatically set image URL based on RAG type
            const tagImage = getTagImageFromRAG(ragType);
            const imageUrl = tagImage || document.getElementById('propertyImageUrl').value.trim();
            
            if (!propertyName) {
                alert('Please enter a property name');
                return;
            }
            
            try {
                // Get property type and type-specific data
                const propertyType = document.getElementById('propertyType')?.value || 'text';
                const propertyData = {
                    ragtype: ragType || null,
                    propertyname: propertyName,
                    description: description || null,
                    image_url: imageUrl || null,
                    property_type: propertyType
                };
                
                // Add type-specific data
                if (propertyType === 'numeric') {
                    const minValue = document.getElementById('propertyMinValue')?.value;
                    const maxValue = document.getElementById('propertyMaxValue')?.value;
                    const unit = document.getElementById('propertyUnit')?.value;
                    if (minValue) propertyData.min_value = parseFloat(minValue);
                    if (maxValue) propertyData.max_value = parseFloat(maxValue);
                    if (unit) propertyData.unit = unit;
                } else if (propertyType === 'date') {
                    const dateValue = document.getElementById('propertyDateValue')?.value;
                    const hasReminder = document.getElementById('propertyHasReminder')?.checked;
                    const reminderDays = document.getElementById('propertyReminderDays')?.value;
                    if (dateValue) propertyData.default_value = dateValue;
                    if (hasReminder && reminderDays) {
                        propertyData.has_reminder = true;
                        propertyData.reminder_days = parseInt(reminderDays);
                    }
                } else if (propertyType === 'link') {
                    const linkUrl = document.getElementById('propertyLinkUrl')?.value;
                    if (linkUrl) propertyData.link_url = linkUrl;
                }
                
                const response = await fetch(`/api/elements/${elementId}/properties`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(propertyData)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert(`Error adding property: ${error.error || 'Failed to add property'}`);
                    return;
                }
                
                // Reload both lists
                await Promise.all([
                    loadElementProperties(elementId),
                    loadAvailablePropertiesForElement(elementId)
                ]);
                
                // Reset form
                document.getElementById('addPropertyForm').reset();
                document.getElementById('propertyElementId').value = elementId;
            } catch (error) {
                console.error('Error adding property:', error);
                alert(`Error: ${error.message}`);
            }
        }

        async function deleteProperty(propertyId, elementId) {
            if (!confirm('Are you sure you want to delete this property?')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/elements/${elementId}/properties/${propertyId}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert(`Error deleting property: ${error.error || 'Failed to delete property'}`);
                    return;
                }
                
                // Reload both lists
                await Promise.all([
                    loadElementProperties(elementId),
                    loadAvailablePropertiesForElement(elementId)
                ]);
            } catch (error) {
                console.error('Error deleting property:', error);
                alert(`Error: ${error.message}`);
            }
        }

        // Encode PlantUML code for URL (client-side)
        function encodePlantUML(text) {
            // Use pako library if available, otherwise use a simple approach
            // For now, we'll use a simple base64 encoding approach
            // Note: This is a simplified version - PlantUML uses deflate compression
            // For production, you'd want to use a library like pako for deflate
            try {
                // Try to use the browser's built-in compression if available
                // Otherwise, we'll need to make an API call or use a library
                // For simplicity, let's make an API call to re-encode
                return null; // Will trigger API call
            } catch (e) {
                console.error('Encoding error:', e);
                return null;
            }
        }

        // Unified function to regenerate diagram with all current settings
        async function regenerateDiagramWithSettings() {
            if (!window.currentDiagramState) {
                console.error('No diagram state available');
                return;
            }
            
            try {
                const state = window.currentDiagramState;
                const themeSelect = document.getElementById('diagramTheme');
                const librarySelect = document.getElementById('diagramLibrary');
                const useFacetsCheckbox = document.getElementById('diagramUseFacets');
                const includeNotesCheckbox = document.getElementById('diagramIncludeNotes');
                const includePropertiesCheckbox = document.getElementById('diagramIncludeProperties');
                
                const selectedTheme = themeSelect ? themeSelect.value : 'default';
                const selectedLibrary = librarySelect ? librarySelect.value : 'edgy/edgy';
                const useFacets = useFacetsCheckbox ? useFacetsCheckbox.checked : false;
                const includeNotes = includeNotesCheckbox ? includeNotesCheckbox.checked : false;
                const includeProperties = includePropertiesCheckbox ? includePropertiesCheckbox.checked : false;
                
                // Use unified /api/plantuml/from-chat endpoint for all diagram types
                const url = '/api/plantuml/from-chat';
                const method = 'POST';
                
                // Determine facet filter based on diagram type
                let facetFilter = null;
                const diagramType = state.diagramType || (state.elementNames && state.elementNames.length > 0 ? 'from-chat' : 'all');
                if (diagramType === 'architecture') {
                    facetFilter = 'Architecture';
                } else if (diagramType === 'identity') {
                    facetFilter = 'Identity';
                }
                
                const body = JSON.stringify({
                    element_names: state.elementNames || [],
                        enterprise: state.enterpriseFilter,
                    facet_filter: facetFilter, // Filter by facet if specified
                    use_facets: useFacets,
                    include_relationships: true, // Always include relationships
                    include_related: state.includeRelated !== undefined ? state.includeRelated : false, // Preserve include related flag
                    include_notes: includeNotes, // Include notes with element descriptions
                    include_properties: includeProperties // Include notes with element properties
                });
                
                const response = await fetch(url, {
                    method: method,
                    headers: method === 'POST' ? { 'Content-Type': 'application/json' } : {},
                    body: body
                });
                
                if (!response.ok) {
                    throw new Error('Failed to regenerate diagram');
                }
                
                const data = await response.json();
                
                // Get base code and apply theme and library
                let plantumlCode = data.plantuml;
                
                // Remove existing theme and library directives
                plantumlCode = plantumlCode.replace(/!theme\s+\w+\n/g, '');
                plantumlCode = plantumlCode.replace(/!include\s+<edgy\/edgy\d*>\n/g, '');
                
                // Add theme if not default
                if (selectedTheme !== 'default') {
                    plantumlCode = plantumlCode.replace('@startuml\n', `@startuml\n!theme ${selectedTheme}\n`);
                }
                
                // Add library include (after @startuml and theme if present)
                if (plantumlCode.includes('!theme')) {
                    plantumlCode = plantumlCode.replace(/(!theme\s+\w+\n)/, `$1!include <${selectedLibrary}>\n`);
                } else {
                    plantumlCode = plantumlCode.replace('@startuml\n', `@startuml\n!include <${selectedLibrary}>\n`);
                }
                
                // Encode the final code
                const encodeResponse = await fetch('/api/plantuml/encode', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ code: plantumlCode })
                });
                
                if (!encodeResponse.ok) {
                    throw new Error('Failed to encode PlantUML code');
                }
                
                const encodeData = await encodeResponse.json();
                const encodedWithPrefix = `~1${encodeData.encoded}`;
                const plantumlUrl = `https://www.plantuml.com/plantuml/svg/${encodedWithPrefix}`;
                const plantumlEditorUrl = `https://www.plantuml.com/plantuml/uml/${encodedWithPrefix}`;
                const plantumlPngUrl = `https://www.plantuml.com/plantuml/png/${encodedWithPrefix}`;
                
                // Update stored code (code display is hidden, but we still store it for internal use)
                    window.plantumlCodeToCopy = plantumlCode;
                
                // Update preview image
                const diagramPreview = document.getElementById('diagramPreview');
                if (diagramPreview) {
                    diagramPreview.src = plantumlUrl;
                    diagramPreview.style.display = 'block';
                    document.getElementById('diagramError').style.display = 'none';
                    
                    // Reset zoom when diagram is regenerated
                    diagramZoomLevel = 100;
                    const zoomSlider = document.getElementById('diagramZoomSlider');
                    const zoomPercent = document.getElementById('diagramZoomPercent');
                    if (zoomSlider) zoomSlider.value = 100;
                    if (zoomPercent) zoomPercent.textContent = '100%';
                    diagramPreview.style.transform = 'scale(1)';
                    diagramPreview.style.maxWidth = 'none';
                }
                
                // Update download links
                const editorLink = document.querySelector('a[href*="plantuml.com/plantuml/uml/"]');
                const svgLink = document.querySelector('a[href*="plantuml.com/plantuml/svg/"]');
                const pngLink = document.querySelector('a[href*="plantuml.com/plantuml/png/"]');
                
                if (editorLink) editorLink.href = plantumlEditorUrl;
                if (svgLink) svgLink.href = plantumlUrl;
                if (pngLink) pngLink.href = plantumlPngUrl;
                
                // Update stored state
                if (window.currentDiagramState) {
                    window.currentDiagramState.plantumlCode = data.plantuml; // Store base code
                    window.currentDiagramState.encoded = encodeData.encoded;
                    window.currentDiagramState.currentTheme = selectedTheme;
                    window.currentDiagramState.currentLibrary = selectedLibrary;
                    window.currentDiagramState.useFacets = useFacets;
                    window.currentDiagramState.diagramType = diagramType; // Preserve diagram type
                    // Preserve diagramId if it exists (for saved diagrams)
                    if (state.diagramId) {
                        window.currentDiagramState.diagramId = state.diagramId;
                    }
                    // Update relationship flags from checkbox (for from-chat diagrams) or infer from response
                    // For regular endpoints (all, architecture, identity), relationships are always included
                    if (diagramType === 'from-chat') {
                        // For from-chat diagrams, use the checkbox value
                        window.currentDiagramState.includeRelationships = true; // Always include relationships
                        if (state.includeRelated !== undefined) {
                            window.currentDiagramState.includeRelated = state.includeRelated;
                        }
                    } else {
                        // For regular endpoints, relationships are always included
                        window.currentDiagramState.includeRelationships = true;
                    }
                    // Update relationships count from response
                    if (data.relationships_count !== undefined) {
                        window.currentDiagramState.relationshipsCount = data.relationships_count;
                    }
                    // Update elements count and IDs from response if available
                    if (data.elements_count !== undefined) {
                        window.currentDiagramState.elementsCount = data.elements_count;
                    }
                    if (data.element_ids !== undefined) {
                        window.currentDiagramState.elementIds = data.element_ids;
                    }
                }
            } catch (error) {
                console.error('Error regenerating diagram:', error);
                alert('Error regenerating diagram: ' + error.message);
                throw error;
            }
        }

        // Change diagram theme
        async function changeDiagramTheme() {
            try {
                await regenerateDiagramWithSettings();
            } catch (error) {
                // Error already handled in regenerateDiagramWithSettings
            }
        }

        // Change diagram library
        async function changeDiagramLibrary() {
            try {
                await regenerateDiagramWithSettings();
            } catch (error) {
                // Error already handled in regenerateDiagramWithSettings
            }
        }

        // Change diagram relationships (include/exclude relationships)
        async function changeDiagramRelationships() {
            const includeRelationshipsCheckbox = document.getElementById('diagramIncludeRelationships');
            const originalValue = !includeRelationshipsCheckbox.checked; // Store original value
            
            try {
                await regenerateDiagramWithSettings();
            } catch (error) {
                // Revert checkbox on error
                includeRelationshipsCheckbox.checked = originalValue;
                // Error already handled in regenerateDiagramWithSettings
            }
        }

        // Change diagram facets (regenerate from server)
        async function changeDiagramFacets() {
            const useFacetsCheckbox = document.getElementById('diagramUseFacets');
            const originalValue = !useFacetsCheckbox.checked; // Store original value
            
            try {
                await regenerateDiagramWithSettings();
            } catch (error) {
                // Revert checkbox on error
                useFacetsCheckbox.checked = originalValue;
                // Error already handled in regenerateDiagramWithSettings
            }
        }

        // Change diagram relationships (include/exclude relationships)
        async function changeDiagramRelationships() {
            const includeRelationshipsCheckbox = document.getElementById('diagramIncludeRelationships');
            const originalValue = !includeRelationshipsCheckbox.checked; // Store original value
            
            try {
                await regenerateDiagramWithSettings();
            } catch (error) {
                // Revert checkbox on error
                includeRelationshipsCheckbox.checked = originalValue;
                // Error already handled in regenerateDiagramWithSettings
            }
        }

        // Copy PlantUML code to clipboard (code display is hidden, but function kept for potential future use)
        function copyPlantUMLCode() {
            const text = window.plantumlCodeToCopy || '';
            
            navigator.clipboard.writeText(text).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = ' Copied!';
                btn.style.background = '#666666';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#808080';
                }, 2000);
            }).catch(err => {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    const btn = event.target;
                    const originalText = btn.textContent;
                    btn.textContent = ' Copied!';
                    btn.style.background = '#4CAF50';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '#2196F3';
                    }, 2000);
                } catch (e) {
                    alert('Failed to copy: ' + e);
                }
                document.body.removeChild(textarea);
            });
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const plantumlModal = document.getElementById('plantumlModal');
            const propertiesModal = document.getElementById('propertiesModal');
            const elementDetailsModal = document.getElementById('elementDetailsModal');
            const relationshipDetailsModal = document.getElementById('relationshipDetailsModal');
            if (event.target == plantumlModal) {
                closePlantUMLModal();
            }
            if (event.target == propertiesModal) {
                closePropertiesModal();
            }
            if (event.target == elementDetailsModal) {
                closeElementDetailsModal();
            }
            if (event.target == relationshipDetailsModal) {
                closeRelationshipDetailsModal();
            }
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Chatbot functionality
        function handleChatKeyPress(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            }
        }

        function askQuestion(question) {
            document.getElementById('chatInput').value = question;
            sendChatMessage();
        }

        async function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Clear input
            input.value = '';
            input.disabled = true;
            const sendBtn = document.querySelector('.chat-send-btn');
            sendBtn.disabled = true;
            
            // Add user message
            addChatMessage(message, 'user');
            
            // Show typing indicator
            const typingId = addTypingIndicator();
            
            try {
                // Get enterprise filter if selected
                const enterpriseSelect = document.getElementById('chatbotEnterpriseSelect');
                const enterprise = enterpriseSelect ? enterpriseSelect.value : '';
                
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        question: message,
                        enterprise: enterprise || null
                    })
                });
                
                const data = await response.json();
                
                // Remove typing indicator
                removeTypingIndicator(typingId);
                
                // Check if user requested to open a saved diagram
                if (data.open_diagram) {
                    // User wants to open a saved diagram - call viewSavedDiagram
                    const diagramId = data.open_diagram;
                    const message = data.open_diagram_message || data.answer || 'Opening the diagram for you...';
                    addChatMessage(message, 'assistant');
                    // Small delay to allow message to render, then open diagram
                    setTimeout(() => {
                        viewSavedDiagram(diagramId);
                    }, 100);
                } else {
                    // Normal response handling
                // Add assistant response with mentioned elements for diagram generation
                const mentionedElements = data.mentioned_elements || null;
                // Diagram generation button removed - always false
                const canGenerateDiagram = false;
                    
                    // If diagram is included in response, add it to the answer
                    let answerText = data.answer || 'I apologize, but I encountered an error processing your question.';
                    
                    // Ensure answerText is a valid string
                    if (!answerText || typeof answerText !== 'string') {
                        console.error('[Chat] Invalid answer text received:', answerText);
                        answerText = 'I encountered an error processing your question. Please try again.';
                    }
                    
                    // Check if this is a template request with diagram data
                    const isTemplateRequest = data.is_template_request === true;
                    const hasDiagramData = data.diagram && data.diagram.plantuml_url;
                    const hasTemplateName = data.template_diagram_name && data.template_diagram_name.trim() !== '';
                    
                    // Determine if we should show template preview button
                    // Show button if: template request flag is true OR template name exists with diagram data
                    const shouldShowTemplateButton = isTemplateRequest && hasDiagramData;
                    
                    // For template requests, don't auto-embed diagram - show button instead
                    if (shouldShowTemplateButton) {
                        // Add a message about the template being used
                        if (hasTemplateName) {
                            answerText += `\n\n **Template Used:** "${data.template_diagram_name}"`;
                        }
                        answerText += `\n\n Found ${data.diagram.elements_count || 0} elements matching the template structure. Click the button below to preview the diagram.`;
                    } else if (hasDiagramData && !isTemplateRequest) {
                        // For regular diagram requests, embed diagram directly
                        answerText += `\n\n<div style="margin: 15px 0; text-align: center;"><img src="${data.diagram.plantuml_url}" alt="EDGY Diagram" style="max-width: 100%; height: auto; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;" onerror="this.style.display='none';"></div>`;
                    }
                    
                    // Add message with error handling
                    // Pass template diagram data if it's a template request OR if template name exists
                    // Also ensure template_used is set from template_diagram_name if not in diagram data
                    let templateDiagramDataToPass = shouldShowTemplateButton ? data.diagram : null;
                    
                    // If template name exists but diagram data doesn't have template_used, add it
                    if (hasTemplateName && templateDiagramDataToPass && !templateDiagramDataToPass.template_used) {
                        templateDiagramDataToPass = { ...templateDiagramDataToPass, template_used: data.template_diagram_name };
                    }
                    
                    // If template name exists but no diagram data, create minimal template data object
                    if (hasTemplateName && !templateDiagramDataToPass) {
                        templateDiagramDataToPass = { template_used: data.template_diagram_name };
                    }
                    
                    console.log('[Chat] Template request check:', {
                        isTemplateRequest,
                        hasDiagramData,
                        hasTemplateName,
                        shouldShowTemplateButton,
                        templateDiagramName: data.template_diagram_name,
                        templateDiagramDataToPass: templateDiagramDataToPass ? (templateDiagramDataToPass.template_used || 'no template_used') : 'null'
                    });
                    try {
                    addChatMessage(answerText, 'assistant', mentionedElements, canGenerateDiagram, templateDiagramDataToPass);
                    } catch (error) {
                        console.error('[Chat] Error adding chat message:', error);
                        // Fallback: add a simple error message
                        const errorMsg = document.createElement('div');
                        errorMsg.className = 'chat-message assistant';
                        errorMsg.innerHTML = `
                            <div class="chat-avatar"><img src="/images/ask-ed_OLD.svg" alt="Ask ED"></div>
                            <div class="chat-content">
                                <p>I encountered an error displaying the response. The answer was: ${escapeHtml(answerText.substring(0, 500))}</p>
                            </div>
                        `;
                        document.getElementById('chatMessages').appendChild(errorMsg);
                    }
                }
                
                // If diagram data is provided, also store it for potential modal display
                if (data.diagram) {
                    // Store diagram data in the message element for potential interaction
                    setTimeout(() => {
                        const messages = document.getElementById('chatMessages');
                        const lastMessage = messages.lastElementChild;
                        if (lastMessage && lastMessage.classList.contains('assistant')) {
                            lastMessage.dataset.diagramData = JSON.stringify(data.diagram);
                        }
                    }, 100);
                }
                
                // Diagrams are never auto-generated - users must manually click "Generate EDGY Diagram" button
                
            } catch (error) {
                removeTypingIndicator(typingId);
                addChatMessage('Sorry, I encountered an error. Please try again.', 'assistant');
            } finally {
                input.disabled = false;
                sendBtn.disabled = false;
                input.focus();
            }
        }

        
        // Prompt for user name and store it
        function promptForUserName() {
            const storedName = localStorage.getItem('userName');
            if (!storedName) {
                const name = prompt('Please enter your name:');
                if (name && name.trim()) {
                    const trimmedName = name.trim();
                    localStorage.setItem('userName', trimmedName);
                }
            }
        }
        
        // Get user initial for avatar
        function getUserInitial() {
            const userName = localStorage.getItem('userName');
            if (userName && userName.length > 0) {
                return userName.charAt(0).toUpperCase();
            }
            return '?';
        }
        
        // Attach click handler for diagram generation button
        function attachDiagramButtonHandler(btn, responseText, mentionedElements) {
            if (!btn || btn.hasAttribute('data-handler-attached')) {
                return; // Already attached or button doesn't exist
            }
            
            btn.setAttribute('data-handler-attached', 'true');
            btn.addEventListener('click', async function() {
                // Get response text from data attribute (stored when button was created)
                let text = this.getAttribute('data-response-text') || '';
                // Decode HTML entities
                text = text.replace(/&#39;/g, "'").replace(/&quot;/g, '"');
                
                // Also try to get from closure scope as fallback
                if (!text && typeof responseText !== 'undefined') {
                    text = responseText;
                }
                
                // Get template diagram name if available
                // Check for empty string explicitly - empty string means no template, null/undefined means not set
                const templateNameAttr = this.getAttribute('data-template-name');
                const templateDiagramName = (templateNameAttr && templateNameAttr.trim() !== '') ? templateNameAttr.trim() : null;
                
                console.log('[Diagram] Response text length:', text.length);
                console.log('[Diagram] Response text preview:', text.substring(0, 300));
                console.log('[Diagram] Template diagram name from button:', templateDiagramName);
                console.log('[Diagram] Raw data-template-name attribute:', templateNameAttr);
                console.log('[Diagram] All button data attributes:', {
                    'data-template-name': templateNameAttr,
                    'data-elements': this.getAttribute('data-elements') ? 'present' : 'missing',
                    'data-response-text': this.getAttribute('data-response-text') ? 'present' : 'missing'
                });
                
                const extractedElements = extractElementsFromResponse(text);
                
                // Use extracted elements if found, otherwise fall back to data-elements attribute
                const dataElements = JSON.parse(this.getAttribute('data-elements') || '[]');
                const elements = extractedElements.length > 0 
                    ? extractedElements 
                    : (dataElements.length > 0 ? dataElements : (mentionedElements || []));
                
                console.log('[Diagram] Extracted elements from response:', extractedElements);
                console.log('[Diagram] Data elements attribute:', dataElements);
                console.log('[Diagram] Final elements for diagram:', elements);
                
                if (elements.length === 0) {
                    alert('No elements found in the response. The ChatBot response may not have included specific element names. Please try asking about specific elements.');
                    return;
                }
                
                // Default behavior for manual button: include relationships and related elements
                // (user explicitly clicked the button, so they want a full diagram)
                generatePlantUMLFromChat(elements, true, true, templateDiagramName);
            });
        }
        
        // List elements with yellow/amber properties
        function addChatMessage(text, sender, mentionedElements = null, canGenerateDiagram = false, templateDiagramData = null) {
            console.log('[addChatMessage] Called with templateDiagramData:', templateDiagramData ? {
                hasTemplateUsed: !!templateDiagramData.template_used,
                templateUsed: templateDiagramData.template_used,
                keys: Object.keys(templateDiagramData)
            } : 'null');
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${sender}`;
            
            // Set avatar - user gets emoji, assistant gets image
            let avatarHtml;
            if (sender === 'user') {
                const initial = getUserInitial();
                avatarHtml = `<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; color: #ffffff;">${initial}</div>`;

            } else { avatarHtml = '<img src=\"/images/ask-ed_OLD.svg\" alt=\"EDGly\" style=\"width: 100%; height: 100%; object-fit: cover; border-radius: 50%;\">';
            }
            
            // Parse element image references in format [ELEMENT_IMAGE:element_name]
            const elementImageRegex = /\[ELEMENT_IMAGE:([^\]]+)\]/g;
            // Parse property image references in format [PROPERTY_IMAGE:image_url]
            const propertyImageRegex = /\[PROPERTY_IMAGE:([^\]]+)\]/g;
            
            // Check if there are any image references
            const hasImageRefs = elementImageRegex.test(text) || propertyImageRegex.test(text);
            elementImageRegex.lastIndex = 0; // Reset regex
            propertyImageRegex.lastIndex = 0; // Reset regex
            
            // Build initial content - SIMPLIFIED: if text contains HTML tables, use it directly
            let content;
            // Check if we're waiting for images (tables with image references)
            const isWaitingForImages = hasImageRefs && (text.includes('<table') || text.includes('<thead') || text.includes('<tbody'));
            
            // Simple function to process markdown in text portions only (not HTML)
            function processMarkdownInText(textPortion, wrapInParagraph = false) {
                if (!textPortion || !textPortion.trim()) {
                    return '';
                }
                
                // Don't process if already HTML
                if (textPortion.trim().startsWith('<p>') || textPortion.trim().startsWith('<div>') || textPortion.trim().startsWith('<strong>')) {
                    return textPortion;
                }
                
                // Split by double newlines to handle multiple paragraphs
                const paragraphs = textPortion.split(/\n\n+/).filter(p => p.trim());
                
                let processed = paragraphs.map(para => {
                    // Process markdown: bold and single newlines
                    let processedPara = escapeHtml(para.trim())
                        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                        .replace(/\n/g, '<br>');
                    return processedPara;
                });
                
                // Wrap in paragraph tags if requested
                if (wrapInParagraph && processed.length > 0) {
                    // If we have multiple paragraphs, wrap each separately
                    if (processed.length > 1) {
                        processed = processed.map(p => `<p>${p}</p>`);
            } else {
                        processed = [`<p>${processed[0]}</p>`];
                    }
                }
                
                return processed.join('');
            }
            
            // Helper function to process images with records (reusable for retry)
            function processImagesWithRecords(records, textToProcess) {
                console.log('[Chat] ===== IMAGE PROCESSING START =====');
                console.log('[Chat] Original text length:', textToProcess.length);
                console.log('[Chat] Original text contains table:', textToProcess.includes('<table'));
                console.log('[Chat] Records fetched:', records.length);
                
                let processedText = textToProcess;
                
                // Create a map of element names to image URLs for faster lookup
                const elementImageMap = new Map();
                records.forEach(record => {
                    if (record.name && record.image_url) {
                        const name = String(record.name).trim();
                        const imageUrl = String(record.image_url).trim();
                        if (name && imageUrl) {
                            // Store exact, trimmed, and lowercase versions for fast lookup
                            elementImageMap.set(name, imageUrl);
                            elementImageMap.set(name.toLowerCase(), imageUrl);
                            // Also store trimmed versions
                            const trimmedName = name.trim();
                            if (trimmedName !== name) {
                                elementImageMap.set(trimmedName, imageUrl);
                                elementImageMap.set(trimmedName.toLowerCase(), imageUrl);
                            }
                        }
                    }
                });
                
                console.log('[Chat] Element image map created with', elementImageMap.size, 'entries');
                console.log('[Chat] Sample entries:', Array.from(elementImageMap.entries()).slice(0, 5));
                
                // Process element image references - replace ALL occurrences of each placeholder
                const elementMatches = [...textToProcess.matchAll(/\[ELEMENT_IMAGE:([^\]]+)\]/g)];
                console.log('[Chat] Found element image placeholders:', elementMatches.length);
                console.log('[Chat] Placeholder names:', elementMatches.map(m => m[1]));
                
                        elementMatches.forEach(match => {
                    let elementName = match[1];
                    const placeholder = match[0]; // Full placeholder including brackets
                    console.log('[Chat] Looking for element:', elementName);
                    
                    // Trim whitespace from element name
                    elementName = elementName.trim();
                    
                    // Try multiple matching strategies
                    let imageUrl = elementImageMap.get(elementName) || 
                                  elementImageMap.get(elementName.toLowerCase()) ||
                                  elementImageMap.get(elementName.trim()) ||
                                  elementImageMap.get(elementName.trim().toLowerCase());
                    
                    // If still not found, try case-insensitive partial match
                    if (!imageUrl) {
                        for (const [mapName, mapUrl] of elementImageMap.entries()) {
                            if (mapName.toLowerCase() === elementName.toLowerCase() || 
                                elementName.toLowerCase() === mapName.toLowerCase()) {
                                imageUrl = mapUrl;
                                console.log('[Chat] Found match via case-insensitive comparison:', mapName, '->', elementName);
                                break;
                            }
                        }
                    }
                    
                    if (imageUrl) {
                        // Don't escape the URL - it's already safe for HTML attributes
                        // Only escape quotes to prevent breaking the src attribute
                        const imageHtml = `<img src="${imageUrl.replace(/"/g, '&quot;')}" alt="${escapeHtml(elementName)}" style="width: 64px; height: 64px; vertical-align: middle; margin: 0 4px; display: inline-block; object-fit: contain;" onerror="this.style.display='none'; console.error('Image failed to load:', this.src);">`;
                        // Replace ALL occurrences of this placeholder (not just first)
                        const placeholderRegex = new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                        processedText = processedText.replace(placeholderRegex, imageHtml);
                        console.log('[Chat]  Replaced ELEMENT_IMAGE for:', elementName, 'with URL:', imageUrl);
                            } else {
                        // Debug: log available names for troubleshooting
                        console.warn('[Chat]  No image_url found for element:', elementName);
                        console.warn('[Chat] Available element names in map:', Array.from(elementImageMap.keys()).slice(0, 10));
                        // Replace ALL occurrences with element name if image not found
                        const placeholderRegex = new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                        processedText = processedText.replace(placeholderRegex, elementName);
                    }
                });
                
                // Process property image references - replace ALL occurrences of each placeholder
                        const propertyMatches = [...processedText.matchAll(/\[PROPERTY_IMAGE:([^\]]+)\]/g)];
                console.log('[Chat] Found property image placeholders:', propertyMatches.length);
                        propertyMatches.forEach(match => {
                    let imageUrl = match[1];
                    const placeholder = match[0]; // Full placeholder including brackets
                    console.log('[Chat] Processing PROPERTY_IMAGE with URL:', imageUrl);
                    
                    // Handle escaped brackets in URL (&#93; -> ]) if present
                    if (imageUrl.includes('&#93;')) {
                        imageUrl = imageUrl.replace(/&#93;/g, ']');
                        console.log('[Chat] Unescaped brackets in property image URL');
                    }
                    
                    if (imageUrl && imageUrl.trim()) {
                        // Don't escape the URL - it's already safe for HTML attributes
                        // Only escape quotes to prevent breaking the src attribute
                        const imageHtml = `<img src="${imageUrl.replace(/"/g, '&quot;')}" alt="Property Tag" style="max-width: 64px; height: auto; vertical-align: middle; margin: 0 3px; display: inline-block; object-fit: contain;" onerror="this.style.display='none'; console.error('Property image failed to load:', this.src);">`;
                        // Replace ALL occurrences of this placeholder (not just first)
                        const placeholderRegex = new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                        processedText = processedText.replace(placeholderRegex, imageHtml);
                        console.log('[Chat]  Replaced PROPERTY_IMAGE with URL:', imageUrl.substring(0, 50));
                            } else {
                        // Remove ALL occurrences if no URL
                        const placeholderRegex = new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                        processedText = processedText.replace(placeholderRegex, '');
                        console.log('[Chat]  Empty PROPERTY_IMAGE URL, removing placeholder');
                    }
                });
                
                // Verify table structure is still intact
                if (textToProcess.includes('<table')) {
                    const originalTableCount = (textToProcess.match(/<table/gi) || []).length;
                    const processedTableCount = (processedText.match(/<table/gi) || []).length;
                    const originalTableCloseCount = (textToProcess.match(/<\/table>/gi) || []).length;
                    const processedTableCloseCount = (processedText.match(/<\/table>/gi) || []).length;
                    
                    if (originalTableCount !== processedTableCount || originalTableCloseCount !== processedTableCloseCount) {
                        console.error('[Chat] ERROR: Table structure broken during image replacement!');
                        console.error('[Chat] Falling back to original text with placeholders');
                        processedText = textToProcess; // Fallback to original
                    }
                }
                
                return processedText;
            }
            
            // If image references exist and text contains HTML tables, don't set initial content
            if (isWaitingForImages) {
                content = ''; // Will be replaced after image processing
            } else if (text.includes('<table') || text.includes('</table>')) {
                // Text contains HTML tables - need to process markdown in text portions, preserve table HTML
                console.log('[Chat] Table HTML detected - processing markdown in text portions');
                
                // Split text into parts: before table, table HTML, after table
                // Match complete table tags including nested content
                const tableRegex = /(<table[\s\S]*?<\/table>)/gi;
                const parts = text.split(tableRegex);
                
                // Process each part: markdown for text, preserve HTML for tables
                content = parts.map(part => {
                    if (part && part.trim().startsWith('<table')) {
                        // This is a table - preserve as-is
                        return part;
                    } else if (part && part.trim()) {
                        // This is text - process markdown and wrap in paragraph tags
                        return processMarkdownInText(part, true);
                    }
                    return part || '';
                }).join('');
                
                console.log('[Chat] Content processed with markdown for text portions, length:', content.length);
            } else if (text.includes('<div') || text.includes('<img')) {
                // Contains other HTML - preserve HTML tags, escape text
                const htmlRegex = /(<div[^>]*>[\s\S]*?<\/div>|<img[^>]*>)/gi;
                const parts = text.split(htmlRegex);
                content = parts.map(part => {
                    if (part && (part.trim().startsWith('<div') || part.trim().startsWith('<img'))) {
                        return part; // Preserve HTML
                    } else if (part && part.trim()) {
                        return processMarkdownInText(part);
                    }
                    return part || '';
                }).join('');
            } else {
                // Regular text, escape HTML and wrap in paragraph
                content = `<p>${processMarkdownInText(text)}</p>`;
            }
            
            // If image references exist, fetch element data and replace them
            if (hasImageRefs) {
                // Create AbortController for timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
                
                fetch('/api/records', {
                    signal: controller.signal,
                    headers: {
                        'Cache-Control': 'no-cache'
                    }
                })
                    .then(response => {
                        clearTimeout(timeoutId);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(records => {
                        // Debug: Log records with image URLs
                        const recordsWithImages = records.filter(r => r.image_url);
                        console.log('[Chat] Total records fetched:', records.length);
                        console.log('[Chat] Records with image_url:', recordsWithImages.length);
                        if (recordsWithImages.length > 0) {
                            console.log('[Chat] Sample records with images:', recordsWithImages.slice(0, 3).map(r => ({ name: r.name, image_url: r.image_url })));
                        } else {
                            console.warn('[Chat] WARNING: No records have image_url! This will cause image replacement to fail.');
                        }
                        
                        // Process images using the helper function
                        const processedText = processImagesWithRecords(records, text);
                        
                        // Debug: Check if images were actually inserted
                        const elementMatches = [...text.matchAll(/\[ELEMENT_IMAGE:([^\]]+)\]/g)];
                        const imgTagsInProcessed = (processedText.match(/<img[^>]*>/gi) || []).length;
                        console.log('[Chat] Image tags found in processedText:', imgTagsInProcessed);
                        if (imgTagsInProcessed > 0) {
                            const firstImg = processedText.match(/<img[^>]*>/i);
                            if (firstImg) {
                                console.log('[Chat] First image tag:', firstImg[0].substring(0, 100));
                            }
                        } else if (elementMatches.length > 0) {
                            console.warn('[Chat] WARNING: No images found in processedText but', elementMatches.length, 'placeholders were found!');
                            console.warn('[Chat] This suggests image replacement failed - checking records...');
                            // Verify records have image URLs
                            const recordsWithImages = records.filter(r => r.image_url);
                            console.log('[Chat] Records with image URLs:', recordsWithImages.length, 'out of', records.length);
                        }
                        
                        console.log('[Chat] ProcessedText length after replacements:', processedText.length);
                        console.log('[Chat] ProcessedText contains <table:', processedText.includes('<table'));
                        console.log('[Chat] ProcessedText contains </table>:', processedText.includes('</table>'));
                        
                        // Process content with images - SIMPLEST: if tables exist, use processedText directly
                        let finalContent;
                        try {
                            if (processedText.includes('<table') || processedText.includes('</table>')) {
                                // Contains tables - split into parts and process markdown for text portions
                                console.log('[Chat] Table HTML with images - processing markdown for text portions');
                                
                                // Verify images are in the processed text
                                const imgCount = (processedText.match(/<img[^>]*>/gi) || []).length;
                                console.log('[Chat] Image tags in processedText:', imgCount);
                                if (imgCount === 0 && elementMatches.length > 0) {
                                    console.warn('[Chat] WARNING: No images found in processedText but placeholders were found!');
                                    console.warn('[Chat] This suggests image replacement failed');
                                }
                                
                                // Split into parts: before table, table HTML, after table
                                // Use a more robust function to extract tables that handles nesting
                                function extractTablesWithNesting(text) {
                                    const tables = [];
                                    const parts = [];
                                    let lastIndex = 0;
                                    let depth = 0;
                                    let tableStart = -1;
                                    
                                    for (let i = 0; i < text.length; i++) {
                                        if (text.substring(i).startsWith('<table')) {
                                            if (depth === 0) {
                                                // Start of a new table
                                                if (i > lastIndex) {
                                                    parts.push({ type: 'text', content: text.substring(lastIndex, i) });
                                                }
                                                tableStart = i;
                                            }
                                            depth++;
                                            i += 6; // Skip '<table'
                                        } else if (text.substring(i).startsWith('</table>')) {
                                            depth--;
                                            if (depth === 0 && tableStart !== -1) {
                                                // End of table
                                                const tableContent = text.substring(tableStart, i + 8);
                                                parts.push({ type: 'table', content: tableContent });
                                                lastIndex = i + 8;
                                                tableStart = -1;
                                            }
                                            i += 7; // Skip '</table>'
                                        }
                                    }
                                    
                                    // Add remaining text
                                    if (lastIndex < text.length) {
                                        parts.push({ type: 'text', content: text.substring(lastIndex) });
                                    }
                                    
                                    return parts;
                                }
                                
                                const parts = extractTablesWithNesting(processedText);
                                
                                // Process each part: markdown for text, preserve HTML for tables
                                finalContent = parts.map(part => {
                                    if (part.type === 'table') {
                                        // This is a table - preserve as-is (images already replaced)
                                        return part.content;
                                    } else if (part.content && part.content.trim()) {
                                        // This is text - process markdown and wrap in paragraph tags
                                        return processMarkdownInText(part.content, true);
                                    }
                                    return part.content || '';
                                }).join('');
                            } else if (processedText.includes('<div') || processedText.includes('<img')) {
                                // Other HTML - preserve HTML tags, escape text
                                const htmlRegex = /(<div[^>]*>[\s\S]*?<\/div>|<img[^>]*>)/gi;
                                const parts = processedText.split(htmlRegex);
                                finalContent = parts.map(part => {
                                    if (part && (part.trim().startsWith('<div') || part.trim().startsWith('<img'))) {
                                        return part;
                                    } else if (part && part.trim()) {
                                        return processMarkdownInText(part, true);
                                    }
                                    return part || '';
                                }).join('');
                            } else {
                                finalContent = `<p>${processMarkdownInText(processedText)}</p>`;
                            }
                        } catch (error) {
                            console.error('[Chat] Error processing content with images:', error);
                            // Fallback: process markdown for text portions if it contains tables
                            if (processedText.includes('<table') || processedText.includes('</table>')) {
                                // Split and process markdown for text portions
                                const tableRegex = /(<table[\s\S]*?<\/table>)/gi;
                                const parts = processedText.split(tableRegex);
                                finalContent = parts.map(part => {
                                    if (part && part.trim().startsWith('<table')) {
                                        return part; // Preserve table HTML
                                    } else if (part && part.trim()) {
                                        return processMarkdownInText(part, true); // Process markdown and wrap in paragraph
                                    }
                                    return part || '';
                                }).join('');
                            } else {
                                finalContent = `<p>${processMarkdownInText(processedText)}</p>`;
                            }
                        }
                        
                        // Update the content in the DOM - preserve table structure
                        const contentElement = messageDiv.querySelector('.chat-content');
                        // Store messageDiv reference for button checks (to avoid duplicates)
                        const messageDivRef = messageDiv;
                        if (contentElement) {
                            // CRITICAL: Check if there's already a rendered table in the DOM
                            const existingTable = contentElement.querySelector('table');
                            
                            // CRITICAL: If content contains tables OR there's already a table rendered,
                            // always update the entire contentElement to preserve table structure
                            if (finalContent.includes('<table') || finalContent.includes('</table>') || existingTable) {
                                console.log('[Chat] ===== IMAGE PROCESSING DOM UPDATE =====');
                                console.log('[Chat] Existing table detected:', existingTable !== null);
                                console.log('[Chat] Updating contentElement with table HTML');
                                console.log('[Chat] FinalContent length:', finalContent.length);
                                console.log('[Chat] FinalContent contains <table:', finalContent.includes('<table'));
                                console.log('[Chat] FinalContent contains </table>:', finalContent.includes('</table>'));
                                
                                // CRITICAL: Verify finalContent has valid table structure before inserting
                                if (finalContent.includes('<table') && finalContent.includes('</table>')) {
                                    const tableOpenCount = (finalContent.match(/<table/gi) || []).length;
                                    const tableCloseCount = (finalContent.match(/<\/table>/gi) || []).length;
                                    console.log('[Chat] Table tag counts - Open:', tableOpenCount, 'Close:', tableCloseCount);
                                    
                                    if (tableOpenCount === tableCloseCount && tableOpenCount > 0) {
                                        // Valid table structure - safe to insert
                                        console.log('[Chat] Table structure validated - inserting HTML');
                                        
                                        // Verify images are in finalContent before inserting
                                        const finalImgCount = (finalContent.match(/<img[^>]*>/gi) || []).length;
                                        console.log('[Chat] Image tags in finalContent:', finalImgCount);
                                        if (finalImgCount > 0) {
                                            const firstImg = finalContent.match(/<img[^>]*>/i);
                                            console.log('[Chat] Sample image tag:', firstImg ? firstImg[0].substring(0, 150) : 'none');
                                        }
                                        
                            contentElement.innerHTML = finalContent;
                                        
                                        // Verify images are in DOM after insertion and ensure button is added
                                        setTimeout(() => {
                                            const domImgCount = contentElement.querySelectorAll('img').length;
                                            console.log('[Chat] Image tags in DOM after insertion:', domImgCount);
                                            if (domImgCount === 0 && finalImgCount > 0) {
                                                console.error('[Chat] ERROR: Images were in finalContent but not found in DOM!');
                                                console.error('[Chat] This may be due to invalid image URLs or HTML structure issues');
                                            } else if (domImgCount > 0) {
                                                console.log('[Chat]  Images successfully rendered in DOM');
                                                contentElement.querySelectorAll('img').forEach((img, idx) => {
                                                    console.log(`[Chat] Image ${idx + 1}:`, img.src, img.alt);
                                                });
                                            }
                                            
                                            // Diagram generation button removed - no button creation
                                        }, 100);
                                    } else {
                                        console.error('[Chat] ERROR: Invalid table structure in finalContent!');
                                        console.error('[Chat] Mismatched table tags - Open:', tableOpenCount, 'Close:', tableCloseCount);
                                        console.log('[Chat] Attempting to use processedText directly (has images replaced)');
                                        
                                        // Use processedText directly instead of original text (processedText has images replaced)
                                        const processedTableOpen = (processedText.match(/<table/gi) || []).length;
                                        const processedTableClose = (processedText.match(/<\/table>/gi) || []).length;
                                        
                                        if (processedTableOpen === processedTableClose && processedTableOpen > 0) {
                                            console.log('[Chat] processedText has valid table structure - using it directly');
                                            contentElement.innerHTML = processedText;
                                        } else {
                                            console.warn('[Chat] processedText also has invalid structure, using finalContent anyway');
                                            contentElement.innerHTML = finalContent; // Use what we have
                                        }
                                    }
                                } else {
                                    console.error('[Chat] ERROR: finalContent missing table tags!');
                                    // Fallback to processedText (has images replaced) if it has tables
                                    if (processedText.includes('<table') && processedText.includes('</table>')) {
                                        console.log('[Chat] Falling back to processedText (has images replaced)');
                                        contentElement.innerHTML = processedText;
                                    } else {
                                        console.warn('[Chat] processedText also missing tables, using finalContent');
                                        contentElement.innerHTML = finalContent;
                                    }
                                }
                                
                                // Verify table was inserted correctly
                                const tableFound = contentElement.querySelector('table') !== null;
                                console.log('[Chat] Table found in DOM after image processing:', tableFound);
                                if (!tableFound && finalContent.includes('<table')) {
                                    console.error('[Chat] ERROR: Table not found after image processing update!');
                                    console.error('[Chat] FinalContent preview:', finalContent.substring(0, 500));
                                    // Last resort: try inserting again after a brief delay
                                    setTimeout(() => {
                                        if (!contentElement.querySelector('table') && finalContent.includes('<table')) {
                                            console.log('[Chat] Retry: Re-inserting table HTML');
                                            contentElement.innerHTML = finalContent;
                                            // Diagram generation button removed
                                        }
                                    }, 100);
                                } else if (tableFound) {
                                    console.log('[Chat] Table successfully rendered after image processing');
                                    // Ensure button is added if needed (check for both regular and template buttons)
                                    // CRITICAL: Check messageDivRef (messageDiv), not contentElement, to avoid duplicates
                                    // Diagram generation button removed
                                }
                            } else {
                                // No tables - check for p tag for text content
                                const pElement = contentElement.querySelector('p');
                                if (pElement && !existingTable) {
                                    // Only update p tag if there's no table
                                    pElement.innerHTML = finalContent;
                                } else {
                                    // Update entire content div
                                    contentElement.innerHTML = finalContent;
                                }
                            }
                            
                            // Diagram generation button removed
                        }
                    })
                    .catch(error => {
                        clearTimeout(timeoutId);
                        console.error('[Chat] ===== IMAGE FETCH ERROR =====');
                        console.error('[Chat] Error fetching element images:', error);
                        console.error('[Chat] Error type:', error.name);
                        console.error('[Chat] Original text contains table:', text.includes('<table'));
                        
                        // Retry once if it's a timeout or network error (but not if already retried)
                        const shouldRetry = (error.name === 'AbortError' || error.name === 'TypeError' || error.message?.includes('Failed to fetch')) && !window._imageFetchRetried;
                        if (shouldRetry) {
                            console.log('[Chat] Retrying image fetch after error...');
                            window._imageFetchRetried = true; // Prevent infinite retries
                            
                            // Retry with a fresh fetch (no timeout on retry)
                            return fetch('/api/records', {
                                headers: {
                                    'Cache-Control': 'no-cache'
                                }
                            })
                                .then(response => {
                                    if (!response.ok) {
                                        throw new Error(`HTTP error! status: ${response.status}`);
                                    }
                                    return response.json();
                                })
                                .then(records => {
                                    console.log('[Chat] Retry successful, processing images with', records.length, 'records');
                                    // Process images with retried records using helper function
                                    const processedText = processImagesWithRecords(records, text);
                                    // Return as if it was the normal flow - continue with processing
                                    return { records, processedText };
                                })
                                .then(result => {
                                    // Handle retry result - continue with normal processing flow
                                    const records = result.records;
                                    const processedText = result.processedText;
                                    // Continue with the same processing as the main path below
                                    // (The code will handle processedText)
                                    return { records, processedText };
                                })
                                .catch(retryError => {
                                    console.error('[Chat] Retry also failed:', retryError);
                                    window._imageFetchRetried = false; // Reset for next attempt
                                    throw retryError; // Fall through to error handling
                                });
                        }
                        
                        // Reset retry flag if not retrying
                        window._imageFetchRetried = false;
                        
                        // On error, preserve table structure - just remove the image references
                        let fallbackText = text;
                        const elementMatches = [...text.matchAll(/\[ELEMENT_IMAGE:([^\]]+)\]/g)];
                        console.log('[Chat] Removing element image placeholders:', elementMatches.length);
                        elementMatches.forEach(match => {
                            // Replace ALL occurrences
                            const placeholderRegex = new RegExp(match[0].replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                            fallbackText = fallbackText.replace(placeholderRegex, match[1]); // Replace with element name
                        });
                        const propertyMatches = [...fallbackText.matchAll(/\[PROPERTY_IMAGE:([^\]]+)\]/g)];
                        console.log('[Chat] Removing property image placeholders:', propertyMatches.length);
                        propertyMatches.forEach(match => {
                            // Replace ALL occurrences
                            const placeholderRegex = new RegExp(match[0].replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                            fallbackText = fallbackText.replace(placeholderRegex, ''); // Remove placeholder
                        });
                        
                        console.log('[Chat] FallbackText length:', fallbackText.length);
                        console.log('[Chat] FallbackText contains <table:', fallbackText.includes('<table'));
                        console.log('[Chat] FallbackText contains </table>:', fallbackText.includes('</table>'));
                        
                        const contentElement = messageDiv.querySelector('.chat-content');
                        if (contentElement) {
                            // CRITICAL: If fallbackText contains tables, preserve HTML structure
                            if (fallbackText.includes('<table') || fallbackText.includes('</table>')) {
                                // Verify table structure is intact
                                const tableOpenCount = (fallbackText.match(/<table/gi) || []).length;
                                const tableCloseCount = (fallbackText.match(/<\/table>/gi) || []).length;
                                console.log('[Chat] Fallback table structure - Open:', tableOpenCount, 'Close:', tableCloseCount);
                                
                                if (tableOpenCount === tableCloseCount && tableOpenCount > 0) {
                                    console.log('[Chat] Valid table structure in fallback - inserting');
                                    contentElement.innerHTML = fallbackText;
                                    
                                    // Verify table was inserted
                                    const tableFound = contentElement.querySelector('table') !== null;
                                    console.log('[Chat] Table found in DOM after error fallback:', tableFound);
                                    
                                    if (!tableFound) {
                                        console.error('[Chat] ERROR: Table not found after error fallback!');
                                        // Last resort: use original text
                                        if (text.includes('<table') && text.includes('</table>')) {
                                            console.log('[Chat] Using original text as last resort');
                                            contentElement.innerHTML = text;
                                        }
                                    }
                                } else {
                                    console.error('[Chat] Invalid table structure in fallback - using original text');
                                    contentElement.innerHTML = text.includes('<table') ? text : fallbackText;
                                }
                            } else {
                                // No tables - normal text handling
                                const pElement = contentElement.querySelector('p');
                                if (pElement && !contentElement.querySelector('table')) {
                                    pElement.innerHTML = escapeHtml(fallbackText).replace(/\n/g, '<br>');
                                } else {
                                    contentElement.innerHTML = escapeHtml(fallbackText).replace(/\n/g, '<br>');
                                }
                            }
                        }
                    });
            }
            
            // Add PlantUML diagram button for assistant messages only if data exists
            // But only if we're not waiting for image processing (to avoid adding button before content)
            // CRITICAL: For tables, append button AFTER table HTML, not by concatenating strings
            // Diagram generation button removed - no button creation needed
            
            // For tables, ensure content is inserted as HTML, not escaped text
            // Create the message div structure
            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'chat-avatar';
            avatarDiv.innerHTML = avatarHtml;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'chat-content';
            
            // Insert content directly as HTML (not escaped) with error handling
            try {
                // CRITICAL: For tables, ensure we're inserting raw HTML, not escaped text
                if (text.includes('<table') || text.includes('</table>')) {
                    console.log('[Chat] ===== TABLE RENDERING START =====');
                    console.log('[Chat] Inserting table HTML directly');
                    console.log('[Chat] Content type:', typeof content);
                    console.log('[Chat] Content length:', content ? content.length : 0);
                    console.log('[Chat] Text length:', text.length);
                    console.log('[Chat] isWaitingForImages:', isWaitingForImages);
                    console.log('[Chat] Content preview (first 300 chars):', content ? content.substring(0, 300) : 'null');
                    console.log('[Chat] Text preview (first 300 chars):', text.substring(0, 300));
                    
                    // CRITICAL: If waiting for images, don't insert content yet - image processing will update it
                    if (isWaitingForImages) {
                        console.log('[Chat] Waiting for image processing - setting loading message initially');
                        console.log('[Chat] Image processing will update contentDiv.innerHTML when complete');
                        contentDiv.innerHTML = '<div style="color: #888; font-style: italic;">Loading images...</div>';
                        // Store reference to contentDiv for image processing callback
                        window._pendingImageContentDiv = contentDiv;
                    } else {
                        // Use content if it was processed (with markdown formatting), otherwise process text
                        let htmlToInsert = content && typeof content === 'string' && content.includes('<table') ? content : text;
                    
                        // Ensure markdown is processed for text portions outside tables
                        // Split into parts: before table, table HTML, after table
                        const tableRegex = /(<table[\s\S]*?<\/table>)/gi;
                        const parts = htmlToInsert.split(tableRegex);
                        htmlToInsert = parts.map(part => {
                            if (part && part.trim().startsWith('<table')) {
                                // This is a table - preserve as-is
                                return part;
                            } else if (part && part.trim()) {
                                // This is text - process markdown if not already processed
                                // Check if it already has HTML tags (already processed)
                                if (part.includes('<strong>') || part.includes('<br>') || part.includes('<p>') || part.includes('<em>')) {
                                    return part; // Already processed
                                }
                                return processMarkdownInText(part, true); // Wrap in paragraph tags
                            }
                            return part || '';
                        }).join('');
                        
                        // Insert directly - innerHTML will render HTML
                        console.log('[Chat] Inserting HTML, length:', htmlToInsert.length);
                        contentDiv.innerHTML = htmlToInsert;
                        
                        // Verify table was inserted
                        const tableFound = contentDiv.querySelector('table') !== null;
                        const allTables = contentDiv.querySelectorAll('table');
                        console.log('[Chat] Table found in DOM after insertion:', tableFound);
                        console.log('[Chat] Number of tables found:', allTables.length);
                        
                        if (!tableFound) {
                            console.error('[Chat] CRITICAL: Table HTML not rendered!');
                            console.error('[Chat] HTML to insert preview:', htmlToInsert.substring(0, 1000));
                            console.error('[Chat] ContentDiv innerHTML length:', contentDiv.innerHTML.length);
                            console.error('[Chat] ContentDiv innerHTML preview:', contentDiv.innerHTML.substring(0, 500));
                            
                            // Last resort: try multiple strategies
                            console.log('[Chat] Attempting recovery strategies...');
                            
                            // Strategy 1: Try inserting original text directly
                            if (text.includes('<table')) {
                                console.log('[Chat] Recovery Strategy 1: Direct text insertion');
                                contentDiv.innerHTML = text;
                                if (contentDiv.querySelector('table') !== null) {
                                    console.log('[Chat] Recovery Strategy 1 SUCCESS');
                                } else {
                                    // Strategy 2: Try using DOMParser
                                    console.log('[Chat] Recovery Strategy 2: Using DOMParser');
                                    try {
                                        const parser = new DOMParser();
                                        const doc = parser.parseFromString(text, 'text/html');
                                        const tables = doc.querySelectorAll('table');
                                        if (tables.length > 0) {
                                            contentDiv.innerHTML = '';
                                            tables.forEach(table => {
                                                contentDiv.appendChild(table.cloneNode(true));
                                            });
                                            console.log('[Chat] Recovery Strategy 2 SUCCESS');
                                        }
                                    } catch (parseError) {
                                        console.error('[Chat] Recovery Strategy 2 FAILED:', parseError);
                                    }
                                }
                            }
                        } else {
                            console.log('[Chat] ===== TABLE RENDERING SUCCESS =====');
                        }
                        
                        // Append button after table if needed (only if not waiting for images - images will add button in callback)
                        if (content._buttonHtml && !isWaitingForImages) {
                            // Check if button already exists to avoid duplicates
                            if (!messageDiv.querySelector('.generate-diagram-btn') && !messageDiv.querySelector('.preview-template-diagram-btn')) {
                            console.log('[Chat] Inserting stored button HTML after table:', content._buttonHtml.substring(0, 100));
                            contentDiv.insertAdjacentHTML('beforeend', content._buttonHtml);
                            
                            // Attach click handler for regular diagram button
                            const btn = contentDiv.querySelector('.generate-diagram-btn');
                            if (btn) {
                                console.log('[Chat] Found regular diagram button, attaching handler');
                                attachDiagramButtonHandler(btn, text, mentionedElements);
                            }
                            
                            // Attach click handler for template preview button
                            const templateBtn = contentDiv.querySelector('.preview-template-diagram-btn');
                            if (templateBtn) {
                                console.log('[Chat] Found template preview button, attaching handler');
                                templateBtn.addEventListener('click', function() {
                                console.log('[Chat] Template preview button clicked');
                                const diagramDataStr = this.getAttribute('data-diagram-data');
                                if (diagramDataStr) {
                                    try {
                                        const diagramData = JSON.parse(diagramDataStr.replace(/&#39;/g, "'").replace(/&quot;/g, '"'));
                                        console.log('[Chat] Parsed diagram data:', {
                                            hasPlantumlCode: !!diagramData.plantuml_code,
                                            elementsCount: diagramData.elements_count
                                        });
                                        // Display the pre-generated diagram
                                        displayPlantUMLDiagram(
                                            diagramData.plantuml_code,
                                            diagramData.encoded_url,
                                            diagramData.elements_count || 0,
                                            diagramData.relationships_count || 0,
                                            `Template Diagram: ${diagramData.template_used || 'Based on Template'}`,
                                            mentionedElements || [],
                                            null, // enterprise filter
                                            diagramData.element_ids || [],
                                            'from-chat',
                                            null, // diagramId
                                            true, // includeRelationships
                                            false // includeRelated
                                        );
                                    } catch (error) {
                                        console.error('[Chat] Error parsing template diagram data:', error);
                                        addChatMessage('Error displaying template diagram. Please try again.', 'assistant');
                                    }
                                } else {
                                    console.error('[Chat] No diagram data found in button attribute');
                                }
                            });
                        } else {
                            console.warn('[Chat] Template preview button not found after insertion');
                        }
                            } else {
                                console.log('[Chat] Button already exists, skipping duplicate insertion');
                            }
                        } else {
                            if (isWaitingForImages) {
                                console.log('[Chat] Skipping button insertion - waiting for images (will be added in image callback)');
                            } else {
                                console.log('[Chat] No button HTML stored in content._buttonHtml');
                            }
                        }
                    }
                } else {
                    // No tables - normal insertion
                    contentDiv.innerHTML = content || '';
                }
            } catch (error) {
                console.error('[Chat] Error inserting content into DOM:', error);
                console.error('[Chat] Error stack:', error.stack);
                console.error('[Chat] Content that caused error:', content ? content.substring(0, 500) : 'null');
                // Fallback: if text contains HTML, try inserting it directly
                if (text.includes('<table') || text.includes('</table>')) {
                    console.log('[Chat] Fallback: inserting original text with tables');
                    try {
                        contentDiv.innerHTML = text;
                    } catch (fallbackError) {
                        console.error('[Chat] Fallback also failed:', fallbackError);
                        contentDiv.textContent = 'Error displaying content. Please check console for details.';
                    }
                } else {
                    contentDiv.textContent = content || '';
                }
            }
            
            messageDiv.appendChild(avatarDiv);
            messageDiv.appendChild(contentDiv);
            
            messagesContainer.appendChild(messageDiv);
            
            // Attach click handler for generate diagram button (if not already attached for tables)
            if (sender === 'assistant') {
                // Handle regular diagram generation button
                const btn = messageDiv.querySelector('.generate-diagram-btn');
                if (btn && !btn.hasAttribute('data-handler-attached')) {
                    btn.setAttribute('data-handler-attached', 'true');
                    btn.addEventListener('click', async function() {
                        // Get response text from data attribute (stored when button was created)
                        let responseText = this.getAttribute('data-response-text') || '';
                        // Decode HTML entities
                        responseText = responseText.replace(/&#39;/g, "'").replace(/&quot;/g, '"');
                        
                        // Also try to get from closure scope as fallback
                        if (!responseText && typeof text !== 'undefined') {
                            responseText = text;
                        }
                        
                        console.log('[Diagram] Response text length:', responseText.length);
                        console.log('[Diagram] Response text preview:', responseText.substring(0, 300));
                        
                        const extractedElements = extractElementsFromResponse(responseText);
                        
                        // Use extracted elements if found, otherwise fall back to data-elements attribute
                        const dataElements = JSON.parse(this.getAttribute('data-elements') || '[]');
                        const elements = extractedElements.length > 0 
                            ? extractedElements 
                            : (dataElements.length > 0 ? dataElements : []);
                        
                        console.log('[Diagram] Extracted elements from response:', extractedElements);
                        console.log('[Diagram] Data elements attribute:', dataElements);
                        console.log('[Diagram] Final elements for diagram:', elements);
                        
                        if (elements.length === 0) {
                            alert('No elements found in the response. The ChatBot response may not have included specific element names. Please try asking about specific elements.');
                            return;
                        }
                        
                        // Get template diagram name if available
                        const templateDiagramName = this.getAttribute('data-template-name') || null;
                        
                        // Default behavior for manual button: include relationships and related elements
                        // (user explicitly clicked the button, so they want a full diagram)
                        generatePlantUMLFromChat(elements, true, true, templateDiagramName);
                    });
                }
                
                // Handle template preview button
                const templateBtn = messageDiv.querySelector('.preview-template-diagram-btn');
                if (templateBtn && !templateBtn.hasAttribute('data-handler-attached')) {
                    templateBtn.setAttribute('data-handler-attached', 'true');
                    templateBtn.addEventListener('click', function() {
                        const diagramDataStr = this.getAttribute('data-diagram-data');
                        if (diagramDataStr) {
                            try {
                                const diagramData = JSON.parse(diagramDataStr.replace(/&#39;/g, "'").replace(/&quot;/g, '"'));
                                // Display the pre-generated diagram
                                displayPlantUMLDiagram(
                                    diagramData.plantuml_code,
                                    diagramData.encoded_url,
                                    diagramData.elements_count || 0,
                                    diagramData.relationships_count || 0,
                                    `Template Diagram: ${diagramData.template_used || 'Based on Template'}`,
                                    mentionedElements || [],
                                    null, // enterprise filter
                                    diagramData.element_ids || [],
                                    'from-chat',
                                    null, // diagramId
                                    true, // includeRelationships
                                    false // includeRelated
                                );
                            } catch (error) {
                                console.error('[Chat] Error parsing template diagram data:', error);
                                addChatMessage('Error displaying template diagram. Please try again.', 'assistant');
                            }
                        }
                    });
                }
            }
            
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        // Extract element names from ChatBot response text
        function extractElementsFromResponse(responseText) {
            if (!responseText || typeof responseText !== 'string') {
                console.warn('[extractElementsFromResponse] Invalid responseText:', responseText);
                return [];
            }
            
            const elementNames = new Set();
            
            // Method 1: Extract from [ELEMENT_IMAGE:element_name] references
            try {
                const elementImageMatches = [...responseText.matchAll(/\[ELEMENT_IMAGE:([^\]]+)\]/g)];
                elementImageMatches.forEach(match => {
                    const elementName = match[1].trim();
                    if (elementName) {
                        elementNames.add(elementName);
                    }
                });
            } catch (e) {
                console.warn('[extractElementsFromResponse] Error extracting from ELEMENT_IMAGE:', e);
            }
            
            // Method 2: Extract element names from common patterns in the response
            // Look for patterns like "- ElementName", "ElementName (Element Type)", etc.
            // This helps catch elements mentioned without image references
            try {
                const elementPatterns = [
                    /- ([A-Z][a-zA-Z\s]+?)(?:\s*\(|$|\[|Facet|Enterprise)/g,  // "- ElementName" pattern
                    /([A-Z][a-zA-Z\s]+?)\s*\(Element Type:/g,  // "ElementName (Element Type:" pattern
                    /([A-Z][a-zA-Z\s]+?)\s*- [A-Z]/g  // "ElementName - Facet" pattern
                ];
                
                elementPatterns.forEach(pattern => {
                    try {
                        const matches = [...responseText.matchAll(pattern)];
                        matches.forEach(match => {
                            const elementName = match[1].trim();
                            // Filter out common false positives
                            if (elementName && 
                                !elementName.match(/^(Relevant|Your|Repository|Elements|Properties|Description|Enterprise|Facet|Base|Architecture|Identity|Experience|Product|Organisation|Brand)$/i) &&
                                elementName.length > 1 && elementName.length < 50) {
                                elementNames.add(elementName);
                            }
                        });
                    } catch (e) {
                        console.warn('[extractElementsFromResponse] Error with pattern:', e);
                    }
                });
            } catch (e) {
                console.warn('[extractElementsFromResponse] Error extracting from patterns:', e);
            }
            
            const result = Array.from(elementNames);
            console.log('[extractElementsFromResponse] Extracted elements:', result);
            return result;
        }
        
        async function generatePlantUMLFromChat(elementNames, includeRelationships = false, includeRelated = false, templateDiagramName = null) {
            try {
                // Show loading indicator
                const loadingMsg = document.createElement('div');
                loadingMsg.className = 'chat-message assistant';
                loadingMsg.innerHTML = `
                    <div class="chat-avatar"><img src="/images/ask-ed_OLD.svg" alt="Ask ED" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;"></div><div class="chat-content"><p>Generating PlantUML diagram...</p>
                    </div>
                `;
                document.getElementById('chatMessages').appendChild(loadingMsg);
                
                // Get enterprise filter if selected
                const enterpriseSelect = document.getElementById('chatbotEnterpriseSelect');
                const enterprise = enterpriseSelect ? enterpriseSelect.value : '';
                
                const requestBody = {
                        element_names: elementNames || [],
                        enterprise: enterprise || null,
                        use_facets: false, // Default to false - show elements and relationships only
                        include_relationships: true, // Always include relationships
                        include_related: includeRelated,
                        include_notes: false, // Default to false - elements and relationships only
                        include_properties: false // Default to false - elements and relationships only
                };
                
                // Add template diagram name if provided
                if (templateDiagramName && templateDiagramName.trim() !== '') {
                    requestBody.template_diagram_name = templateDiagramName.trim();
                    console.log('[Diagram] Including template diagram name in request:', requestBody.template_diagram_name);
                } else {
                    console.log('[Diagram] WARNING: No template diagram name provided - templateDiagramName is:', templateDiagramName);
                }
                
                console.log('[Diagram] Request body template_diagram_name:', requestBody.template_diagram_name || 'NOT INCLUDED');
                
                const response = await fetch('/api/plantuml/from-chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                // Remove loading message
                loadingMsg.remove();
                
                const data = await response.json();
                
                if (data.error) {
                    addChatMessage('Error generating diagram: ' + data.error, 'assistant');
                    return;
                }
                
                displayPlantUMLDiagram(
                    data.plantuml,
                    data.encoded,
                    data.elements_count,
                    data.relationships_count,
                    data.title || 'Chatbot Response Diagram',
                    elementNames || [], // elementNames
                    enterprise || null, // enterpriseFilter
                    data.element_ids || [], // elementIds
                    'from-chat', // diagramType
                    null, // diagramId
                    true, // Always include relationships
                    includeRelated // includeRelated
                );
            } catch (error) {
                console.error('Error generating PlantUML diagram:', error);
                addChatMessage('Error generating diagram. Please try again.', 'assistant');
            }
        }

        function addTypingIndicator() {
            const messagesContainer = document.getElementById('chatMessages');
            const typingDiv = document.createElement('div');
            typingDiv.id = 'typing-indicator';
            typingDiv.className = 'chat-message assistant';
            typingDiv.innerHTML = `
                <div class="chat-avatar"><img src="/images/ask-ed_OLD.svg" alt="Ask ED" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;"></div><div class="chat-content"><p>Thinking...</p>
                </div>
            `;
            messagesContainer.appendChild(typingDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            return 'typing-indicator';
        }

        function removeTypingIndicator(id) {
            const indicator = document.getElementById(id);
            if (indicator) {
                indicator.remove();
            }
        }
        
        // Enhanced Diagram Interaction (Zoom & Pan)
        let diagramZoomLevel = 100;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let panOffsetX = 0;
        let panOffsetY = 0;
        
        function zoomDiagram(action, value = null) {
            const diagramPreview = document.getElementById('diagramPreview');
            const wrapper = document.getElementById('diagramPanWrapper');
            const zoomSlider = document.getElementById('diagramZoomSlider');
            const zoomPercent = document.getElementById('diagramZoomPercent');
            
            if (!diagramPreview) return;
            
            if (action === 'in') {
                diagramZoomLevel = Math.min(diagramZoomLevel + 10, 200);
            } else if (action === 'out') {
                diagramZoomLevel = Math.max(diagramZoomLevel - 10, 25);
            } else if (action === 'reset') {
                diagramZoomLevel = 100;
                panOffsetX = 0;
                panOffsetY = 0;
            } else if (action === 'slider' && value !== null) {
                diagramZoomLevel = parseInt(value);
            }
            
            // Update slider if it exists
            if (zoomSlider && action !== 'slider') {
                zoomSlider.value = diagramZoomLevel;
            }
            
            // Update percentage display
            if (zoomPercent) {
                zoomPercent.textContent = diagramZoomLevel + '%';
            }
            
            // Apply zoom using CSS transform
            const scale = diagramZoomLevel / 100;
            if (wrapper) {
                wrapper.style.transform = `translate(-50%, -50%) translate(${panOffsetX}px, ${panOffsetY}px) scale(${scale})`;
            } else {
                diagramPreview.style.transform = `scale(${scale})`;
            }
        }
        
        function handleDiagramWheel(event) {
            event.preventDefault();
            const delta = event.deltaY > 0 ? -10 : 10;
            diagramZoomLevel = Math.max(25, Math.min(200, diagramZoomLevel + delta));
            zoomDiagram('slider', diagramZoomLevel);
        }
        
        function startPan(event) {
            if (event.button !== 0) return; // Only left mouse button
            isPanning = true;
            panStartX = event.clientX - panOffsetX;
            panStartY = event.clientY - panOffsetY;
            const container = document.getElementById('diagramZoomContainer');
            if (container) container.style.cursor = 'grabbing';
        }
        
        function doPan(event) {
            if (!isPanning) return;
            panOffsetX = event.clientX - panStartX;
            panOffsetY = event.clientY - panStartY;
            const wrapper = document.getElementById('diagramPanWrapper');
            const scale = diagramZoomLevel / 100;
            if (wrapper) {
                wrapper.style.transform = `translate(-50%, -50%) translate(${panOffsetX}px, ${panOffsetY}px) scale(${scale})`;
            }
        }
        
        function endPan() {
            isPanning = false;
            const container = document.getElementById('diagramZoomContainer');
            if (container) container.style.cursor = 'grab';
        }
        
        function initDiagramInteraction() {
            // Reset zoom and pan when diagram loads
            diagramZoomLevel = 100;
            panOffsetX = 0;
            panOffsetY = 0;
            const slider = document.getElementById('diagramZoomSlider');
            const percent = document.getElementById('diagramZoomPercent');
            if (slider) slider.value = 100;
            if (percent) percent.textContent = '100%';
        }
        
        // Enterprise Management Functions
        
        // Context menu state
        let contextMenuElementId = null;
        let contextMenuRelationshipIndex = null;
        
        // Handle element selection for relationship creation
        function handleElementSelection(elementId) {
            console.log('handleElementSelection called with elementId:', elementId, 'current selected:', canvasState.selectedElementId);
            console.log('Canvas state:', { 
                selectedElementId: canvasState.selectedElementId,
                elements: canvasState.elements.map(e => ({ id: e.id, name: e.instance_name, type: e.element_type }))
            });
            
            if (canvasState.selectedElementId === null || canvasState.selectedElementId === undefined) {
                // First element selected - select it
                console.log('Selecting first element:', elementId);
                selectElementForRelationship(elementId);
            } else if (canvasState.selectedElementId === elementId) {
                // Clicked same element - deselect
                console.log('Deselecting element:', elementId);
                deselectElementForRelationship();
            } else {
                // Second element selected - create relationship if valid
                console.log('Creating relationship between', canvasState.selectedElementId, 'and', elementId);
                createRelationshipBetweenElements(canvasState.selectedElementId, elementId);
            }
        }
        
        // Select element for relationship creation
        function selectElementForRelationship(elementId) {
            // Deselect previous selection
            if (canvasState.selectedElementId) {
                const prevBorder = document.getElementById(`element-border-${canvasState.selectedElementId}`);
                if (prevBorder) {
                    prevBorder.style.borderColor = 'transparent';
                }
            }
            
            canvasState.selectedElementId = elementId;
            const border = document.getElementById(`element-border-${elementId}`);
            if (border) {
                border.style.borderColor = '#667eea';
                border.style.borderWidth = '2px';
            }
        }
        
        // Deselect element
        function deselectElementForRelationship() {
            if (canvasState.selectedElementId) {
                const border = document.getElementById(`element-border-${canvasState.selectedElementId}`);
                if (border) {
                    border.style.borderColor = 'transparent';
                    border.style.borderWidth = '2px';
                }
            }
            canvasState.selectedElementId = null;
        }
        
        // Create relationship between two selected elements
        function createRelationshipBetweenElements(sourceId, targetId) {
            console.log('createRelationshipBetweenElements called:', { sourceId, targetId });
            const source = canvasState.elements.find(e => e.id === sourceId);
            const target = canvasState.elements.find(e => e.id === targetId);
            
            console.log('Source element:', source);
            console.log('Target element:', target);
            console.log('Relationship rules:', canvasState.relationshipRules);
            
            if (!source || !target) {
                console.error('Source or target element not found');
                deselectElementForRelationship();
                return;
            }
            
            console.log('Source element_type:', source.element_type);
            console.log('Target element_type:', target.element_type);
            
            // Find valid relationship types between these element types
            const validRelationships = canvasState.relationshipRules.filter(rule => {
                const sourceMatch = rule.source_element_type === source.element_type && rule.target_element_type === target.element_type;
                const targetMatch = rule.source_element_type === target.element_type && rule.target_element_type === source.element_type;
                console.log('Checking rule:', {
                    rule: rule,
                    sourceMatch,
                    targetMatch,
                    sourceType: source.element_type,
                    targetType: target.element_type,
                    ruleSource: rule.source_element_type,
                    ruleTarget: rule.target_element_type
                });
                return sourceMatch || targetMatch;
            });
            
            console.log('Valid relationships found:', validRelationships.length, validRelationships);
            
            if (validRelationships.length === 0) {
                showCanvasToast(`No valid relationships exist between ${source.element_type} and ${target.element_type}`, 'error');
                deselectElementForRelationship();
                return;
            }
            
            // If only one valid relationship, create it directly
            if (validRelationships.length === 1) {
                const rule = validRelationships[0];
                const isReverse = rule.source_element_type === target.element_type;
                if (isReverse) {
                    createConnection(targetId, sourceId, rule.relationship_type);
                } else {
                    createConnection(sourceId, targetId, rule.relationship_type);
                }
                deselectElementForRelationship();
                return;
            }
            
            // Multiple valid relationships - show selection menu
            showRelationshipSelectionMenu(sourceId, targetId, validRelationships);
        }
        
        // Show relationship selection menu
        function showRelationshipSelectionMenu(sourceId, targetId, validRelationships) {
            const source = canvasState.elements.find(e => e.id === sourceId);
            const target = canvasState.elements.find(e => e.id === targetId);
            
            const menu = document.createElement('div');
            menu.style.cssText = `
                position: fixed;
                background: #2a2a2a;
                border: 1px solid rgba(255,255,255,0.1);
                border-radius: 4px;
                padding: 8px 0;
                min-width: 200px;
                z-index: 10003;
                box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            `;
            
            const title = document.createElement('div');
            title.style.cssText = 'padding: 8px 12px; color: #ffffff; font-size: 11px; font-weight: 600; border-bottom: 1px solid rgba(255,255,255,0.1);';
            title.textContent = `Select Relationship Type`;
            menu.appendChild(title);
            
            const info = document.createElement('div');
            info.style.cssText = 'padding: 6px 12px; color: #a0a0a0; font-size: 10px; border-bottom: 1px solid rgba(255,255,255,0.1);';
            info.textContent = `${source.instance_name}  ${target.instance_name}`;
            menu.appendChild(info);
            
            validRelationships.forEach(rule => {
                const item = document.createElement('div');
                item.style.cssText = `
                    padding: 6px 12px;
                    cursor: pointer;
                    font-size: 10px;
                    color: #ffffff;
                    transition: background 0.2s;
                `;
                item.textContent = rule.relationship_type;
                
                item.addEventListener('mouseenter', () => {
                    item.style.background = '#353550';
                });
                
                item.addEventListener('mouseleave', () => {
                    item.style.background = 'transparent';
                });
                
                item.addEventListener('click', () => {
                    const isReverse = rule.source_element_type === target.element_type;
                    if (isReverse) {
                        createConnection(targetId, sourceId, rule.relationship_type);
                    } else {
                        createConnection(sourceId, targetId, rule.relationship_type);
                    }
                    document.body.removeChild(menu);
                    deselectElementForRelationship();
                });
                
                menu.appendChild(item);
            });
            
            // Position menu near the target element
            const targetElement = document.getElementById(`element-${targetId}`);
            if (targetElement) {
                const rect = targetElement.getBoundingClientRect();
                menu.style.left = (rect.right + 10) + 'px';
                menu.style.top = rect.top + 'px';
            } else {
                // Center on screen if element not found
                menu.style.left = '50%';
                menu.style.top = '50%';
                menu.style.transform = 'translate(-50%, -50%)';
            }
            
            // Append to correct parent (fullscreen or body)
            const canvasSection = document.getElementById('modelingCanvas');
            const appendTo = (canvasSection && canvasSection.classList.contains('active') && canvasState.isFullscreen) 
                ? canvasSection 
                : document.body;
            appendTo.appendChild(menu);
            
            // Close menu when clicking outside
            setTimeout(() => {
                const closeHandler = (e) => {
                    if (!menu.contains(e.target)) {
                        if (appendTo.contains(menu)) {
                            appendTo.removeChild(menu);
                        }
                        deselectElementForRelationship();
                        document.removeEventListener('click', closeHandler, true);
                    }
                };
                document.addEventListener('click', closeHandler, true);
            }, 10);
        }
        
        // Show context menu
        async function showContextMenu(e, elementId) {
            try {
            contextMenuElementId = elementId;
            contextMenuRelationshipIndex = null;
            const menu = document.getElementById('elementContextMenu');
                if (!menu) {
                    console.error('Context menu element not found');
                    return;
                }
            menu.style.display = 'block';
            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';
            
            // Hide relationship menu if visible
                const relationshipMenu = document.getElementById('relationshipContextMenu');
                if (relationshipMenu) {
                    relationshipMenu.style.display = 'none';
                }
            
            // Hide submenus
                const relatedSubmenu = document.getElementById('relatedElementsSubmenu');
                const propertiesSubmenu = document.getElementById('propertiesSubmenu');
                if (relatedSubmenu) relatedSubmenu.style.display = 'none';
                if (propertiesSubmenu) propertiesSubmenu.style.display = 'none';
            
            // Always show "Create Relationship" option
            const createRelationshipBtn = document.getElementById('createRelationshipMenuItem');
                if (createRelationshipBtn) {
                createRelationshipBtn.style.display = 'block';
                }
                
                // Load related elements for submenu (with error handling)
                try {
                    await loadRelatedElementsForSubmenu(elementId);
                } catch (error) {
                    console.error('Error loading related elements submenu:', error);
                    // Hide the menu item if loading fails
                    const addRelatedMenuItem = document.getElementById('addRelatedElementMenuItem');
                    if (addRelatedMenuItem) {
                        addRelatedMenuItem.style.display = 'none';
                    }
                }
                
            } catch (error) {
                console.error('Error showing context menu:', error);
            }
            
            // Close menu when clicking elsewhere
            setTimeout(() => {
                document.addEventListener('click', closeContextMenu, { once: true });
            }, 10);
        }
        
        // Load properties for submenu (now loads instance properties)
        async function loadPropertiesForSubmenu(elementId) {
            const element = canvasState.elements.find(e => e.id === elementId);
            if (!element) return;
            
            // Load properties from element instance (not element type)
            const properties = element.properties || [];
            
            if (properties.length === 0) {
                document.getElementById('propertiesMenuItem').style.display = 'none';
                return;
            }
            
            document.getElementById('propertiesMenuItem').style.display = 'block';
            
            const submenu = document.getElementById('propertiesSubmenu');
            submenu.innerHTML = '';
            
            properties.forEach(prop => {
                const tagImage = getTagImageFromRAG(prop.ragtype) || prop.image_url;
                const item = document.createElement('div');
                item.style.cssText = `
                    padding: 4px 8px;
                    cursor: pointer;
                    font-size: 10px;
                    color: #000000;
                    transition: background 0.2s;
                    display: flex;
                    align-items: center;
                    gap: 6px;
                `;
                
                item.innerHTML = `
                    ${tagImage ? `<img src="${tagImage}" alt="${prop.ragtype || 'Property'}" 
                         style="width: 16px; height: 16px; object-fit: contain; flex-shrink: 0;"
                         onerror="this.style.display='none'; this.onerror=null;">` : ''}
                    <span style="flex: 1;">${escapeHtml(prop.propertyname || 'Unnamed Property')}</span>
                `;
                
                item.addEventListener('mouseenter', () => {
                    item.style.background = 'rgba(255,255,255,0.2)';
                });
                
                item.addEventListener('mouseleave', () => {
                    item.style.background = 'transparent';
                });
                
                // Add click handler to display properties modal
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    closeContextMenu();
                    if (element.element_type_id) {
                        const elementName = element.instance_name || element.name || 'Element';
                        showElementProperties(element.element_type_id, elementName);
                    } else {
                        alert('Unable to display properties: Element type ID not found');
                    }
                });
                
                submenu.appendChild(item);
            });
        }
        
        // Show properties submenu
        function showPropertiesSubmenu() {
            const submenu = document.getElementById('propertiesSubmenu');
            const menuItem = document.getElementById('propertiesMenuItem');
            if (submenu && submenu.children.length > 0) {
                submenu.style.display = 'block';
                // Position submenu
                const rect = menuItem.getBoundingClientRect();
                submenu.style.top = '0px';
            }
        }
        
        // Hide properties submenu
        function hidePropertiesSubmenu() {
            const submenu = document.getElementById('propertiesSubmenu');
            if (submenu) {
                // Delay hiding to allow moving to submenu
                setTimeout(() => {
                    if (!submenu.matches(':hover') && !document.getElementById('propertiesMenuItem').matches(':hover')) {
                        submenu.style.display = 'none';
                    }
                }, 100);
            }
        }
        
        // Select element for relationship (from context menu)
        function selectElementFromContextMenu() {
            const elementId = contextMenuElementId;
            closeContextMenu();
            if (!elementId) return;
            
            selectElementForRelationship(elementId);
        }
        
        // Load related elements for submenu
        async function loadRelatedElementsForSubmenu(elementId) {
            if (!elementId) {
                console.warn('No element ID provided for submenu');
                return;
            }
            
            const element = canvasState.elements.find(e => e.id === elementId);
            if (!element) {
                console.warn('Element not found for submenu:', elementId, 'Available elements:', canvasState.elements.map(e => e.id));
                // Hide the menu item if element not found
                const addRelatedMenuItem = document.getElementById('addRelatedElementMenuItem');
                if (addRelatedMenuItem) {
                    addRelatedMenuItem.style.display = 'none';
                }
                return;
            }
            
            // Fetch the correct element_type from database using element_type_id
            let correctElementType = element.element_type;
            if (element.element_type_id && element.element_type_id > 0) {
                try {
                    // Fetch all records and find the one matching element_type_id
                    // (There's no GET /api/records/<id> endpoint, so we fetch all and filter)
                    const response = await fetch('/api/records');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const allRecords = await response.json();
                    if (Array.isArray(allRecords)) {
                        const elementData = allRecords.find(r => r.id === element.element_type_id);
                        if (elementData && elementData.element) {
                            correctElementType = elementData.element;
                            
                            // Update the element in canvasState with correct element_type
                            if (correctElementType !== element.element_type) {
                                console.log('Correcting element_type:', {
                                    old: element.element_type,
                                    new: correctElementType,
                                    elementId,
                                    element_type_id: element.element_type_id
                                });
                                element.element_type = correctElementType;
                            }
                        } else {
                            console.warn('Element type not found in records:', element.element_type_id);
                        }
                    }
                } catch (error) {
                    console.error('Error fetching element type:', error);
                    // Use existing element_type as fallback
                    console.log('Using existing element_type:', element.element_type);
                }
            } else {
                console.log('No element_type_id available, using element_type:', element.element_type);
            }
            
            console.log('Loading related elements for:', {
                elementId,
                element_type: correctElementType,
                element_type_id: element.element_type_id,
                relationshipRules: canvasState.relationshipRules
            });
            
            // Debug: Check for Process -> Process flow rule
            const processFlowRules = canvasState.relationshipRules.filter(rule => 
                rule.source_element_type === 'Process' && 
                rule.target_element_type === 'Process' && 
                rule.relationship_type === 'flow'
            );
            console.log('Process -> Process flow rules found:', processFlowRules);
            
            // Find valid element types that can be related to this element
            const validElementTypes = new Map();
            
            canvasState.relationshipRules.forEach(rule => {
                // Use case-insensitive comparison for element types
                const elementType = (correctElementType || '').trim();
                const sourceType = (rule.source_element_type || '').trim();
                const targetType = (rule.target_element_type || '').trim();
                
                // Debug logging for Process rules
                if (elementType.toLowerCase() === 'process' || sourceType.toLowerCase() === 'process' || targetType.toLowerCase() === 'process') {
                    console.log('Processing rule:', {
                        elementType,
                        sourceType,
                        targetType,
                            relationshipType: rule.relationship_type,
                        sourceMatch: elementType.toLowerCase() === sourceType.toLowerCase(),
                        targetMatch: elementType.toLowerCase() === targetType.toLowerCase()
                    });
                }
                
                if (elementType.toLowerCase() === sourceType.toLowerCase()) {
                    if (!validElementTypes.has(targetType)) {
                        validElementTypes.set(targetType, {
                            relationshipType: rule.relationship_type,
                            targetType: targetType,
                            isReverse: false
                        });
                        console.log('Added valid element type (source match):', targetType, rule.relationship_type);
                    }
                }
                if (elementType.toLowerCase() === targetType.toLowerCase()) {
                    if (!validElementTypes.has(sourceType)) {
                        validElementTypes.set(sourceType, {
                            relationshipType: rule.relationship_type,
                            targetType: sourceType,
                            isReverse: true
                        });
                        console.log('Added valid element type (target match):', sourceType, rule.relationship_type);
                    }
                }
            });
            
            console.log('Valid element types found:', Array.from(validElementTypes.keys()));
            console.log('Has Process in validElementTypes?', validElementTypes.has('Process'));
            
            // Special handling: If Process -> Process flow rule exists but Process wasn't added,
            // manually add it (this handles the case where both source and target are Process)
            if (correctElementType.toLowerCase() === 'process' && processFlowRules.length > 0 && !validElementTypes.has('Process')) {
                console.log('Manually adding Process (self-reference case)');
                validElementTypes.set('Process', {
                    relationshipType: 'flow',
                    targetType: 'Process',
                    isReverse: false
                });
                console.log('After manual add, validElementTypes:', Array.from(validElementTypes.keys()));
            } else if (correctElementType.toLowerCase() === 'process' && processFlowRules.length === 0) {
                console.warn('Process -> Process flow rule NOT found in relationshipRules!');
                console.log('Available relationship rules:', canvasState.relationshipRules.map(r => 
                    `${r.source_element_type} -> ${r.target_element_type} (${r.relationship_type})`
                ));
            }
            
            if (validElementTypes.size === 0) {
                const addRelatedMenuItem = document.getElementById('addRelatedElementMenuItem');
                if (addRelatedMenuItem) {
                    addRelatedMenuItem.style.display = 'none';
                }
                return;
            }
            
            const addRelatedMenuItem = document.getElementById('addRelatedElementMenuItem');
            if (addRelatedMenuItem) {
                addRelatedMenuItem.style.display = 'block';
            }
            
            // Load element types from API
            fetch('/api/records')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(elements => {
                    if (!Array.isArray(elements)) {
                        throw new Error('Invalid response format');
                    }
                    const elementTypesMap = {};
                    elements.forEach(elem => {
                        if (elem.element && !elementTypesMap[elem.element]) {
                            elementTypesMap[elem.element] = {
                                id: elem.id,
                                name: elem.element,
                                image: elem.image_url || `/images/Shape-${elem.element}.svg`
                            };
                        }
                    });
                    
                    console.log('Element types map:', Object.keys(elementTypesMap));
                    console.log('Valid element types to add:', Array.from(validElementTypes.keys()));
                    
                    const submenu = document.getElementById('relatedElementsSubmenu');
                    submenu.innerHTML = '';
                    
                    // Convert Map to array and sort by relationship type first, then by element name
                    const sortedItems = Array.from(validElementTypes.entries())
                        .map(([elementType, info]) => ({
                            elementType,
                            info,
                            typeInfo: elementTypesMap[elementType]
                        }))
                        .filter(item => item.typeInfo) // Filter out items without typeInfo
                        .sort((a, b) => {
                            // First sort by relationship type
                            const relationshipCompare = (a.info.relationshipType || '').localeCompare(b.info.relationshipType || '');
                            if (relationshipCompare !== 0) {
                                return relationshipCompare;
                            }
                            // Then sort by element name
                            return (a.typeInfo.name || '').localeCompare(b.typeInfo.name || '');
                        });
                    
                    sortedItems.forEach(({ elementType, info, typeInfo }) => {
                        console.log('Processing valid element type:', elementType, 'info:', info);
                        console.log('Adding to submenu:', elementType, typeInfo);
                        
                        const item = document.createElement('div');
                        item.style.cssText = `
                            padding: 6px 10px;
                            cursor: pointer;
                            font-size: 11px;
                            color: #ffffff;
                            transition: background 0.2s;
                            display: flex;
                            align-items: center;
                            gap: 8px;
                        `;
                        item.innerHTML = `
                            <img src="${typeInfo.image}" alt="${typeInfo.name}" 
                                 style="width: 16px; height: 16px; object-fit: contain; flex-shrink: 0;"
                                 onerror="this.src='/images/Shape-${typeInfo.name}.svg'; this.onerror=null;">
                            <span style="flex: 1;">${typeInfo.name}</span>
                            <span style="color: #888; font-size: 10px;">${info.relationshipType}</span>
                        `;
                        
                        item.addEventListener('mouseenter', () => {
                            item.style.background = '#353550';
                        });
                        
                        item.addEventListener('mouseleave', () => {
                            item.style.background = 'transparent';
                        });
                        
                        item.addEventListener('click', () => {
                            createRelatedElementInstance(elementId, typeInfo.id, typeInfo.name, typeInfo.image, info.relationshipType, info.isReverse);
                            closeContextMenu();
                        });
                        
                        submenu.appendChild(item);
                    });
                })
                .catch(error => {
                    console.error('Error loading element types:', error);
                    // Hide the menu item if loading fails
                    const addRelatedMenuItem = document.getElementById('addRelatedElementMenuItem');
                    if (addRelatedMenuItem) {
                        addRelatedMenuItem.style.display = 'none';
                    }
                    const submenu = document.getElementById('relatedElementsSubmenu');
                    if (submenu) {
                        submenu.innerHTML = '<div style="padding: 8px; color: #ff0000; font-size: 10px;">Error loading elements</div>';
                    }
                });
        }
        
        // Show related elements submenu
        function showRelatedElementsSubmenu() {
            const submenu = document.getElementById('relatedElementsSubmenu');
            const menuItem = document.getElementById('addRelatedElementMenuItem');
            if (submenu && submenu.children.length > 0) {
                submenu.style.display = 'block';
                // Position submenu
                const rect = menuItem.getBoundingClientRect();
                submenu.style.top = '0px';
            }
        }
        
        // Hide related elements submenu
        function hideRelatedElementsSubmenu() {
            const submenu = document.getElementById('relatedElementsSubmenu');
            if (submenu) {
                // Delay hiding to allow moving to submenu
                setTimeout(() => {
                    if (!submenu.matches(':hover') && !document.getElementById('addRelatedElementMenuItem').matches(':hover')) {
                        submenu.style.display = 'none';
                    }
                }, 100);
            }
        }
        
        // Show relationship context menu
        function showRelationshipContextMenu(e, relationshipIndex) {
            console.log('showRelationshipContextMenu called', relationshipIndex, 'event:', e);
            contextMenuRelationshipIndex = relationshipIndex;
            contextMenuElementId = null;
            const menu = document.getElementById('relationshipContextMenu');
            if (!menu) {
                console.error('Relationship context menu element not found');
                return;
            }
            const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] ? e.touches[0].clientX : window.innerWidth / 2);
            const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] ? e.touches[0].clientY : window.innerHeight / 2);
            
            menu.style.display = 'block';
            menu.style.left = clientX + 'px';
            menu.style.top = clientY + 'px';
            console.log('Relationship context menu displayed at', clientX, clientY);
            
            // Hide element menu if visible
            const elementMenu = document.getElementById('elementContextMenu');
            if (elementMenu) {
                elementMenu.style.display = 'none';
            }
            
            // Hide property menu if visible
            const propertyMenu = document.getElementById('propertyContextMenu');
            if (propertyMenu) {
                document.body.removeChild(propertyMenu);
            }
            
            // Close menu when clicking elsewhere
            setTimeout(() => {
                document.addEventListener('click', closeRelationshipContextMenu, { once: true });
                document.addEventListener('contextmenu', (evt) => {
                    if (evt.target !== menu && !menu.contains(evt.target)) {
                        closeRelationshipContextMenu();
                    }
                }, { once: true });
            }, 10);
        }
        
        // Close context menu
        function closeContextMenu() {
            const menu = document.getElementById('elementContextMenu');
            if (menu) {
            menu.style.display = 'none';
            }
            const relatedSubmenu = document.getElementById('relatedElementsSubmenu');
            if (relatedSubmenu) {
                relatedSubmenu.style.display = 'none';
            }
            const propertiesSubmenu = document.getElementById('propertiesSubmenu');
            if (propertiesSubmenu) {
                propertiesSubmenu.style.display = 'none';
            }
            contextMenuElementId = null;
        }

        
        // Close relationship context menu
        function closeRelationshipContextMenu() {
            const menu = document.getElementById('relationshipContextMenu');
            menu.style.display = 'none';
            contextMenuRelationshipIndex = null;
        }
        
        // Delete relationship
        function deleteRelationship() {
            const relationshipIndex = contextMenuRelationshipIndex;
            closeRelationshipContextMenu();
            
            if (relationshipIndex === null || relationshipIndex === undefined) return;
            
            const relationship = canvasState.relationships[relationshipIndex];
            if (!relationship) return;
            
            // Save undo state before deletion
            saveStateForUndo();
            
            // Remove relationship from state
            canvasState.relationships.splice(relationshipIndex, 1);
            
            // Update connections
            debouncedUpdateConnections();
            updateCanvasInfo();
            updateUndoRedoButtons();
        }
        
        // Show element information
        async function showElementInfo() {
            const elementId = contextMenuElementId;
            closeContextMenu();
            if (!elementId) return;
            
            const element = canvasState.elements.find(e => e.id === elementId);
            if (!element) return;
            
            try {
                const response = await fetch(`/api/records/${element.element_type_id}`);
                if (!response.ok) throw new Error('Failed to load element info');
                
                const elementData = await response.json();
                const content = document.getElementById('elementInfoContent');
                const saveBtn = document.getElementById('saveElementInfoBtn');
                
                // Store element ID for saving
                content.dataset.elementId = elementId;
                
                content.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; color: #e0e0e0; margin-bottom: 8px; font-size: 14px; font-weight: 600;">Element Type</label>
                        <div style="color: #ffffff; font-size: 14px;">${escapeHtml(elementData.element || element.element_type || 'N/A')}</div>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; color: #e0e0e0; margin-bottom: 8px; font-size: 14px; font-weight: 600;">Instance Name</label>
                        <div style="color: #ffffff; font-size: 14px;">${escapeHtml(element.instance_name)}</div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; color: #e0e0e0; margin-bottom: 8px; font-size: 14px; font-weight: 600;">Instance Description</label>
                        <textarea id="elementInstanceDescription" 
                                  onblur="saveElementInstanceDescriptionOnBlur()"
                                  style="width: 100%; padding: 10px; border: 1px solid #3e3e42; border-radius: 6px; background: #1e1e1e; color: #e0e0e0; font-size: 14px; min-height: 120px; resize: vertical; font-family: inherit; box-sizing: border-box;"
                                  placeholder="Enter description for this element instance...">${escapeHtml((element.description !== undefined && element.description !== null) ? element.description : '')}</textarea>
                    </div>
                `;
                
                if (saveBtn) {
                    saveBtn.style.display = 'block';
                }
                
                document.getElementById('elementInfoModal').style.display = 'flex';
            } catch (error) {
                alert('Error loading element information: ' + error.message);
            }
        }
        
        // Save element instance description on blur
        async function saveElementInstanceDescriptionOnBlur() {
            const content = document.getElementById('elementInfoContent');
            const elementId = parseInt(content.dataset.elementId);
            if (!elementId) return;
            
            const element = canvasState.elements.find(e => e.id === elementId);
            if (!element) return;
            
            // Check if element is saved to database (has database ID, typically >= 1000 or from loaded model)
            // If element hasn't been saved yet, just update canvasState (will be saved when model is saved)
            const isSavedToDatabase = canvasState.currentModelId && elementId >= 1000;
            
            const descriptionInput = document.getElementById('elementInstanceDescription');
            const description = descriptionInput ? descriptionInput.value.trim() : '';
            
            // Always update canvasState
            if (element) {
                element.description = description;
            }
            
            // Only save to database if element is already saved
            if (isSavedToDatabase) {
                try {
                    const response = await fetch(`/api/canvas/element-instances/${elementId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ description: description })
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        let errorMessage = 'Failed to save description';
                        try {
                            const errorJson = JSON.parse(errorText);
                            errorMessage = errorJson.error || errorMessage;
                        } catch (e) {
                            errorMessage = `HTTP ${response.status}: ${errorText}`;
                        }
                        console.error('Error saving description to database:', errorMessage);
                        // Don't show error toast on blur - user can see it if they try to save manually
                    }
                } catch (error) {
                    console.error('Error saving description:', error);
                    // Don't show error toast on blur - user can see it if they try to save manually
                }
            }
        }
        
        // Save element instance info (description)
        async function saveElementInstanceInfo() {
            const content = document.getElementById('elementInfoContent');
            const elementId = parseInt(content.dataset.elementId);
            if (!elementId) return;
            
            const descriptionInput = document.getElementById('elementInstanceDescription');
            const description = descriptionInput ? descriptionInput.value.trim() : '';
            
            try {
                const response = await fetch(`/api/canvas/element-instances/${elementId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ description: description })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to save description');
                }
                
                // Update element in canvasState
                const element = canvasState.elements.find(e => e.id === elementId);
                if (element) {
                    element.description = description;
                }
                
                showCanvasToast('Element instance description saved successfully', 'success');
                closeElementInfoModal();
            } catch (error) {
                showCanvasToast('Error saving description: ' + error.message, 'error');
            }
        }
        
        function closeElementInfoModal() {
            document.getElementById('elementInfoModal').style.display = 'none';
        }
        
        // Show tooltip with description when hovering over Info button
        function showInfoTooltip(event) {
            const elementId = contextMenuElementId;
            if (!elementId) return;
            
            const element = canvasState.elements.find(e => e.id === elementId);
            if (!element) return;
            
            const description = element.description || 'No description';
            const tooltip = document.getElementById('infoTooltip');
            if (!tooltip) return;
            
            tooltip.textContent = description;
            tooltip.style.display = 'block';
            
            // Position tooltip near the mouse cursor
            const menu = document.getElementById('elementContextMenu');
            if (menu) {
                const menuRect = menu.getBoundingClientRect();
                tooltip.style.left = (menuRect.right + 10) + 'px';
                tooltip.style.top = (menuRect.top) + 'px';
            } else {
                tooltip.style.left = (event.clientX + 10) + 'px';
                tooltip.style.top = (event.clientY + 10) + 'px';
            }
        }
        
        // Hide tooltip
        function hideInfoTooltip() {
            const tooltip = document.getElementById('infoTooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }
        
        // View element properties
        // Add property to element
        // Show add property submenu
        async function confirmAddProperty() {
            const elementInstanceId = document.getElementById('addPropertyModal').dataset.elementInstanceId;
            const name = document.getElementById('propertyNameInput').value.trim();
            const description = document.getElementById('propertyDescriptionInput').value.trim();
            const ragType = document.getElementById('propertyRAGTypeInput').value;
            
            if (!name) {
                alert('Please enter a property name');
                return;
            }
            
            // Find the element instance
            const element = canvasState.elements.find(e => e.id === parseInt(elementInstanceId));
            if (!element) {
                alert('Element instance not found');
                return;
            }
            
            // Initialize properties array if it doesn't exist
            if (!element.properties) {
                element.properties = [];
            }
            
            // Add property to element instance
            const newProperty = {
                propertyname: name,
                description: description || null,
                ragtype: ragType || null,
                image_url: getTagImageFromRAG(ragType) || null
            };
            
            element.properties.push(newProperty);
            
            // Re-render element to show properties image
            const elementDiv = document.getElementById(`element-${element.id}`);
            if (elementDiv) {
                elementDiv.remove();
            }
            renderElement(element);
            
            saveStateForUndo(); // Save state after adding property
            updateUndoRedoButtons();
            
            closeAddPropertyModal();
            alert('Property added successfully!');
        }
        
        function closeAddPropertyModal() {
            document.getElementById('addPropertyModal').style.display = 'none';
            document.getElementById('addPropertyModal').dataset.elementInstanceId = '';
        }
        
        // Show add related element modal
        function showAddRelatedElementModal() {
            const elementId = contextMenuElementId;
            closeContextMenu();
            if (!elementId) return;
            
            const element = canvasState.elements.find(e => e.id === elementId);
            if (!element) return;
            
            // Update source name
            document.getElementById('relatedElementSourceName').textContent = element.instance_name;
            
            // Find valid element types that can be related to this element
            const validElementTypes = new Map(); // Map<elementType, {relationshipType, isReverse}>
            
            canvasState.relationshipRules.forEach(rule => {
                // Check if current element can be source
                if (element.element_type === rule.source_element_type) {
                    if (!validElementTypes.has(rule.target_element_type)) {
                        validElementTypes.set(rule.target_element_type, {
                            relationshipType: rule.relationship_type,
                            targetType: rule.target_element_type,
                            isReverse: false
                        });
                    }
                }
                // Check if current element can be target (reverse relationship)
                if (element.element_type === rule.target_element_type) {
                    if (!validElementTypes.has(rule.source_element_type)) {
                        validElementTypes.set(rule.source_element_type, {
                            relationshipType: rule.relationship_type,
                            targetType: rule.source_element_type,
                            isReverse: true
                        });
                    }
                }
            });
            
            if (validElementTypes.size === 0) {
                alert(`No valid relationships exist for ${element.element_type} elements.`);
                return;
            }
            
            // Load all element types from API to get their IDs and images
            fetch('/api/records')
                .then(response => response.json())
                .then(elements => {
                    const elementTypesMap = {};
                    elements.forEach(elem => {
                        if (elem.element && !elementTypesMap[elem.element]) {
                            elementTypesMap[elem.element] = {
                                id: elem.id,
                                name: elem.element,
                                image: elem.image_url || `/images/Shape-${elem.element}.svg`
                            };
                        }
                    });
                    
                    // Populate modal with valid element types
                    const listContainer = document.getElementById('relatedElementTypesList');
                    listContainer.innerHTML = '';
                    
                    validElementTypes.forEach((info, elementType) => {
                        const typeInfo = elementTypesMap[elementType];
                        if (!typeInfo) return;
                        
                        const card = document.createElement('div');
                        card.style.cssText = `
                            background: #1e1e1e;
                            border: 1px solid rgba(255,255,255,0.1);
                            border-radius: 6px;
                            padding: 12px;
                            cursor: pointer;
                            text-align: center;
                            transition: all 0.2s;
                            user-select: none;
                        `;
                        card.innerHTML = `
                            <img src="${typeInfo.image}" alt="${typeInfo.name}" 
                                 style="width: 64px; height: 64px; margin-bottom: 8px; object-fit: contain;"
                                 onerror="this.src='/images/Shape-${typeInfo.name}.svg'; this.onerror=null;">
                            <div style="color: #ffffff; font-size: 12px; font-weight: 500; margin-bottom: 4px;">${typeInfo.name}</div>
                            <div style="color: #a0a0a0; font-size: 10px;">${info.relationshipType}</div>
                        `;
                        
                        card.addEventListener('mouseenter', () => {
                            card.style.background = '#252550';
                            card.style.transform = 'scale(1.05)';
                        });
                        
                        card.addEventListener('mouseleave', () => {
                            card.style.background = '#1e1e1e';
                            card.style.transform = 'scale(1)';
                        });
                        
                        card.addEventListener('click', () => {
                            createRelatedElementInstance(elementId, typeInfo.id, typeInfo.name, typeInfo.image, info.relationshipType, info.isReverse);
                        });
                        
                        listContainer.appendChild(card);
                    });
                    
                    document.getElementById('addRelatedElementModal').style.display = 'flex';
                })
                .catch(error => {
                    console.error('Error loading element types:', error);
                    alert('Error loading element types. Please try again.');
                });
        }
        
        // Check if a position overlaps with existing elements
        function isPositionClear(x, y, width, height, excludeElementId = null) {
            const padding = 20; // Minimum gap between elements
            const checkX = x - padding;
            const checkY = y - padding;
            const checkWidth = width + (padding * 2);
            const checkHeight = height + (padding * 2);
            
            for (const existingElement of canvasState.elements) {
                if (excludeElementId && existingElement.id === excludeElementId) {
                    continue;
                }
                
                // Check for overlap
                if (!(checkX + checkWidth <= existingElement.x_position ||
                      checkX >= existingElement.x_position + existingElement.width ||
                      checkY + checkHeight <= existingElement.y_position ||
                      checkY >= existingElement.y_position + existingElement.height)) {
                    return false; // Overlap detected
                }
            }
            return true; // Position is clear
        }
        
        // Find a clear position near the source element
        function findClearPosition(sourceElement, elementWidth, elementHeight) {
            const baseOffsetX = 180; // 120px width + 60px gap
            const baseOffsetY = 0;
            const maxAttempts = 50; // Maximum number of positions to try
            const gridStep = GRID_SIZE;
            
            // Try positions in a spiral pattern around the source element
            const offsets = [
                { x: baseOffsetX, y: baseOffsetY }, // Right
                { x: baseOffsetX, y: -baseOffsetX }, // Right-Up
                { x: 0, y: -baseOffsetX }, // Up
                { x: -baseOffsetX, y: -baseOffsetX }, // Left-Up
                { x: -baseOffsetX, y: 0 }, // Left
                { x: -baseOffsetX, y: baseOffsetX }, // Left-Down
                { x: 0, y: baseOffsetX }, // Down
                { x: baseOffsetX, y: baseOffsetX }, // Right-Down
            ];
            
            // Try initial offsets
            for (const offset of offsets) {
                const rawX = sourceElement.x_position + offset.x;
                const rawY = sourceElement.y_position + offset.y;
                const snappedPos = snapElementToGrid(rawX, rawY, elementWidth, elementHeight);
                
                if (isPositionClear(snappedPos.x, snappedPos.y, elementWidth, elementHeight, sourceElement.id)) {
                    return snappedPos;
                }
            }
            
            // If initial positions are occupied, try expanding spiral pattern
            for (let radius = 2; radius <= 10; radius++) {
                const radiusPixels = radius * gridStep;
                for (let angle = 0; angle < 8; angle++) {
                    const angleRad = (angle * Math.PI) / 4;
                    const offsetX = Math.round(Math.cos(angleRad) * radiusPixels);
                    const offsetY = Math.round(Math.sin(angleRad) * radiusPixels);
                    
                    const rawX = sourceElement.x_position + offsetX;
                    const rawY = sourceElement.y_position + offsetY;
                    const snappedPos = snapElementToGrid(rawX, rawY, elementWidth, elementHeight);
                    
                    if (isPositionClear(snappedPos.x, snappedPos.y, elementWidth, elementHeight, sourceElement.id)) {
                        return snappedPos;
                    }
                }
            }
            
            // Fallback: place far to the right
            const fallbackX = sourceElement.x_position + 300;
            const fallbackY = sourceElement.y_position;
            return snapElementToGrid(fallbackX, fallbackY, elementWidth, elementHeight);
        }
        
        // Create related element instance with only one relationship
        function createRelatedElementInstance(sourceElementId, elementTypeId, elementType, elementImage, relationshipType, isReverse) {
            closeAddRelatedElementModal();
            
            const sourceElement = canvasState.elements.find(e => e.id === sourceElementId);
            if (!sourceElement) return;
            
            // People elements are smaller (60x60, 50% of standard size)
            const isPeople = elementType && elementType.toLowerCase() === 'people';
            const elementWidth = isPeople ? 60 : 120;
            const elementHeight = isPeople ? 60 : 120;
            
            // Find a clear position
            const position = findClearPosition(sourceElement, elementWidth, elementHeight);
            
            // Create new element instance
            const elementId = canvasState.nextElementId++;
            const instanceName = `${elementType} ${elementId}`;
            
            const element = {
                id: elementId,
                element_type_id: elementTypeId,
                element_type: elementType,
                instance_name: instanceName,
                x_position: position.x,
                y_position: position.y,
                width: elementWidth,
                height: elementHeight,
                image_url: elementImage
            };
            
            canvasState.elements.push(element);
            renderElement(element);
            updateCanvasInfo();
            
            // Create ONLY the relationship between source and new element
            if (isReverse) {
                // New element is source, original element is target
                createConnection(elementId, sourceElementId, relationshipType);
            } else {
                // Original element is source, new element is target
                createConnection(sourceElementId, elementId, relationshipType);
            }
        }
        
        // Close add related element modal
        function closeAddRelatedElementModal() {
            document.getElementById('addRelatedElementModal').style.display = 'none';
            document.getElementById('relatedElementTypesList').innerHTML = '';
        }
        
        // Delete element instance (supports multi-select)
        function deleteElementInstance() {
            const elementId = contextMenuElementId;
            closeContextMenu();
            
            // If there are selected elements, delete all selected
            if (canvasState.selectedElementIds.length > 0) {
                deleteSelectedElements();
                return;
            }
            
            // Otherwise delete single element from context menu
            if (!elementId) return;
            
            const element = canvasState.elements.find(e => e.id === elementId);
            if (!element) return;
            
            saveStateForUndo(); // Save state before deletion
            
            // Remove associated property instances
            const propertiesToDelete = canvasState.propertyInstances.filter(
                p => p.element_instance_id === elementId
            );
            propertiesToDelete.forEach(prop => {
                const propDiv = document.getElementById(`property-${prop.id}`);
                if (propDiv) propDiv.remove();
            });
            canvasState.propertyInstances = canvasState.propertyInstances.filter(
                p => p.element_instance_id !== elementId
            );
            
            // Remove element from state
            canvasState.elements = canvasState.elements.filter(e => e.id !== elementId);
            updateCanvasInfo();
            
            // Remove relationships involving this element
            canvasState.relationships = canvasState.relationships.filter(r => 
                r.source_instance_id !== elementId && r.target_instance_id !== elementId
            );
            
            // Remove element from DOM
            const elementDiv = document.getElementById(`element-${elementId}`);
            if (elementDiv) {
                elementDiv.remove();
            }
            
            // Update connections
            debouncedUpdateConnections();
            updateCanvasInfo();
            updateUndoRedoButtons();
        }
        
        // Load enterprise definitions when section is shown
        const originalShowSection = window.showSection;
        window.showSection = function(sectionId) {
            if (typeof originalShowSection === 'function') {
                originalShowSection(sectionId);
            }
            if (sectionId === 'modelingCanvas') {
                setTimeout(initCanvas, 100);
            }
        };
        // ========================================================================
        // Modeling Canvas Functionality
        // ========================================================================
        
        let canvasState = {
            propertyInstances: [],
            nextPropertyInstanceId: 1,
            elements: [],
            relationships: [],
            nextElementId: 1,
            zoom: 1.0,
            panX: 0,
            panY: 0,
            currentModelId: null,
            currentModelName: null, // Track loaded model name
            relationshipRules: [],
            isDragging: false,
            dragOffset: { x: 0, y: 0 },
            theme: localStorage.getItem('canvasTheme') || 'dark', // 'dark' or 'light'
            isFullscreen: false,
            showGridlines: localStorage.getItem('canvasShowGridlines') !== 'false', // Default to true, load from localStorage
            selectedElementId: null, // For relationship creation
            selectedElementIds: [], // Multi-select support
            undoHistory: [], // Undo/Redo history (max 3)
            redoHistory: [], // Redo history
            // Layer visibility states
            layerVisibility: {
                elements: localStorage.getItem('canvasLayerElements') !== 'false',
                properties: localStorage.getItem('canvasLayerProperties') !== 'false',
                connections: localStorage.getItem('canvasLayerConnections') !== 'false',
                grid: localStorage.getItem('canvasLayerGrid') !== 'false',
                minimap: localStorage.getItem('canvasLayerMinimap') !== 'false'
            },
            // Snap guides state
            snapGuidesEnabled: localStorage.getItem('canvasSnapGuides') !== 'false',
            // Snap to grid state
            snapToGridEnabled: localStorage.getItem('canvasSnapToGrid') !== 'false', // Default to true
            // Element shadows state
            elementShadowsEnabled: localStorage.getItem('canvasElementShadows') !== 'false', // Default to true
            snapThreshold: 10, // pixels threshold for snapping
            // Auto-create relationships when dropping elements
            autoCreateRelationships: localStorage.getItem('canvasAutoCreateRelationships') !== 'false', // Default to true
            // Canvas template background
            canvasTemplate: localStorage.getItem('canvasTemplate') || 'none', // Template name or 'none'
            // Template selection and independent zoom/pan
            templateSelected: false, // Whether template is currently selected
            templateZoom: parseFloat(localStorage.getItem('templateZoom')) || 1.0, // Independent zoom for template
            templatePanX: parseFloat(localStorage.getItem('templatePanX')) || 0, // Independent pan X for template
            templatePanY: parseFloat(localStorage.getItem('templatePanY')) || 0, // Independent pan Y for template
            // Template segments configuration
            templateSegments: [], // Array of {segment_index, segment_name}
            templateSegmentCount: 4, // Default number of segments
            elementSegmentAssociations: {} // Map of element_instance_id -> segment_index
        };

        const EDGLY_NOTIFICATIONS_KEY = 'edglyNotificationsEnabled';
        let edglyNotificationsEnabled = localStorage.getItem(EDGLY_NOTIFICATIONS_KEY);
        edglyNotificationsEnabled = edglyNotificationsEnabled !== 'false';

        function updateEdglyNotificationsToggle() {
            const toggleLabel = document.getElementById('edglyNotificationsToggle');
            if (toggleLabel) {
                toggleLabel.textContent = `EDGly Notifications: ${edglyNotificationsEnabled ? 'On' : 'Off'}`;
            }
        }

        let edglyBubbleTimeoutId = null;

        function updateEdglyCommentaryBubble(message, show = true) {
            const bubble = document.getElementById('edglyCommentaryBubble');
            if (!bubble) return;
            if (edglyBubbleTimeoutId) {
                clearTimeout(edglyBubbleTimeoutId);
                edglyBubbleTimeoutId = null;
            }
            if (!edglyNotificationsEnabled || !show || !message) {
                bubble.textContent = '';
                bubble.classList.remove('visible');
                return;
            }
            bubble.textContent = message;
            bubble.classList.add('visible');
            edglyBubbleTimeoutId = setTimeout(() => {
                bubble.textContent = '';
                bubble.classList.remove('visible');
                edglyBubbleTimeoutId = null;
            }, 30000);
        }

        function updateEdglyBubbleTheme() {
            const bubble = document.getElementById('edglyCommentaryBubble');
            if (!bubble) return;
            const isDarkTheme = canvasState.theme === 'dark';
            bubble.style.color = isDarkTheme ? '#ffffff' : '#1f1f1f';
            bubble.style.borderColor = isDarkTheme ? 'rgba(255, 255, 255, 0.35)' : 'rgba(0, 0, 0, 0.35)';
        }

        function toggleEdglyNotifications() {
            edglyNotificationsEnabled = !edglyNotificationsEnabled;
            localStorage.setItem(EDGLY_NOTIFICATIONS_KEY, edglyNotificationsEnabled);
            updateEdglyNotificationsToggle();
            if (!edglyNotificationsEnabled) {
                updateEdglyCommentaryBubble('', false);
            }
        }

        function triggerEdglyAttention() {
            const avatar = document.querySelector('#askedChatbotButton .edgly-avatar');
            if (!avatar) return;
            avatar.classList.remove('edgly-wiggle');
            void avatar.offsetWidth;
            avatar.classList.add('edgly-wiggle');
            setTimeout(() => avatar.classList.remove('edgly-wiggle'), 3800);
        }
        
        // Toggle auto-create relationships setting
        function toggleAutoCreateRelationships() {
            canvasState.autoCreateRelationships = !canvasState.autoCreateRelationships;
            localStorage.setItem('canvasAutoCreateRelationships', canvasState.autoCreateRelationships);
            updateAutoCreateRelationshipsMenuItem();
        }
        
        // Update the menu item display for auto-create relationships
        function updateAutoCreateRelationshipsMenuItem() {
            const menuItem = document.getElementById('autoCreateRelationshipsMenuItem');
            const textSpan = document.getElementById('autoCreateRelationshipsText');
            const checkmark = document.getElementById('autoCreateRelationshipsCheckmark');
            
            if (menuItem && textSpan && checkmark) {
                if (canvasState.autoCreateRelationships) {
                    textSpan.textContent = 'Auto-Create Relationships';
                    checkmark.style.display = 'inline';
                } else {
                    textSpan.textContent = 'Auto-Create Relationships';
                    checkmark.style.display = 'none';
                }
            }
        }
        
        // Update canvas info display (element/relationship counts)
        function updateCanvasInfo() {
            const elementCount = canvasState.elements.length;
            const relationshipCount = canvasState.relationships.length;
            const modelName = canvasState.currentModelName || 'Untitled Model';
            
            const elementCountEl = document.getElementById('canvasElementCount');
            const relationshipCountEl = document.getElementById('canvasRelationshipCount');
            const modelNameEl = document.getElementById('canvasModelName');
            
            if (elementCountEl) {
                elementCountEl.textContent = `${elementCount} Element${elementCount !== 1 ? 's' : ''}`;
            }
            if (relationshipCountEl) {
                relationshipCountEl.textContent = `${relationshipCount} Relationship${relationshipCount !== 1 ? 's' : ''}`;
            }
            if (modelNameEl) {
                modelNameEl.textContent = modelName;
            }
            
            // Update empty state visibility (disabled - hints removed)
            const emptyState = document.getElementById('canvasEmptyState');
            if (emptyState) {
                emptyState.style.display = 'none'; // Always hidden
            }
            
            // Update minimap
            updateMinimap();
        }
        
        // Track if any element is currently being dragged
        let isAnyElementDragging = false;
        
        // Debounced updateConnections for better performance (when not dragging)
        let connectionUpdateTimeout = null;
        function debouncedUpdateConnections() {
            // If dragging, update immediately without debounce
            if (isAnyElementDragging) {
                updateConnections();
                return;
            }
            
            if (connectionUpdateTimeout) {
                clearTimeout(connectionUpdateTimeout);
            }
            connectionUpdateTimeout = setTimeout(() => {
                updateConnections();
                connectionUpdateTimeout = null;
            }, 100); // Debounce by 100ms
        }
        
        // Initialize canvas when section is shown
        function initCanvas() {
            // Check if required elements exist before proceeding
            const canvasContainer = document.getElementById('canvasContainer');
            if (!canvasContainer) {
                console.warn('Canvas container not found, delaying initialization');
                setTimeout(initCanvas, 100);
                return;
            }
            
            try {
                // Clear template on startup (before other setup)
                canvasState.canvasTemplate = 'none';
                canvasState.templateZoom = 1.0;
                canvasState.templatePanX = 0;
                canvasState.templatePanY = 0;
                canvasState.templateSegments = [];
                canvasState.templateSegmentCount = 4;
                localStorage.removeItem('canvasTemplate');
                localStorage.removeItem('templateZoom');
                localStorage.removeItem('templatePanX');
                localStorage.removeItem('templatePanY');
                
                // Clear template layer safely
                try {
                    const templateLayer = document.getElementById('templateLayer');
                    if (templateLayer) {
                        templateLayer.style.display = 'none';
                        templateLayer.innerHTML = '';
                    }
                } catch (e) {
                    console.warn('Error clearing template layer:', e);
                }
                
                // Load data (these functions should handle missing elements gracefully)
                if (typeof loadElementTypes === 'function') {
                    loadElementTypes();
                }
                if (typeof loadPropertiesForPalette === 'function') {
                    loadPropertiesForPalette();
                }
                if (typeof loadTemplatesForPalette === 'function') {
                    loadTemplatesForPalette();
                }
                if (typeof loadRelationshipRules === 'function') {
                    loadRelationshipRules();
                }
                if (typeof initPaletteSections === 'function') {
                    initPaletteSections();
                }
                
                // Setup event listeners
                if (typeof updateZoomDisplay === 'function') {
                    updateZoomDisplay();
                }
                if (typeof setupCanvasEventListeners === 'function') {
                    setupCanvasEventListeners();
                }
                if (typeof setupContextMenuEventListeners === 'function') {
                    setupContextMenuEventListeners();
                }
                if (typeof applyCanvasTheme === 'function') {
                    applyCanvasTheme();
                }
                if (typeof updateChatbotButtonSVG === 'function') {
                    updateChatbotButtonSVG();
                }
                
                // Setup template handlers
                if (typeof setupTemplateResizeObserver === 'function') {
                    setupTemplateResizeObserver();
                }
                if (typeof setupTemplateSelection === 'function') {
                    setupTemplateSelection();
                }
                
                // Load element-segment associations
                if (typeof loadElementSegmentAssociations === 'function') {
                    loadElementSegmentAssociations();
                }
                if (typeof updateUndoRedoButtons === 'function') {
                    updateUndoRedoButtons();
                }
                if (typeof updateCanvasInfo === 'function') {
                    updateCanvasInfo();
                }
                if (typeof updateAutoCreateRelationshipsMenuItem === 'function') {
                    updateAutoCreateRelationshipsMenuItem();
                }
            } catch (error) {
                console.error('Error initializing canvas:', error);
                console.error('Error stack:', error.stack);
                // Continue with initialization even if there's an error
            }
            
            // Initialize gridlines icon
            const gridlinesIcon = document.getElementById('gridlinesToggleIcon');
            if (gridlinesIcon) {
                gridlinesIcon.textContent = canvasState.showGridlines ? '' : '';
            }
            
            // Setup element search
            setupElementSearch();
            
            // Setup keyboard shortcuts
            setupKeyboardShortcuts();
            
            // Setup minimap
            setupMinimap();
            
            // Setup layer management
            setupLayerManagement();
            
            // Setup snap guides
            setupSnapGuides();
            
            // Setup AskED chatbot modal
            setupAskedChatbotModal();
            
            // Setup palette positioning
            setupPalettePositioning();
        }
        
        // Palette Positioning Functions
        function setupPalettePositioning() {
            const palette = document.getElementById('elementPalette');
            const paletteHeader = document.getElementById('paletteHeader');
            const mainContainer = document.getElementById('canvasMainContainer');
            if (!palette || !paletteHeader || !mainContainer) return;
            
            // Load saved position preference
            let savedPosition = localStorage.getItem('palettePosition') || 'left';
            // Convert old top/bottom positions to left
            if (savedPosition === 'top' || savedPosition === 'bottom') {
                savedPosition = 'left';
                localStorage.setItem('palettePosition', 'left');
            }
            const savedFloatingPos = localStorage.getItem('paletteFloatingPos');
            
            // Set initial position
            applyPalettePosition(savedPosition, savedFloatingPos);
            
            // Add click handlers for position buttons
            const positionButtons = document.querySelectorAll('.palette-position-btn');
            positionButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const position = btn.getAttribute('data-position');
                    applyPalettePosition(position);
                    // Update active button
                    positionButtons.forEach(b => {
                        b.style.background = b === btn ? '#3d3d54' : '#1a1a2e';
                    });
                });
            });
            
            // Setup drag functionality for floating mode
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };
            
            paletteHeader.addEventListener('mousedown', (e) => {
                const currentPosition = localStorage.getItem('palettePosition') || 'left';
                if (currentPosition === 'floating') {
                    isDragging = true;
                    const rect = palette.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    palette.style.cursor = 'move';
                    e.preventDefault();
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const palette = document.getElementById('elementPalette');
                    if (palette) {
                        const x = e.clientX - dragOffset.x;
                        const y = e.clientY - dragOffset.y;
                        palette.style.left = `${x}px`;
                        palette.style.top = `${y}px`;
                        // Save floating position
                        localStorage.setItem('paletteFloatingPos', JSON.stringify({ x, y }));
                    }
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    const palette = document.getElementById('elementPalette');
                    if (palette) {
                        palette.style.cursor = '';
                    }
                }
            });
        }
        
        // Make function globally accessible
        window.applyPalettePosition = function(position, floatingPos = null) {
            const palette = document.getElementById('elementPalette');
            const mainContainer = document.getElementById('canvasMainContainer');
            if (!palette || !mainContainer) return;
            
            // Save position preference
            localStorage.setItem('palettePosition', position);
            
            // Reset all styles
            palette.style.position = '';
            palette.style.top = '';
            palette.style.bottom = '';
            palette.style.left = '';
            palette.style.right = '';
            palette.style.width = '';
            palette.style.height = '';
            palette.style.minWidth = '';
            palette.style.maxWidth = '';
            palette.style.zIndex = '';
            palette.style.margin = '';
            palette.style.alignSelf = '';
            mainContainer.style.flexDirection = '';
            mainContainer.style.alignItems = '';
            
            const paletteHeader = document.getElementById('paletteHeader');
            if (paletteHeader) {
                paletteHeader.style.cursor = position === 'floating' ? 'move' : 'default';
            }
            
            // Update active button
            const positionButtons = document.querySelectorAll('.palette-position-btn');
            positionButtons.forEach(btn => {
                const btnPosition = btn.getAttribute('data-position');
                btn.style.background = btnPosition === position ? '#3d3d54' : '#1a1a2e';
            });
            
            if (position === 'floating') {
                // Floating mode - position absolutely
                palette.style.position = 'fixed';
                // Use higher z-index to ensure it's above canvas elements
                palette.style.zIndex = '10001';
                palette.style.width = '180px';
                palette.style.height = 'auto';
                palette.style.maxHeight = '80vh';
                palette.style.display = 'flex';
                palette.style.flexDirection = 'column';
                palette.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
                
                if (floatingPos) {
                    try {
                        const pos = JSON.parse(floatingPos);
                        palette.style.left = `${pos.x}px`;
                        palette.style.top = `${pos.y}px`;
                    } catch (e) {
                        // Default position if parsing fails
                        palette.style.left = '20px';
                        palette.style.top = '100px';
                    }
                } else {
                    palette.style.left = '20px';
                    palette.style.top = '100px';
                }
                
                // Remove from flex container
                if (palette.parentNode === mainContainer) {
                    mainContainer.removeChild(palette);
                    // Append to canvas section if in fullscreen, otherwise to body
                    const canvasSection = document.getElementById('modelingCanvas');
                    if (canvasSection && canvasState.isFullscreen) {
                        canvasSection.appendChild(palette);
                    } else {
                        document.body.appendChild(palette);
                    }
                }
            } else {
                // Fixed positions - add back to flex container if needed
                if (palette.parentNode !== mainContainer) {
                    // Remove from current parent (could be body or canvasSection)
                    const currentParent = palette.parentNode;
                    if (currentParent) {
                        currentParent.removeChild(palette);
                    }
                    // Add back to mainContainer
                    mainContainer.insertBefore(palette, mainContainer.firstChild);
                }
                
                palette.style.width = '180px';
                // Make docked palette full height - use flexbox to stretch
                palette.style.height = '100%';
                palette.style.maxHeight = '100%';
                palette.style.display = 'flex';
                palette.style.flexDirection = 'column';
                
                if (position === 'left') {
                    mainContainer.style.flexDirection = 'row';
                } else if (position === 'right') {
                    mainContainer.style.flexDirection = 'row-reverse';
                }
            }
            
            // Update palette content max-height and overflow based on position
            const paletteContent = palette.querySelector('div[style*="overflow-y"]');
            if (paletteContent) {
                // For docked positions (left/right), use full available height
                if (position === 'left' || position === 'right') {
                    // Use flex: 1 to fill remaining space after header
                    paletteContent.style.flex = '1';
                    paletteContent.style.minHeight = '0'; // Allow flex item to shrink
                    paletteContent.style.maxHeight = 'none';
                    paletteContent.style.height = 'auto';
                    paletteContent.style.overflowX = 'hidden';
                    paletteContent.style.overflowY = 'auto';
                    paletteContent.style.whiteSpace = 'normal';
                } else {
                    // Floating mode - use max height constraint
                    paletteContent.style.maxHeight = 'calc(80vh - 50px)';
                    paletteContent.style.height = '';
                    paletteContent.style.overflowX = 'hidden';
                    paletteContent.style.overflowY = 'auto';
                    paletteContent.style.whiteSpace = 'normal';
                }
            }
            
            // Update grid layout for side positions
            const elementPaletteList = document.getElementById('elementPaletteList');
            const propertyPaletteList = document.getElementById('propertyPaletteList');
            
            // Reset to normal 3-column grid for side positions
            if (elementPaletteList) {
                // For facet-grouped layout, update facet grids
                const facetGrids = elementPaletteList.querySelectorAll('div[style*="grid-template-columns"]');
                facetGrids.forEach(grid => {
                    grid.style.gridTemplateColumns = 'repeat(3, 1fr)';
                    grid.style.gridAutoFlow = 'row';
                    grid.style.justifyContent = '';
                });
            }
            if (propertyPaletteList) {
                propertyPaletteList.style.gridTemplateColumns = 'repeat(2, 1fr)';
                propertyPaletteList.style.gridAutoFlow = 'row';
                propertyPaletteList.style.justifyContent = '';
            }
        };
        
        // AskED Chatbot Modal Functions
        function setupAskedChatbotModal() {
            // Enterprise filter removed from EDGly modal
        }
        
        function toggleAskedChatbotModal() {
            const modal = document.getElementById('askedChatbotModal');
            if (!modal) return;
            
            const isVisible = modal.style.display === 'flex';
            modal.style.display = isVisible ? 'none' : 'flex';
            
            // Sync chat messages when opening modal
            if (!isVisible) {
                syncChatMessagesToModal();
            }
        }
        
        function syncChatMessagesToModal() {
            const mainMessages = document.getElementById('chatMessages');
            const modalMessages = document.getElementById('askedModalChatMessages');
            
            if (!mainMessages || !modalMessages) return;
            
            // Copy messages from main chatbot to modal
            modalMessages.innerHTML = mainMessages.innerHTML;
            
            // Scroll to bottom
            setTimeout(() => {
                modalMessages.scrollTop = modalMessages.scrollHeight;
            }, 100);
        }
        
        function handleAskedModalChatKeyPress(event) {
            if (event.key === 'Enter') {
                sendAskedModalChatMessage();
            }
        }
        
        function askQuestionModal(question) {
            const input = document.getElementById('askedModalChatInput');
            if (input) {
                input.value = question;
                sendAskedModalChatMessage();
            }
        }
        
        async function sendAskedModalChatMessage() {
            const input = document.getElementById('askedModalChatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Clear input
            input.value = '';
            input.disabled = true;
            const sendBtn = input.nextElementSibling;
            if (sendBtn) sendBtn.disabled = true;
            
            // Add user message to modal
            addAskedModalChatMessage(message, 'user');
            
            // Also add to main chatbot for sync
            addChatMessage(message, 'user');
            
            // Show typing indicator
            const typingId = addAskedModalTypingIndicator();
            
            try {
                // Enterprise filter removed from EDGly modal - send without filter
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        question: message,
                        enterprise: null
                    })
                });
                
                const data = await response.json();
                
                // Remove typing indicator
                removeAskedModalTypingIndicator(typingId);
                
                // Handle response (similar to main chatbot)
                if (data.open_diagram) {
                    const diagramId = data.open_diagram;
                    const responseMessage = data.open_diagram_message || data.answer || 'Opening the diagram for you...';
                    addAskedModalChatMessage(responseMessage, 'assistant');
                    addChatMessage(responseMessage, 'assistant');
                    setTimeout(() => {
                        viewSavedDiagram(diagramId);
                    }, 100);
                } else {
                    let answerText = data.answer || 'I apologize, but I encountered an error processing your question.';
                    
                    if (!answerText || typeof answerText !== 'string') {
                        answerText = 'I encountered an error processing your question. Please try again.';
                    }
                    
                    // Format and add assistant response to modal (with formatting)
                    addAskedModalChatMessage(answerText, 'assistant');
                    
                    // Also add to main chatbot for sync (without formatting changes)
                    addChatMessage(answerText, 'assistant');
                }
            } catch (error) {
                console.error('Error sending chat message:', error);
                removeAskedModalTypingIndicator(typingId);
                const errorMessage = 'Sorry, I encountered an error. Please try again.';
                addAskedModalChatMessage(errorMessage, 'assistant');
                addChatMessage(errorMessage, 'assistant');
            } finally {
                input.disabled = false;
                if (sendBtn) sendBtn.disabled = false;
            }
        }
        
        function addAskedModalChatMessage(message, sender) {
            const messagesContainer = document.getElementById('askedModalChatMessages');
            if (!messagesContainer) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${sender}`;
            
            if (sender === 'user') {
                messageDiv.innerHTML = `
                    <div class="chat-content">
                        <p>${escapeHtml(message)}</p>
                    </div>
                `;
            } else {
                // Format assistant response
                const formattedMessage = formatChatbotResponse(message);
                
                messageDiv.innerHTML = `
                    <div class="chat-avatar">
                        <img src="/images/ask-ed_OLD.svg" alt="EDGly" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;" onerror="this.style.display='none';">
                    </div>
                    <div class="chat-content">
                        ${formattedMessage}
                    </div>
                `;
            }
            
            messagesContainer.appendChild(messageDiv);
            
            // Process images after insertion to ensure they load properly
            if (sender === 'assistant') {
                setTimeout(() => {
                    const images = messageDiv.querySelectorAll('img');
                    images.forEach(img => {
                        // Force image reload if it failed
                        if (!img.complete || img.naturalHeight === 0) {
                            const originalSrc = img.src;
                            img.onerror = function() {
                                // Try fallback image paths
                                const alt = img.alt || '';
                                if (alt && !img.src.includes('fallback')) {
                                    img.src = `/images/Shape-${alt}.svg`;
                                    img.onerror = function() {
                                        img.style.display = 'none';
                                    };
                                } else {
                                    img.style.display = 'none';
                                }
                            };
                            // Trigger reload
                            img.src = '';
                            img.src = originalSrc;
                        }
                    });
                }, 50);
            }
            
            // Scroll to bottom
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        }
        
        function formatChatbotResponse(text) {
            if (!text || typeof text !== 'string') {
                return `<p>${escapeHtml(String(text))}</p>`;
            }
            
            let formatted = text;
            
            // Remove HTML tables and convert to formatted text
            formatted = formatted.replace(/<table[^>]*>[\s\S]*?<\/table>/gi, (match) => {
                // Extract table content and convert to formatted list
                const rows = match.match(/<tr[^>]*>[\s\S]*?<\/tr>/gi) || [];
                let listItems = '';
                rows.forEach(row => {
                    const cells = row.match(/<t[dh][^>]*>([\s\S]*?)<\/t[dh]>/gi) || [];
                    if (cells.length > 0) {
                        const cellTexts = cells.map(cell => {
                            return cell.replace(/<[^>]+>/g, '').trim();
                        }).filter(text => text.length > 0);
                        if (cellTexts.length > 0) {
                            listItems += `<p><strong>${escapeHtml(cellTexts[0])}</strong>${cellTexts.length > 1 ? ': ' + escapeHtml(cellTexts.slice(1).join(', ')) : ''}</p>`;
                        }
                    }
                });
                return listItems || '';
            });
            
            // Convert markdown-style headings to HTML
            formatted = formatted.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            formatted = formatted.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            formatted = formatted.replace(/^# (.*$)/gim, '<h1>$1</h1>');
            
            // Convert markdown bold/italic
            formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            formatted = formatted.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Detect and replace element/relationship/property image references
            // Pattern: [ELEMENT_IMAGE:element_type], [PROPERTY_IMAGE:rag_type], [RELATIONSHIP_IMAGE:relationship_type]
            formatted = formatted.replace(/\[ELEMENT_IMAGE:([^\]]+)\]/gi, (match, elementType) => {
                const elementImage = findElementImage(elementType.trim());
                if (elementImage) {
                    return `<img src="${escapeHtml(elementImage)}" alt="${escapeHtml(elementType)}" class="element-image" title="${escapeHtml(elementType)}" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 4px;">`;
                }
                return '';
            });
            
            formatted = formatted.replace(/\[PROPERTY_IMAGE:([^\]]+)\]/gi, (match, ragType) => {
                const propertyImage = findPropertyImageByRagType(ragType.trim());
                if (propertyImage) {
                    return `<img src="${escapeHtml(propertyImage)}" alt="${escapeHtml(ragType)}" class="property-image" title="${escapeHtml(ragType)}" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 4px;">`;
                }
                return '';
            });
            
            formatted = formatted.replace(/\[RELATIONSHIP_IMAGE:([^\]]+)\]/gi, (match, relationshipType) => {
                const relationshipImage = findRelationshipImage(relationshipType.trim());
                if (relationshipImage) {
                    return `<img src="${escapeHtml(relationshipImage)}" alt="${escapeHtml(relationshipType)}" class="relationship-image" title="${escapeHtml(relationshipType)}" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 4px;">`;
                }
                return '';
            });
            
            // Wrap citations and notes
            formatted = formatted.replace(/\[Citation:([^\]]+)\]/gi, '<div class="citation">Citation: $1</div>');
            formatted = formatted.replace(/\[Note:([^\]]+)\]/gi, '<div class="note">Note: $1</div>');
            formatted = formatted.replace(/\[Footnote:([^\]]+)\]/gi, '<div class="footnote">Footnote: $1</div>');
            
            // Convert line breaks to paragraphs
            const paragraphs = formatted.split(/\n\n+/).filter(p => p.trim().length > 0);
            if (paragraphs.length > 1) {
                formatted = paragraphs.map(p => {
                    p = p.trim();
                    // Don't wrap if it's already an HTML tag
                    if (p.startsWith('<')) {
                        return p;
                    }
                    return `<p>${p}</p>`;
                }).join('');
            } else {
                // Single paragraph
                if (!formatted.trim().startsWith('<')) {
                    formatted = `<p>${formatted.trim()}</p>`;
                }
            }
            
            return formatted;
        }
        
        function findElementImage(elementName) {
            // Use standard element images from /images folder based on element type
            // Map element types to their standard images (not instance-specific)
            const elementImageMap = {
                'People': '/images/light-people-element.svg',
                'Activity': '/images/activity-element.svg',
                'Outcome': '/images/outcome-element.svg',
                'Object': '/images/object-element.svg',
                'Capability': '/images/capability-element.svg',
                'Asset': '/images/asset-element.svg',
                'Process': '/images/process-element.svg',
                'Purpose': '/images/purpose-element.svg',
                'Content': '/images/content-element.svg',
                'Story': '/images/story-element.svg',
                'Journey': '/images/journey-element.svg',
                'Product': '/images/product-element.svg',
                'Organisation': '/images/organisation-element.svg',
                'Organization': '/images/organisation-element.svg',
                'Brand': '/images/brand-element.svg',
                'Channel': '/images/channel-element.svg',
                'Task': '/images/task-element.svg'
            };
            
            // Try exact match first
            if (elementImageMap[elementName]) {
                return elementImageMap[elementName];
            }
            
            // Try case-insensitive match
            const elementNameLower = elementName.toLowerCase();
            for (const [key, value] of Object.entries(elementImageMap)) {
                if (key.toLowerCase() === elementNameLower) {
                    return value;
                }
            }
            
            return null;
        }
        
        function findRelationshipImage(relationshipName) {
            // Common relationship images
            const relationshipImages = {
                'creates': '/images/create-relationships.png',
                'performs': '/images/create-relationships.png',
                'realises': '/images/create-relationships.png',
                'requires': '/images/create-relationships.png',
                'flow': '/images/create-relationships.png'
            };
            
            return relationshipImages[relationshipName.toLowerCase()] || '/images/create-relationships.png';
        }
        
        function findPropertyImage(propertyName) {
            // Try to find property by name from available properties
            // This would need to be loaded from the API
            // For now, return a default property tag image
            return '/images/Tag-Green.svg';
        }
        
        function findPropertyImageByRagType(ragType) {
            // Map RAG types to standard property images in /images folder
            const ragTypeLower = ragType.toLowerCase();
            const ragImageMap = {
                'red': '/images/Tag-Red.svg',
                'negative': '/images/Tag-Red.svg',
                'yellow': '/images/Tag-Yellow.svg',
                'amber': '/images/Tag-Yellow.svg',
                'warning': '/images/Tag-Yellow.svg',
                'green': '/images/Tag-Green.svg',
                'positive': '/images/Tag-Green.svg',
                'black': '/images/Tag-Black.svg'
            };
            
            // Try exact match
            if (ragImageMap[ragTypeLower]) {
                return ragImageMap[ragTypeLower];
            }
            
            // Try partial match
            for (const [key, value] of Object.entries(ragImageMap)) {
                if (ragTypeLower.includes(key) || key.includes(ragTypeLower)) {
                    return value;
                }
            }
            
            // Default to green
            return '/images/Tag-Green.svg';
        }
        
        function addAskedModalTypingIndicator() {
            const messagesContainer = document.getElementById('askedModalChatMessages');
            if (!messagesContainer) return null;
            
            const typingId = 'typing-' + Date.now();
            const typingDiv = document.createElement('div');
            typingDiv.id = typingId;
            typingDiv.className = 'chat-message assistant';
            typingDiv.innerHTML = `
                <div class="chat-avatar">
                    <img src="/images/ask-ed_OLD.svg" alt="EDGly" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;" onerror="this.style.display='none';">
                </div>
                <div class="chat-content">
                    <div class="typing-indicator">
                        <span></span><span></span><span></span>
                    </div>
                </div>
            `;
            
            messagesContainer.appendChild(typingDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            return typingId;
        }
        
        function removeAskedModalTypingIndicator(typingId) {
            if (!typingId) return;
            const typingElement = document.getElementById(typingId);
            if (typingElement) {
                typingElement.remove();
            }
        }
        
        // Layer Management Functions
        function setupLayerManagement() {
            // Initialize checkboxes from state
            const elementsToggle = document.getElementById('layerElementsToggle');
            const propertiesToggle = document.getElementById('layerPropertiesToggle');
            const connectionsToggle = document.getElementById('layerConnectionsToggle');
            const gridToggle = document.getElementById('layerGridToggle');
            
            if (elementsToggle) {
                elementsToggle.checked = canvasState.layerVisibility.elements;
                elementsToggle.addEventListener('change', (e) => {
                    canvasState.layerVisibility.elements = e.target.checked;
                    localStorage.setItem('canvasLayerElements', e.target.checked);
                    toggleLayerVisibility('elements', e.target.checked);
                });
            }
            
            if (propertiesToggle) {
                propertiesToggle.checked = canvasState.layerVisibility.properties;
                propertiesToggle.addEventListener('change', (e) => {
                    canvasState.layerVisibility.properties = e.target.checked;
                    localStorage.setItem('canvasLayerProperties', e.target.checked);
                    toggleLayerVisibility('properties', e.target.checked);
                });
            }
            
            if (connectionsToggle) {
                connectionsToggle.checked = canvasState.layerVisibility.connections;
                connectionsToggle.addEventListener('change', (e) => {
                    canvasState.layerVisibility.connections = e.target.checked;
                    localStorage.setItem('canvasLayerConnections', e.target.checked);
                    toggleLayerVisibility('connections', e.target.checked);
                });
            }
            
            if (gridToggle) {
                gridToggle.checked = canvasState.layerVisibility.grid;
                gridToggle.addEventListener('change', (e) => {
                    canvasState.layerVisibility.grid = e.target.checked;
                    localStorage.setItem('canvasLayerGrid', e.target.checked);
                    toggleLayerVisibility('grid', e.target.checked);
                });
            }
            
            const minimapToggle = document.getElementById('layerMinimapToggle');
            if (minimapToggle) {
                minimapToggle.checked = canvasState.layerVisibility.minimap;
                minimapToggle.addEventListener('change', (e) => {
                    canvasState.layerVisibility.minimap = e.target.checked;
                    localStorage.setItem('canvasLayerMinimap', e.target.checked);
                    toggleLayerVisibility('minimap', e.target.checked);
                });
            }
            
            // Setup snap to grid toggle
            const snapToGridToggle = document.getElementById('layerSnapToGridToggle');
            if (snapToGridToggle) {
                snapToGridToggle.checked = canvasState.snapToGridEnabled;
                snapToGridToggle.addEventListener('change', (e) => {
                    canvasState.snapToGridEnabled = e.target.checked;
                    localStorage.setItem('canvasSnapToGrid', e.target.checked);
                });
            }
            
            // Setup element shadows toggle
            const elementShadowsToggle = document.getElementById('layerElementShadowsToggle');
            if (elementShadowsToggle) {
                elementShadowsToggle.checked = canvasState.elementShadowsEnabled;
                elementShadowsToggle.addEventListener('change', (e) => {
                    canvasState.elementShadowsEnabled = e.target.checked;
                    localStorage.setItem('canvasElementShadows', e.target.checked);
                    toggleElementShadows(e.target.checked);
                });
            }
            
            // Apply initial visibility states
            toggleLayerVisibility('elements', canvasState.layerVisibility.elements);
            toggleLayerVisibility('properties', canvasState.layerVisibility.properties);
            toggleLayerVisibility('connections', canvasState.layerVisibility.connections);
            toggleLayerVisibility('grid', canvasState.layerVisibility.grid);
            toggleLayerVisibility('minimap', canvasState.layerVisibility.minimap);
            
            // Apply initial shadow state
            toggleElementShadows(canvasState.elementShadowsEnabled);
        }
        
        function toggleElementShadows(enabled) {
            canvasState.elements.forEach(element => {
                const borderDiv = document.getElementById(`element-border-${element.id}`);
                if (borderDiv) {
                    if (enabled) {
                        borderDiv.style.filter = 'drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3))';
                    } else {
                        borderDiv.style.filter = 'none';
                    }
                }
            });
        }
        
        function toggleLayerManagement() {
            const panel = document.getElementById('layerManagementPanel');
            if (!panel) return;
            
            const isVisible = panel.style.display === 'block';
            panel.style.display = isVisible ? 'none' : 'block';
        }
        
        function toggleLayerVisibility(layer, visible) {
            if (layer === 'elements') {
                const elementsLayer = document.getElementById('elementsLayer');
                if (elementsLayer) {
                    elementsLayer.style.display = visible ? 'block' : 'none';
                }
            } else if (layer === 'properties') {
                const propertiesLayer = document.getElementById('propertyInstancesLayer');
                if (propertiesLayer) {
                    propertiesLayer.style.display = visible ? 'block' : 'none';
                }
            } else if (layer === 'connections') {
                const connectionsLayer = document.getElementById('connectionsLayer');
                if (connectionsLayer) {
                    connectionsLayer.style.display = visible ? 'block' : 'none';
                }
            } else if (layer === 'grid') {
                const container = document.getElementById('canvasContainer');
                if (container) {
                    if (visible && canvasState.showGridlines) {
                        container.style.backgroundImage = `
                            linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                            linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px)
                        `;
                    } else {
                        container.style.backgroundImage = 'none';
                    }
                }
            } else if (layer === 'minimap') {
                const minimap = document.getElementById('canvasMinimap');
                if (minimap) {
                    // Only show minimap if there are elements and visibility is enabled
                    if (visible && canvasState.elements.length > 0) {
                        minimap.style.display = 'block';
                        updateMinimap(); // Update minimap when showing
                    } else {
                        minimap.style.display = 'none';
                    }
                }
            }
        }
        
        // Snap Guides Functions
        function setupSnapGuides() {
            const snapGuidesToggle = document.getElementById('snapGuidesToggle');
            if (snapGuidesToggle) {
                snapGuidesToggle.checked = canvasState.snapGuidesEnabled;
                snapGuidesToggle.addEventListener('change', (e) => {
                    canvasState.snapGuidesEnabled = e.target.checked;
                    localStorage.setItem('canvasSnapGuides', e.target.checked);
                    if (!e.target.checked) {
                        clearSnapGuides();
                    }
                });
            }
        }
        
        function clearSnapGuides() {
            const guidesLayer = document.getElementById('snapGuidesLayer');
            if (guidesLayer) {
                guidesLayer.innerHTML = '';
                guidesLayer.style.display = 'none';
            }
        }
        
        function drawSnapGuides(snapLines) {
            if (!canvasState.snapGuidesEnabled) return;
            
            const guidesLayer = document.getElementById('snapGuidesLayer');
            if (!guidesLayer) return;
            
            guidesLayer.innerHTML = '';
            
            if (snapLines.length === 0) {
                guidesLayer.style.display = 'none';
                return;
            }
            
            guidesLayer.style.display = 'block';
            
            snapLines.forEach(line => {
                const guideLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                guideLine.setAttribute('x1', line.x1);
                guideLine.setAttribute('y1', line.y1);
                guideLine.setAttribute('x2', line.x2);
                guideLine.setAttribute('y2', line.y2);
                guideLine.setAttribute('stroke', '#667eea');
                guideLine.setAttribute('stroke-width', '1');
                guideLine.setAttribute('stroke-dasharray', '5,5');
                guideLine.setAttribute('opacity', '0.8');
                guidesLayer.appendChild(guideLine);
            });
        }
        
        function findSnapLines(draggingElement, allElements) {
            if (!canvasState.snapGuidesEnabled) return [];
            
            const snapLines = [];
            const threshold = canvasState.snapThreshold;
            
            const draggingLeft = draggingElement.x_position;
            const draggingRight = draggingElement.x_position + draggingElement.width;
            const draggingTop = draggingElement.y_position;
            const draggingBottom = draggingElement.y_position + draggingElement.height;
            const draggingCenterX = draggingElement.x_position + draggingElement.width / 2;
            const draggingCenterY = draggingElement.y_position + draggingElement.height / 2;
            
            allElements.forEach(element => {
                if (element.id === draggingElement.id) return;
                
                const elementLeft = element.x_position;
                const elementRight = element.x_position + element.width;
                const elementTop = element.y_position;
                const elementBottom = element.y_position + element.height;
                const elementCenterX = element.x_position + element.width / 2;
                const elementCenterY = element.y_position + element.height / 2;
                
                // Check vertical alignment (left, center, right edges)
                if (Math.abs(draggingLeft - elementLeft) < threshold) {
                    snapLines.push({
                        x1: draggingLeft,
                        y1: Math.min(draggingTop, elementTop) - 20,
                        x2: draggingLeft,
                        y2: Math.max(draggingBottom, elementBottom) + 20
                    });
                }
                if (Math.abs(draggingRight - elementRight) < threshold) {
                    snapLines.push({
                        x1: draggingRight,
                        y1: Math.min(draggingTop, elementTop) - 20,
                        x2: draggingRight,
                        y2: Math.max(draggingBottom, elementBottom) + 20
                    });
                }
                if (Math.abs(draggingCenterX - elementCenterX) < threshold) {
                    snapLines.push({
                        x1: draggingCenterX,
                        y1: Math.min(draggingTop, elementTop) - 20,
                        x2: draggingCenterX,
                        y2: Math.max(draggingBottom, elementBottom) + 20
                    });
                }
                
                // Check horizontal alignment (top, center, bottom edges)
                if (Math.abs(draggingTop - elementTop) < threshold) {
                    snapLines.push({
                        x1: Math.min(draggingLeft, elementLeft) - 20,
                        y1: draggingTop,
                        x2: Math.max(draggingRight, elementRight) + 20,
                        y2: draggingTop
                    });
                }
                if (Math.abs(draggingBottom - elementBottom) < threshold) {
                    snapLines.push({
                        x1: Math.min(draggingLeft, elementLeft) - 20,
                        y1: draggingBottom,
                        x2: Math.max(draggingRight, elementRight) + 20,
                        y2: draggingBottom
                    });
                }
                if (Math.abs(draggingCenterY - elementCenterY) < threshold) {
                    snapLines.push({
                        x1: Math.min(draggingLeft, elementLeft) - 20,
                        y1: draggingCenterY,
                        x2: Math.max(draggingRight, elementRight) + 20,
                        y2: draggingCenterY
                    });
                }
            });
            
            return snapLines;
        }
        
        function snapToElements(draggingElement, allElements) {
            if (!canvasState.snapGuidesEnabled) return draggingElement;
            
            const threshold = canvasState.snapThreshold;
            const snappedElement = { ...draggingElement };
            
            const draggingLeft = draggingElement.x_position;
            const draggingRight = draggingElement.x_position + draggingElement.width;
            const draggingTop = draggingElement.y_position;
            const draggingBottom = draggingElement.y_position + draggingElement.height;
            const draggingCenterX = draggingElement.x_position + draggingElement.width / 2;
            const draggingCenterY = draggingElement.y_position + draggingElement.height / 2;
            
            allElements.forEach(element => {
                if (element.id === draggingElement.id) return;
                
                const elementLeft = element.x_position;
                const elementRight = element.x_position + element.width;
                const elementTop = element.y_position;
                const elementBottom = element.y_position + element.height;
                const elementCenterX = element.x_position + element.width / 2;
                const elementCenterY = element.y_position + element.height / 2;
                
                // Snap left edges
                if (Math.abs(draggingLeft - elementLeft) < threshold) {
                    snappedElement.x_position = elementLeft;
                }
                // Snap right edges
                if (Math.abs(draggingRight - elementRight) < threshold) {
                    snappedElement.x_position = elementRight - draggingElement.width;
                }
                // Snap center X
                if (Math.abs(draggingCenterX - elementCenterX) < threshold) {
                    snappedElement.x_position = elementCenterX - draggingElement.width / 2;
                }
                
                // Snap top edges
                if (Math.abs(draggingTop - elementTop) < threshold) {
                    snappedElement.y_position = elementTop;
                }
                // Snap bottom edges
                if (Math.abs(draggingBottom - elementBottom) < threshold) {
                    snappedElement.y_position = elementBottom - draggingElement.height;
                }
                // Snap center Y
                if (Math.abs(draggingCenterY - elementCenterY) < threshold) {
                    snappedElement.y_position = elementCenterY - draggingElement.height / 2;
                }
            });
            
            return snappedElement;
        }
        
        // Element Search Functionality
        function setupElementSearch() {
            const searchInput = document.getElementById('elementSearchInput');
            if (!searchInput) return;
            let searchTimeout = null;
            
            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.trim();
                if (searchTimeout) {
                    clearTimeout(searchTimeout);
                }
                searchTimeout = setTimeout(() => {
                    searchElementOccurrences(searchTerm);
                }, 200);
            });
            
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    searchInput.value = '';
                    clearPaletteSearchResults();
                }
            });
        }
        
        async function searchElementOccurrences(searchTerm) {
            const resultsContainer = document.getElementById('paletteSearchResults');
            const listContainer = document.getElementById('paletteSearchList');
            const emptyState = document.getElementById('paletteSearchEmpty');
            if (!resultsContainer || !listContainer || !emptyState) return;
            
            if (!searchTerm) {
                clearPaletteSearchResults();
                return;
            }
            
            resultsContainer.style.display = 'block';
            listContainer.innerHTML = '<div class="palette-menu-empty" style="display: block;">Searching...</div>';
            emptyState.style.display = 'none';
            
            try {
                const response = await fetch(`/api/canvas/element-instances/search?q=${encodeURIComponent(searchTerm)}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const instances = await response.json();
                renderPaletteSearchResults(instances);
            } catch (error) {
                console.error('Error searching occurrences:', error);
                listContainer.innerHTML = '<div class="palette-menu-empty" style="display: block; color: #ff6b6b;">Search failed</div>';
                emptyState.style.display = 'none';
            }
        }
        
        function renderPaletteSearchResults(instances) {
            const resultsContainer = document.getElementById('paletteSearchResults');
            const listContainer = document.getElementById('paletteSearchList');
            const emptyState = document.getElementById('paletteSearchEmpty');
            if (!resultsContainer || !listContainer || !emptyState) return;
            
            const occurrenceMap = {};
            instances.forEach(instance => {
                const nameKey = instance.instance_name || `Instance ${instance.id}`;
                const key = `${instance.element_type_id || 'type'}::${nameKey}`;
                if (!occurrenceMap[key]) {
                    occurrenceMap[key] = {
                        instance,
                        count: 0,
                        typeLabel: instance.element_type || ''
                    };
                }
                occurrenceMap[key].count += 1;
            });
            const occurrences = Object.values(occurrenceMap);
            
            listContainer.innerHTML = '';
            
            if (occurrences.length === 0) {
                emptyState.style.display = 'block';
                resultsContainer.style.display = 'block';
                return;
            }
            
            emptyState.style.display = 'none';
            resultsContainer.style.display = 'block';
            
            occurrences.forEach(group => {
                group.showType = true;
                const item = createPaletteInstanceMenuItem(group, group.instance.element_type_id);
                listContainer.appendChild(item);
            });
        }
        
        function clearPaletteSearchResults() {
            const resultsContainer = document.getElementById('paletteSearchResults');
            const listContainer = document.getElementById('paletteSearchList');
            const emptyState = document.getElementById('paletteSearchEmpty');
            if (!resultsContainer || !listContainer || !emptyState) return;
            
            listContainer.innerHTML = '';
            emptyState.style.display = 'none';
            resultsContainer.style.display = 'none';
        }
        
        // Keyboard Shortcuts
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Don't trigger shortcuts when typing in inputs
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    if (e.key === '?' || e.key === 'Escape') {
                        // Allow ? and Escape even in inputs
                    } else {
                        return;
                    }
                }
                
                const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                const ctrlKey = isMac ? e.metaKey : e.ctrlKey;
                
                // Show shortcuts panel
                if (e.key === '?' && !ctrlKey && !e.shiftKey) {
                    e.preventDefault();
                    toggleKeyboardShortcuts();
                    return;
                }
                
                // Only process shortcuts when canvas is active
                const canvasSection = document.getElementById('modelingCanvas');
                if (!canvasSection || !canvasSection.classList.contains('active')) {
                    return;
                }
                
                // Canvas shortcuts
                if (e.key === 'g' || e.key === 'G') {
                    e.preventDefault();
                    toggleGridlines();
                } else if (e.key === 't' || e.key === 'T') {
                    e.preventDefault();
                    toggleCanvasTheme();
                } else if (e.key === 'F11') {
                    e.preventDefault();
                    toggleFullscreen();
                } else if (ctrlKey && (e.key === '+' || e.key === '=')) {
                    e.preventDefault();
                    zoomCanvas('in');
                } else if (ctrlKey && e.key === '-') {
                    e.preventDefault();
                    zoomCanvas('out');
                } else if (ctrlKey && e.key === '0') {
                    e.preventDefault();
                    canvasState.zoom = 1;
                    updateCanvasTransform();
                    updateZoomDisplay();
                } else if (ctrlKey && e.key === 's') {
                    e.preventDefault();
                    saveCanvasModel();
                } else if (ctrlKey && e.key === 'o') {
                    e.preventDefault();
                    loadCanvasModels();
                } else if (ctrlKey && e.shiftKey && e.key === 'C') {
                    e.preventDefault();
                    if (confirm('Clear the entire canvas? This cannot be undone.')) {
                        clearCanvas();
                    }
                } else if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (canvasState.selectedElementIds.length > 0) {
                        e.preventDefault();
                        deleteSelectedElements();
                    }
                }
            });
        }
        
        function toggleKeyboardShortcuts() {
            const modal = document.getElementById('keyboardShortcutsModal');
            if (!modal) return;
            
            const isVisible = modal.style.display === 'flex';
            modal.style.display = isVisible ? 'none' : 'flex';
        }
        
        // Minimap Functionality
        let minimapInitialized = false;
        function setupMinimap() {
            const minimap = document.getElementById('canvasMinimap');
            if (!minimap || minimapInitialized) return;
            
            minimapInitialized = true;
            
            // Click on minimap to pan canvas
            minimap.addEventListener('click', (e) => {
                const svg = document.getElementById('minimapSvg');
                if (!svg || e.target === svg) return;
                
                const rect = svg.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = (e.clientY - rect.top) / rect.height;
                
                // Calculate canvas bounds
                const container = document.getElementById('canvasContainer');
                if (!container) return;
                
                const canvasWidth = Math.max(2000, container.scrollWidth);
                const canvasHeight = Math.max(2000, container.scrollHeight);
                
                // Pan to clicked position
                canvasState.panX = -x * canvasWidth + container.clientWidth / 2;
                canvasState.panY = -y * canvasHeight + container.clientHeight / 2;
                updateCanvasTransform();
            });
            
            // Update minimap on scroll
            const container = document.getElementById('canvasContainer');
            if (container) {
                container.addEventListener('scroll', updateMinimap);
            }
        }
        
        function updateMinimap() {
            const minimap = document.getElementById('canvasMinimap');
            const minimapSvg = document.getElementById('minimapSvg');
            const viewport = document.getElementById('minimapViewport');
            if (!minimap || !minimapSvg || !viewport) return;
            
            const elements = canvasState.elements;
            const container = document.getElementById('canvasContainer');
            if (!container) return;
            
            // Check if minimap layer is enabled
            const isMinimapEnabled = canvasState.layerVisibility && canvasState.layerVisibility.minimap !== false;
            
            // Show minimap only if there are elements AND minimap layer is enabled
            if (elements.length === 0 || !isMinimapEnabled) {
                minimap.style.display = 'none';
                return;
            }
            
            minimap.style.display = 'block';
            
            // Calculate canvas bounds
            const minX = Math.min(...elements.map(e => e.x_position), 0);
            const maxX = Math.max(...elements.map(e => e.x_position + e.width), 2000);
            const minY = Math.min(...elements.map(e => e.y_position), 0);
            const maxY = Math.max(...elements.map(e => e.y_position + e.height), 2000);
            
            const canvasWidth = maxX - minX || 2000;
            const canvasHeight = maxY - minY || 2000;
            
            const scaleX = minimapSvg.clientWidth / canvasWidth;
            const scaleY = minimapSvg.clientHeight / canvasHeight;
            const scale = Math.min(scaleX, scaleY);
            
            // Clear and redraw minimap
            minimapSvg.innerHTML = '';
            
            // Draw elements
            elements.forEach(element => {
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const x = (element.x_position - minX) * scale;
                const y = (element.y_position - minY) * scale;
                const width = element.width * scale;
                const height = element.height * scale;
                
                rect.setAttribute('x', x);
                rect.setAttribute('y', y);
                rect.setAttribute('width', width);
                rect.setAttribute('height', height);
                rect.setAttribute('fill', '#667eea');
                rect.setAttribute('opacity', '0.6');
                rect.setAttribute('stroke', '#ffffff');
                rect.setAttribute('stroke-width', '0.5');
                minimapSvg.appendChild(rect);
            });
            
            // Draw relationships
            canvasState.relationships.forEach(rel => {
                const source = elements.find(e => e.id === rel.source_instance_id);
                const target = elements.find(e => e.id === rel.target_instance_id);
                if (!source || !target) return;
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                const x1 = (source.x_position + source.width / 2 - minX) * scale;
                const y1 = (source.y_position + source.height / 2 - minY) * scale;
                const x2 = (target.x_position + target.width / 2 - minX) * scale;
                const y2 = (target.y_position + target.height / 2 - minY) * scale;
                
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', '#888');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('opacity', '0.4');
                minimapSvg.appendChild(line);
            });
            
            // Update viewport indicator
            const scrollLeft = container.scrollLeft;
            const scrollTop = container.scrollTop;
            const viewportWidth = container.clientWidth;
            const viewportHeight = container.clientHeight;
            
            viewport.style.left = `${(scrollLeft - minX) * scale}px`;
            viewport.style.top = `${(scrollTop - minY) * scale}px`;
            viewport.style.width = `${viewportWidth * scale}px`;
            viewport.style.height = `${viewportHeight * scale}px`;
        }
        
        // Setup context menu event listeners to avoid CSP eval errors
        function setupContextMenuEventListeners() {
            // Element context menu buttons
            const createRelationshipBtn = document.getElementById('createRelationshipMenuItem');
            if (createRelationshipBtn) {
                createRelationshipBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    selectElementFromContextMenu();
                });
                createRelationshipBtn.addEventListener('mouseenter', () => {
                    createRelationshipBtn.style.background = '#3e3e42';
                });
                createRelationshipBtn.addEventListener('mouseleave', () => {
                    createRelationshipBtn.style.background = 'transparent';
                });
            }
            
            // Delete element button
            const deleteElementBtn = document.querySelector('#elementContextMenu button[data-action="deleteElementInstance"]');
            if (deleteElementBtn) {
                deleteElementBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    deleteElementInstance();
                });
                deleteElementBtn.addEventListener('mouseenter', () => {
                    deleteElementBtn.style.background = '#3e3e42';
                });
                deleteElementBtn.addEventListener('mouseleave', () => {
                    deleteElementBtn.style.background = 'transparent';
                });
            }
            
            // Relationship context menu delete button
            const deleteRelationshipBtn = document.querySelector('#relationshipContextMenu button[data-action="deleteRelationship"]');
            if (deleteRelationshipBtn) {
                deleteRelationshipBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    deleteRelationship();
                });
                deleteRelationshipBtn.addEventListener('mouseenter', () => {
                    deleteRelationshipBtn.style.background = '#353550';
                });
                deleteRelationshipBtn.addEventListener('mouseleave', () => {
                    deleteRelationshipBtn.style.background = 'transparent';
                });
            }
        }
        
        // Toggle canvas theme between dark and light
        function toggleCanvasTheme() {
            canvasState.theme = canvasState.theme === 'dark' ? 'light' : 'dark';
            localStorage.setItem('canvasTheme', canvasState.theme);
            // Reapply template if active to update colors, otherwise apply theme
            if (canvasState.canvasTemplate && canvasState.canvasTemplate !== 'none') {
                applyCanvasTemplate(canvasState.canvasTemplate);
            } else {
                applyCanvasTheme();
            }
            // Update chatbot button SVG
            updateChatbotButtonSVG();
        }
        
        // Toggle gridlines visibility
        function toggleGridlines() {
            canvasState.showGridlines = !canvasState.showGridlines;
            localStorage.setItem('canvasShowGridlines', canvasState.showGridlines);
            // Reapply template if active, otherwise apply theme
            if (canvasState.canvasTemplate && canvasState.canvasTemplate !== 'none') {
                applyCanvasTemplate(canvasState.canvasTemplate);
            } else {
                applyCanvasTheme();
            }
            
            // Update icon
            const gridlinesIcon = document.getElementById('gridlinesToggleIcon');
            if (gridlinesIcon) {
                gridlinesIcon.textContent = canvasState.showGridlines ? '' : '';
            }
            
            // Update grid layer visibility if grid layer is visible
            if (canvasState.layerVisibility && canvasState.layerVisibility.grid) {
                toggleLayerVisibility('grid', canvasState.showGridlines && canvasState.layerVisibility.grid);
            }
        }
        
        // Show toast notification (doesn't exit fullscreen)
        function showCanvasToast(message, type = 'info') {
            let container = document.getElementById('canvasToastContainer');
            
            // If container doesn't exist or we're in fullscreen, ensure it's accessible
            if (!container) {
                // Try to find or create container in fullscreen context
                const canvasSection = document.getElementById('modelingCanvas');
                if (canvasSection) {
                    // Check if container exists but might be hidden
                    container = canvasSection.querySelector('#canvasToastContainer');
                    if (!container) {
                        // Create container if it doesn't exist
                        container = document.createElement('div');
                        container.id = 'canvasToastContainer';
                        container.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 100000; display: flex; flex-direction: column; gap: 10px; pointer-events: none;';
                        document.body.appendChild(container);
                    }
                }
            }
            
            if (!container) {
                console.error('Toast container not found!');
                // Fallback to alert if container doesn't exist
                alert(message);
                return;
            }
            
            // Ensure container is visible
            container.style.display = 'flex';
            container.style.pointerEvents = 'none';
            
            const toast = document.createElement('div');
            const bgColor = type === 'success' ? '#4caf50' : type === 'error' ? '#f44336' : '#2196f3';
            toast.style.cssText = `
                background: ${bgColor};
                color: #ffffff;
                padding: 12px 20px;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                font-size: 14px;
                font-weight: 500;
                min-width: 250px;
                max-width: 400px;
                pointer-events: auto;
                animation: slideInRight 0.3s ease-out;
                cursor: pointer;
            `;
            toast.textContent = message;
            
            // Add animation keyframes if not already added
            if (!document.getElementById('toastAnimations')) {
                const style = document.createElement('style');
                style.id = 'toastAnimations';
                style.textContent = `
                    @keyframes slideInRight {
                        from {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(0);
                            opacity: 1;
                        }
                    }
                    @keyframes slideOutRight {
                        from {
                            transform: translateX(0);
                            opacity: 1;
                        }
                        to {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Auto-remove after 4 seconds
            const autoRemove = setTimeout(() => {
                toast.style.animation = 'slideOutRight 0.3s ease-out';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 4000);
            
            // Click to dismiss
            toast.addEventListener('click', () => {
                clearTimeout(autoRemove);
                toast.style.animation = 'slideOutRight 0.3s ease-out';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            });
            
            container.appendChild(toast);
        }
        
        // Custom confirm dialog (doesn't exit fullscreen)
        function showCanvasConfirm(message) {
            return new Promise((resolve) => {
                let dialog = document.getElementById('canvasConfirmDialog');
                let messageEl = document.getElementById('canvasConfirmMessage');
                let okBtn = document.getElementById('canvasConfirmOk');
                let cancelBtn = document.getElementById('canvasConfirmCancel');
                
                // If dialog doesn't exist, try to find it or create it
                if (!dialog) {
                    const canvasSection = document.getElementById('modelingCanvas');
                    if (canvasSection) {
                        dialog = canvasSection.querySelector('#canvasConfirmDialog');
                    }
                    // If still not found, create it
                    if (!dialog) {
                        const dialogHTML = `
                            <div id="canvasConfirmDialog" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 100001; align-items: center; justify-content: center;">
                                <div style="background: #2d2d44; padding: 30px; border-radius: 8px; min-width: 400px; max-width: 500px; border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
                                    <h3 style="color: #ffffff; margin-bottom: 20px; font-size: 18px;">Confirm</h3>
                                    <p id="canvasConfirmMessage" style="color: #e0e0e0; margin-bottom: 25px; font-size: 14px; line-height: 1.5;"></p>
                                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                                        <button id="canvasConfirmCancel" class="refresh-btn" style="padding: 8px 16px;">Cancel</button>
                                        <button id="canvasConfirmOk" class="refresh-btn" style="padding: 8px 16px; background: #667eea;">OK</button>
                                    </div>
                                </div>
                            </div>
                        `;
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = dialogHTML;
                        dialog = tempDiv.firstElementChild;
                        document.body.appendChild(dialog);
                        messageEl = document.getElementById('canvasConfirmMessage');
                        okBtn = document.getElementById('canvasConfirmOk');
                        cancelBtn = document.getElementById('canvasConfirmCancel');
                    }
                }
                
                if (!dialog || !messageEl || !okBtn || !cancelBtn) {
                    // Fallback to browser confirm if elements don't exist
                    resolve(confirm(message));
                    return;
                }
                
                messageEl.textContent = message;
                dialog.style.display = 'flex';
                
                const cleanup = () => {
                    dialog.style.display = 'none';
                    okBtn.onclick = null;
                    cancelBtn.onclick = null;
                };
                
                okBtn.onclick = () => {
                    cleanup();
                    resolve(true);
                };
                
                cancelBtn.onclick = () => {
                    cleanup();
                    resolve(false);
                };
            });
        }
        
        // Update chatbot button SVG based on canvas theme
        function updateChatbotButtonSVG() {
            const chatbotButton = document.getElementById('askedChatbotButton');
            if (!chatbotButton) return;
            
            const img = chatbotButton.querySelector('img');
            if (!img) return;
            
            // Use dark SVG when canvas is in dark mode, light SVG otherwise
            if (canvasState.theme === 'dark') {
                img.src = '/images/ask-ed_OLD.svg';
            } else {
                img.src = '/images/ask-ed_OLD.svg';
            }
        }
        
        // Apply canvas theme
        function applyCanvasTheme() {
            const container = document.getElementById('canvasContainer');
            const themeIcon = document.getElementById('themeToggleIcon');
            
            // Check if a template is active
            if (canvasState.canvasTemplate && canvasState.canvasTemplate !== 'none') {
                // Template is active, reapply it
                applyCanvasTemplate(canvasState.canvasTemplate);
                if (themeIcon) themeIcon.textContent = canvasState.theme === 'light' ? 'Light' : 'Dark';
                // Update chatbot button SVG
                updateChatbotButtonSVG();
                updateEdglyBubbleTheme();
                return;
            }
            
            if (canvasState.theme === 'light') {
                // Light mode: light background with dark grid
                container.style.background = '#f5f5f5';
                if (canvasState.showGridlines) {
                container.style.backgroundImage = `
                    linear-gradient(rgba(0,0,0,0.1) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(0,0,0,0.1) 1px, transparent 1px)
                `;
                container.style.backgroundSize = '20px 20px';
                container.style.backgroundPosition = '0 0';
                container.style.backgroundRepeat = 'repeat';
                } else {
                    container.style.backgroundImage = 'none';
                    container.style.backgroundSize = '';
                    container.style.backgroundPosition = '';
                    container.style.backgroundRepeat = '';
                }
                if (themeIcon) themeIcon.textContent = 'Light';
            } else {
                // Dark mode: dark background with light grid
                container.style.background = '#1a1a1a';
                if (canvasState.showGridlines) {
                container.style.backgroundImage = `
                    linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px)
                `;
                container.style.backgroundSize = '20px 20px';
                container.style.backgroundPosition = '0 0';
                container.style.backgroundRepeat = 'repeat';
                } else {
                    container.style.backgroundImage = 'none';
                    container.style.backgroundSize = '';
                    container.style.backgroundPosition = '';
                    container.style.backgroundRepeat = '';
                }
                if (themeIcon) themeIcon.textContent = 'Dark';
            }
            updateEdglyBubbleTheme();
            
            // Update chatbot button SVG based on theme
            updateChatbotButtonSVG();
            
            // Update People element label colors and images
            canvasState.elements.forEach(element => {
                const isPeople = element.element_type && element.element_type.toLowerCase() === 'people';
                if (isPeople) {
                    const label = document.getElementById(`element-label-${element.id}`);
                    if (label) {
                        label.style.color = getPeopleLabelColor();
                    }
                    // Update People element image based on theme
                    const elementDiv = document.getElementById(`element-${element.id}`);
                    if (elementDiv) {
                        const img = elementDiv.querySelector('img');
                        if (img) {
                            const peopleImage = canvasState.theme === 'dark' 
                                ? '/images/dark-people-element.svg' 
                                : '/images/light-people-element.svg';
                            img.src = peopleImage;
                        }
                    }
                }
            });
            
            // Re-render relationships to update connection text label box colors
            debouncedUpdateConnections();
        }
        
        // Toggle fullscreen mode
        function toggleFullscreen() {
            const canvasSection = document.getElementById('modelingCanvas');
            const header = canvasSection.querySelector('h1');
            const backButton = canvasSection.querySelector('.back-to-dashboard');
            const mainContainer = document.getElementById('canvasMainContainer');
            const palette = document.getElementById('elementPalette');
            const canvasArea = document.getElementById('canvasArea');
            const fullscreenIcon = document.getElementById('fullscreenToggleIcon');
            
            if (!canvasState.isFullscreen) {
                // Enter fullscreen
                canvasState.isFullscreen = true;
                
                // Hide header and back button
                if (header) header.style.display = 'none';
                if (backButton) backButton.style.display = 'none';
                
                // Make canvas section fullscreen
                canvasSection.style.position = 'fixed';
                canvasSection.style.top = '0';
                canvasSection.style.left = '0';
                canvasSection.style.width = '100vw';
                canvasSection.style.height = '100vh';
                canvasSection.style.zIndex = '10000';
                canvasSection.style.background = '#1e1e1e';
                canvasSection.style.padding = '10px';
                canvasSection.style.margin = '0';
                
                // Adjust main container
                mainContainer.style.height = 'calc(100vh - 20px)';
                
                // Reapply palette position to ensure it works in fullscreen
                const savedPosition = localStorage.getItem('palettePosition') || 'left';
                const savedFloatingPos = localStorage.getItem('paletteFloatingPos');
                applyPalettePosition(savedPosition, savedFloatingPos);
                
                // Update icon
                if (fullscreenIcon) fullscreenIcon.textContent = '';
                
                // Try native fullscreen API
                if (canvasSection.requestFullscreen) {
                    canvasSection.requestFullscreen().catch(err => {
                        console.log('Fullscreen API not supported or denied:', err);
                    });
                } else if (canvasSection.webkitRequestFullscreen) {
                    canvasSection.webkitRequestFullscreen();
                } else if (canvasSection.mozRequestFullScreen) {
                    canvasSection.mozRequestFullScreen();
                } else if (canvasSection.msRequestFullscreen) {
                    canvasSection.msRequestFullscreen();
                }
            } else {
                // Exit fullscreen
                canvasState.isFullscreen = false;
                
                // Show header and back button
                if (header) header.style.display = 'flex';
                if (backButton) backButton.style.display = 'block';
                
                // Reset canvas section styles
                canvasSection.style.position = '';
                canvasSection.style.top = '';
                canvasSection.style.left = '';
                canvasSection.style.width = '';
                canvasSection.style.height = '';
                canvasSection.style.zIndex = '';
                canvasSection.style.background = '';
                canvasSection.style.padding = '';
                canvasSection.style.margin = '';
                
                // Reset main container - remove explicit height to use CSS default (100%)
                mainContainer.style.height = '';
                
                // Show palette if it was hidden
                palette.style.display = '';
                
                // Reapply palette position after exiting fullscreen
                const savedPosition = localStorage.getItem('palettePosition') || 'left';
                const savedFloatingPos = localStorage.getItem('paletteFloatingPos');
                applyPalettePosition(savedPosition, savedFloatingPos);
                
                // Update icon
                if (fullscreenIcon) fullscreenIcon.textContent = '';
                
                // Exit native fullscreen if active (check first to avoid errors)
                const isNativeFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || 
                                            document.mozFullScreenElement || document.msFullscreenElement);
                
                if (isNativeFullscreen) {
                if (document.exitFullscreen) {
                        document.exitFullscreen().catch(err => {
                            console.log('Error exiting fullscreen:', err);
                        });
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                    }
                }
                
                // Resize template after exiting fullscreen (use requestAnimationFrame for proper timing)
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        // Double RAF ensures layout has completed
                        updateTemplateOnResize();
                    });
                });
            }
        }
        
        // Listen for fullscreen changes (ESC key, etc.)
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        
        function handleFullscreenChange() {
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || 
                                   document.mozFullScreenElement || document.msFullscreenElement);
            
            // Only reset state if user explicitly exited fullscreen (not due to modal/alert)
            // Check if a modal is currently open - if so, don't reset state
            const saveModal = document.getElementById('saveModelModal');
            const loadModal = document.getElementById('loadModelModal');
            const elementInfoModal = document.getElementById('elementInfoModal');
            const isModalOpen = (saveModal && saveModal.style.display === 'flex') ||
                               (loadModal && loadModal.style.display === 'flex') ||
                               (elementInfoModal && elementInfoModal.style.display === 'flex');
            
            if (!isFullscreen && canvasState.isFullscreen && !isModalOpen) {
                // User exited fullscreen via ESC key or other means - sync state
                canvasState.isFullscreen = false;
                
                const canvasSection = document.getElementById('modelingCanvas');
                const header = canvasSection?.querySelector('h1');
                const backButton = canvasSection?.querySelector('.back-to-dashboard');
                const mainContainer = document.getElementById('canvasMainContainer');
                const palette = document.getElementById('elementPalette');
                const fullscreenIcon = document.getElementById('fullscreenToggleIcon');
                
                // Show header and back button
                if (header) header.style.display = 'flex';
                if (backButton) backButton.style.display = 'block';
                
                // Reset canvas section styles
                if (canvasSection) {
                    canvasSection.style.position = '';
                    canvasSection.style.top = '';
                    canvasSection.style.left = '';
                    canvasSection.style.width = '';
                    canvasSection.style.height = '';
                    canvasSection.style.zIndex = '';
                    canvasSection.style.background = '';
                    canvasSection.style.padding = '';
                    canvasSection.style.margin = '';
                }
                
                // Reset main container - remove explicit height to use CSS default (100%)
                if (mainContainer) {
                    mainContainer.style.height = '';
                }
                
                // Show palette if it was hidden
                if (palette) {
                    palette.style.display = '';
                }
                
                // Update icon
                if (fullscreenIcon) fullscreenIcon.textContent = '';
                
                // Resize template after exiting fullscreen (use requestAnimationFrame for proper timing)
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        // Double RAF ensures layout has completed
                        updateTemplateOnResize();
                    });
                });
            }
        }
        
        // Load element types for palette
        async function loadElementTypes() {
            try {
                const response = await fetch('/api/records');
                const elements = await response.json();
                
                const palette = document.getElementById('elementPaletteList');
                if (!palette) {
                    console.warn('elementPaletteList not found, skipping element types load');
                    return;
                }
                palette.innerHTML = '';
                palette.style.display = 'flex';
                palette.style.flexDirection = 'column';
                palette.style.gap = '12px';
                
                // Group by facet, then by element type
                const facetGroups = {};
                elements.forEach(elem => {
                    if (elem.element && elem.facet) {
                        const facet = elem.facet;
                        if (!facetGroups[facet]) {
                            facetGroups[facet] = {};
                        }
                        if (!facetGroups[facet][elem.element]) {
                            facetGroups[facet][elem.element] = {
                                id: elem.id,
                                name: elem.element,
                                facet: facet,
                                image: elem.image_url || `/images/Shape-${elem.element}.svg`
                            };
                        }
                    }
                });
                
                // Sort facets in custom order: Identity, Experience, Architecture, Organisation, Product, Brand, Base
                const facetOrder = ['Identity', 'Experience', 'Architecture', 'Organisation', 'Product', 'Brand', 'Base'];
                const sortedFacets = Object.keys(facetGroups).sort((a, b) => {
                    const indexA = facetOrder.indexOf(a);
                    const indexB = facetOrder.indexOf(b);
                    // If facet is not in the order list, put it at the end
                    if (indexA === -1 && indexB === -1) return a.localeCompare(b);
                    if (indexA === -1) return 1;
                    if (indexB === -1) return -1;
                    return indexA - indexB;
                });
                
                // Create element facet groups with icons
                sortedFacets.forEach(facet => {
                    // Create unique ID for this facet group
                    const facetId = `palette-facet-${facet.toLowerCase().replace(/\s+/g, '-')}`;
                    
                    // Create facet header (clickable)
                    const facetHeader = document.createElement('div');
                    facetHeader.style.cssText = `
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        margin-bottom: 8px;
                        padding: 6px 0;
                        border-bottom: 1px solid rgba(255,255,255,0.1);
                        cursor: pointer;
                        user-select: none;
                        transition: background 0.2s;
                    `;
                    facetHeader.onmouseover = function() {
                        this.style.background = 'rgba(255,255,255,0.05)';
                    };
                    facetHeader.onmouseout = function() {
                        this.style.background = 'transparent';
                    };
                    
                    // Create chevron icon (grey)
                    const chevron = document.createElement('span');
                    chevron.id = `chevron-${facetId}`;
                    chevron.className = 'expand-icon';
                    chevron.style.cssText = `
                        font-size: 14px;
                        color: #808080;
                        transition: transform 0.2s;
                    `;
                    chevron.textContent = ''; // Start expanded
                    
                    // Create facet icon
                    const facetIcon = document.createElement('img');
                    // Use Icon-{facet} format (e.g., Icon-architecture.svg)
                    const facetIconName = facet.toLowerCase().replace(/\s+/g, '-');
                    facetIcon.src = `/images/Icon-${facetIconName}.svg`;
                    facetIcon.alt = facet;
                    facetIcon.style.cssText = `
                        width: 24px;
                        height: 24px;
                        object-fit: contain;
                    `;
                    facetIcon.onerror = function() {
                        // Fallback to Facet- format if Icon- doesn't exist
                        this.src = `/images/Facet-${facet}.svg`;
                        this.onerror = function() {
                            this.style.display = 'none';
                        };
                    };
                    
                    const facetLabel = document.createElement('div');
                    facetLabel.textContent = facet;
                    facetLabel.style.cssText = `
                        color: #ffffff;
                        font-size: 14px;
                        font-weight: 600;
                        text-transform: capitalize;
                    `;
                    
                    // Add click handler to toggle facet
                    facetHeader.addEventListener('click', () => {
                        togglePaletteFacet(facetId);
                    });
                    
                    facetHeader.appendChild(chevron);
                    facetHeader.appendChild(facetIcon);
                    facetHeader.appendChild(facetLabel);
                    palette.appendChild(facetHeader);
                    
                    // Create element cards grid for this facet (3 columns for side mode)
                    const facetGrid = document.createElement('div');
                    facetGrid.id = facetId;
                    facetGrid.style.cssText = `
                        display: grid;
                        grid-template-columns: repeat(3, 1fr);
                        gap: 4px;
                        margin-bottom: 8px;
                    `;
                    
                    const facetElements = Object.values(facetGroups[facet]);
                    facetElements.forEach(type => {
                    const card = document.createElement('div');
                    card.className = 'element-palette-card';
                    card.draggable = true;
                    card.dataset.elementTypeId = type.id;
                    card.dataset.elementType = type.name;
                    card.style.cssText = `
                        background: #1e1e1e;
                        border: 1px solid rgba(255,255,255,0.1);
                        border-radius: 4px;
                        padding: 5px;
                        cursor: grab;
                        text-align: center;
                        transition: all 0.2s;
                        user-select: none;
                    `;
                    card.innerHTML = `
                        <img src="${type.image}" alt="${type.name}" 
                             style="width: 28px; height: 28px; margin-bottom: 4px; object-fit: contain;"
                             onerror="this.src='/images/Shape-${type.name}.svg'; this.onerror=null;">
                        <div style="color: #ffffff; font-size: 9px; font-weight: 500; line-height: 1.2;">${type.name}</div>
                    `;
                    
                    card.addEventListener('dragstart', (e) => {
                        // Don't handle drag if it's coming from a menu item (instance drag)
                        if (e.instanceDrag || e.target.closest('#paletteInstanceMenu')) {
                            console.log('Drag from menu item - ignoring card dragstart');
                            return;
                        }
                        
                        // Don't handle if instanceId is already set (instance drag in progress)
                        const types = Array.from(e.dataTransfer.types || []);
                        if (types.includes('instanceId')) {
                            console.log('Instance drag detected - ignoring card dragstart');
                            return;
                        }
                        
                        console.log('Element dragstart:', { id: type.id, name: type.name, image: type.image });
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('elementTypeId', type.id.toString());
                        e.dataTransfer.setData('elementType', type.name);
                        e.dataTransfer.setData('elementImage', type.image);
                        console.log('Drag data types set:', Array.from(e.dataTransfer.types));
                        card.style.opacity = '0.5';
                    });
                    
                    card.addEventListener('dragend', () => {
                        card.style.opacity = '1';
                    });
                    
                    card.addEventListener('mouseenter', () => {
                        card.style.background = '#252550';
                        card.style.transform = 'scale(1.05)';
                    });
                    
                    card.addEventListener('mouseleave', () => {
                        card.style.background = '#1e1e1e';
                        card.style.transform = 'scale(1)';
                    });
                    
                        // Add context menu for showing existing instances
                        card.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            showPaletteInstanceMenu(type.id, type.name, e);
                        });
                        
                        facetGrid.appendChild(card);
                    });
                    
                    palette.appendChild(facetGrid);
                });
            } catch (error) {
                console.error('Error loading element types:', error);
            }
        }
        
        // Toggle palette facet expansion
        function togglePaletteFacet(facetId) {
            const facetGrid = document.getElementById(facetId);
            const chevron = document.getElementById(`chevron-${facetId}`);
            
            if (facetGrid && chevron) {
                if (facetGrid.style.display === 'none') {
                    facetGrid.style.display = 'grid';
                    chevron.style.transform = 'rotate(0deg)';
                    chevron.textContent = '';
                } else {
                    facetGrid.style.display = 'none';
                    chevron.style.transform = 'rotate(-90deg)';
                    chevron.textContent = '';
                }
            }
        }
        
        // Palette Instance Menu Functions
        let paletteMenuRef = null;
        
        async function getInstancesForElementType(elementTypeId) {
            try {
                // Fetch all instances of this element type from repository (across all models)
                const response = await fetch(`/api/canvas/element-instances/by-type/${elementTypeId}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const instances = await response.json();
                console.log(`Found ${instances.length} instances of element type ${elementTypeId} in repository`);
                return instances || [];
            } catch (error) {
                console.error('Error fetching instances for element type:', error);
                return [];
            }
        }
        
        function closePaletteInstanceMenu() {
            const menu = document.getElementById('paletteInstanceMenu');
            if (menu) {
                menu.style.display = 'none';
            }
            if (paletteMenuRef && paletteMenuRef.closeHandler) {
                document.removeEventListener('click', paletteMenuRef.closeHandler);
                paletteMenuRef = null;
            }
        }
        
        async function showPaletteInstanceMenu(elementTypeId, elementTypeName, event) {
            // Close any existing menu first
            closePaletteInstanceMenu();
            
            const menu = document.getElementById('paletteInstanceMenu');
            const listContainer = document.getElementById('paletteInstanceList');
            const emptyState = document.getElementById('paletteInstanceEmpty');
            const typeLabel = document.getElementById('paletteMenuElementType');
            const countLabel = document.getElementById('paletteMenuInstanceCount');
            
            if (!menu) return;
            
            // Show loading state
            typeLabel.textContent = elementTypeName;
            countLabel.textContent = '...';
            listContainer.innerHTML = '<div class="palette-menu-empty" style="display: block;">Loading instances...</div>';
            emptyState.style.display = 'none';
            listContainer.style.display = 'block';
            
            // Position menu immediately (before async fetch)
            const rect = event.target.getBoundingClientRect();
            const paletteRect = document.getElementById('elementPalette').getBoundingClientRect();
            let menuX = rect.right + 5;
            let menuY = rect.top;
            
            // Adjust if menu would overflow right edge
            if (menuX + 300 > window.innerWidth) {
                menuX = rect.left - 305; // Position to the left instead
            }
            
            // Adjust if menu would overflow bottom edge
            if (menuY + 400 > window.innerHeight) {
                menuY = window.innerHeight - 405;
            }
            
            menu.style.left = menuX + 'px';
            menu.style.top = menuY + 'px';
            menu.style.display = 'block';
            
            try {
                // Get instances for this element type from repository
                const instances = await getInstancesForElementType(elementTypeId);
                
                // Group by occurrence name
                const occurrenceMap = {};
                instances.forEach(instance => {
                    const key = instance.instance_name || `Instance ${instance.id}`;
                    if (!occurrenceMap[key]) {
                        occurrenceMap[key] = { instance, count: 0 };
                    }
                    occurrenceMap[key].count += 1;
                });
                const occurrences = Object.values(occurrenceMap);

                // Update header
                typeLabel.textContent = elementTypeName;
                countLabel.textContent = occurrences.length > 0 ? `(${occurrences.length})` : '';
                
                // Clear previous items
                listContainer.innerHTML = '';
                
                if (occurrences.length === 0) {
                    // Show empty state
                    emptyState.style.display = 'block';
                    listContainer.style.display = 'none';
                } else {
                    // Hide empty state
                    emptyState.style.display = 'none';
                    listContainer.style.display = 'block';
                    
                    // Create menu items for each occurrence
                    occurrences.forEach(group => {
                        const item = createPaletteInstanceMenuItem(group, elementTypeId);
                        listContainer.appendChild(item);
                    });
                }
            } catch (error) {
                console.error('Error loading instances:', error);
                listContainer.innerHTML = '<div style="padding: 16px; color: #ff6b6b; font-size: 11px; text-align: center;">Error loading instances</div>';
                emptyState.style.display = 'none';
            }
            
            // Add click-outside handler
            const closeHandler = (e) => {
                if (!menu.contains(e.target) && !event.target.contains(e.target)) {
                    closePaletteInstanceMenu();
                }
            };
            
            // Delay to avoid immediate close
            setTimeout(() => {
                document.addEventListener('click', closeHandler);
                paletteMenuRef = { closeHandler };
            }, 100);
        }
        
        function createPaletteInstanceMenuItem(group, elementTypeId) {
            const instance = group.instance;
            const item = document.createElement('div');
            item.className = 'palette-instance-item';
            item.draggable = true;
            item.dataset.instanceId = instance.id;
            item.style.cursor = 'grab';
            
            // Truncate long names
            const displayName = instance.instance_name || `Instance ${instance.id}`;
            const truncatedName = displayName.length > 25 
                ? displayName.substring(0, 22) + '...' 
                : displayName;
            
            const typeLabel = group.showType && group.typeLabel
                ? `<span class="instance-type">${group.typeLabel}</span>`
                : '';
            
            item.innerHTML = `
                <img src="${instance.image_url || `/images/Shape-${instance.element_type}.svg`}" 
                     onerror="this.src='/images/Shape-${instance.element_type}.svg'; this.onerror=null;">
                <span class="instance-name" title="${displayName}">${truncatedName}</span>
                ${typeLabel}
                ${group.count > 1 ? `<span style="margin-left: auto; color: #888; font-size: 10px;">${group.count}x</span>` : ''}
            `;
            
            // Prevent context menu on right-click
            item.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
            
            // Drag start handler
            item.addEventListener('dragstart', (e) => {
                console.log('Dragging existing instance:', instance);
                e.stopPropagation(); // Prevent event bubbling to parent elements
                e.stopImmediatePropagation(); // Prevent other handlers on same element
                e.dataTransfer.effectAllowed = 'copy';
                
                // Set instance-specific data
                e.dataTransfer.setData('instanceId', instance.id.toString());
                e.dataTransfer.setData('isExistingInstance', 'true');
                e.dataTransfer.setData('elementTypeId', instance.element_type_id.toString());
                e.dataTransfer.setData('elementType', instance.element_type || '');
                e.dataTransfer.setData('instanceName', instance.instance_name || '');
                e.dataTransfer.setData('imageUrl', instance.image_url || instance.element_image_url || '');
                e.dataTransfer.setData('width', (instance.width || 120).toString());
                e.dataTransfer.setData('height', (instance.height || 120).toString());
                
                // Store properties as JSON
                if (instance.properties && instance.properties.length > 0) {
                    e.dataTransfer.setData('properties', JSON.stringify(instance.properties));
                }
                
                // Store relationships as JSON
                if (instance.relationships && instance.relationships.length > 0) {
                    e.dataTransfer.setData('relationships', JSON.stringify(instance.relationships));
                }
                if (instance.incoming_relationships && instance.incoming_relationships.length > 0) {
                    e.dataTransfer.setData('incoming_relationships', JSON.stringify(instance.incoming_relationships));
                }
                
                console.log('Instance drag data types:', Array.from(e.dataTransfer.types));
                console.log('Instance drag data:', {
                    instanceId: instance.id,
                    elementTypeId: instance.element_type_id,
                    elementType: instance.element_type,
                    instanceName: instance.instance_name
                });
                
                // Mark event to prevent card handler from firing
                e.instanceDrag = true;
                
                item.style.opacity = '0.5';
                // Don't close menu immediately - wait until dragend to avoid cancelling drag
                // closePaletteInstanceMenu(); // Close menu when dragging starts
            }, true); // Use capture phase to fire BEFORE card handler
            
            item.addEventListener('dragend', (e) => {
                item.style.opacity = '1';
                e.stopPropagation();
                // Close menu after drag ends (whether successful or cancelled)
                closePaletteInstanceMenu();
            });
            
            // Prevent mousedown from interfering with drag
            item.addEventListener('mousedown', (e) => {
                // Allow drag to start
                e.stopPropagation();
            });
            
            return item;
        }
        
        // Create copy of existing instance (creates new database record)
        async function createInstanceCopy(sourceInstance, x, y) {
            saveStateForUndo(); // Save state before creating
            
            // Snap to grid
            const isPeople = sourceInstance.element_type && 
                             sourceInstance.element_type.toLowerCase() === 'people';
            const elementWidth = isPeople ? 60 : (sourceInstance.width || 120);
            const elementHeight = isPeople ? 60 : (sourceInstance.height || 120);
            
            const snappedPos = snapElementToGrid(x, y, elementWidth, elementHeight);
            
            // Create new instance record in database (not a duplicate, but a new instance)
            try {
                // Ensure we have a model ID (create one if needed)
                if (!canvasState.currentModelId) {
                    // Create a temporary model name if none exists
                    const modelName = canvasState.currentModelName || 'Untitled Model';
                    const modelResponse = await fetch('/api/canvas/models', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: modelName,
                            description: '',
                            canvas_width: 2000,
                            canvas_height: 2000,
                            zoom_level: canvasState.zoom,
                            pan_x: canvasState.panX,
                            pan_y: canvasState.panY
                        })
                    });
                    
                    if (!modelResponse.ok) {
                        throw new Error('Failed to create model');
                    }
                    
                    const modelData = await modelResponse.json();
                    canvasState.currentModelId = modelData.id;
                    canvasState.currentModelName = modelData.name;
                }
                
                // Create new element instance in database
                const instanceResponse = await fetch('/api/canvas/element-instances', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        canvas_model_id: canvasState.currentModelId,
                        element_type_id: sourceInstance.element_type_id,
                        instance_name: sourceInstance.instance_name, // Same name - user can rename later
                        x_position: snappedPos.x,
                        y_position: snappedPos.y,
                        width: elementWidth,
                        height: elementHeight,
                        z_index: 0
                    })
                });
                
                if (!instanceResponse.ok) {
                    const error = await instanceResponse.json();
                    throw new Error(error.error || 'Failed to create element instance');
                }
                
                const newInstanceData = await instanceResponse.json();
                
                // Use database ID instead of generating a new one
                const copy = {
                    id: newInstanceData.id, // Use database ID
                    element_type_id: newInstanceData.element_type_id,
                    element_type: newInstanceData.element_type,
                    instance_name: newInstanceData.instance_name,
                    x_position: newInstanceData.x_position,
                    y_position: newInstanceData.y_position,
                    width: newInstanceData.width,
                    height: newInstanceData.height,
                    image_url: newInstanceData.element_image_url || sourceInstance.image_url || '',
                    properties: sourceInstance.properties ? [...sourceInstance.properties] : []
                };
                
                // Update nextElementId if needed
                if (copy.id >= canvasState.nextElementId) {
                    canvasState.nextElementId = copy.id + 1;
                }
                
                // Add to state
                canvasState.elements.push(copy);
                
                // Render on canvas
                renderElement(copy);
                
                // Recreate properties for the copied instance
                recreateInstanceProperties(sourceInstance, copy);
                
                // Recreate relationships to matching instances on canvas
                recreateInstanceRelationships(sourceInstance, copy);
                
                // Update canvas info and undo/redo
                updateCanvasInfo();
                updateUndoRedoButtons();
                
                console.log('Created new instance record in database:', copy);
            } catch (error) {
                console.error('Error creating element instance:', error);
                showCanvasToast(`Failed to create element instance: ${error.message}`, 'error');
            }
        }
        
        // Recreate properties for a copied instance
        function recreateInstanceProperties(sourceInstance, newInstance) {
            // Get properties from source instance
            const sourceProperties = sourceInstance.properties || [];
            
            console.log('Recreating properties for instance:', {
                newInstanceId: newInstance.id,
                sourcePropertiesCount: sourceProperties.length
            });
            
            // Create property instances for each property
            sourceProperties.forEach((property, index) => {
                // Count existing properties for this element to calculate position
                const existingProperties = canvasState.propertyInstances.filter(
                    p => p.element_instance_id === newInstance.id
                );
                const position = calculatePropertyPosition(newInstance, existingProperties.length);
                
                // Handle different property structures (from API vs from current model)
                const propertyId = property.property_id || property.id;
                const propertyName = property.propertyname || property.instance_name || '';
                const instanceName = property.instance_name || property.propertyname || propertyName;
                
                if (!propertyId) {
                    console.warn('Property missing property_id, skipping:', property);
                    return; // Skip properties without a valid property_id
                }
                
                const sourceFlag = property.source || (property.rule_id != null ? 'rules_engine' : '');
                const propertyInstance = {
                    id: canvasState.nextPropertyInstanceId++,
                    property_id: propertyId,
                    element_instance_id: newInstance.id,
                    instance_name: instanceName,
                    x_position: position.x,
                    y_position: position.y,
                    isDropped: true, // Mark as dropped property (non-editable)
                    width: position.width,
                    height: position.height,
                    propertyname: propertyName,
                    ragtype: property.ragtype,
                    image_url: property.image_url,
                    source: sourceFlag,
                    rule_id: property.rule_id || null
                };
                
                console.log('Creating property instance:', propertyInstance);
                canvasState.propertyInstances.push(propertyInstance);
                
                // Render the property instance
                renderPropertyInstance(propertyInstance);
            });
            
            // Update positions for all properties on this element (to ensure proper stacking)
            if (sourceProperties.length > 0) {
                updatePropertyPositionsForElement(newInstance.id);
            }
        }
        
        // Recreate relationships for a copied instance
        function recreateInstanceRelationships(sourceInstance, newInstance) {
            // Get relationships from source instance (if available)
            const sourceRelationships = sourceInstance.relationships || [];
            const sourceIncomingRelationships = sourceInstance.incoming_relationships || [];
            
            console.log('Recreating relationships for instance:', {
                newInstanceId: newInstance.id,
                sourceRelationships: sourceRelationships.length,
                sourceIncomingRelationships: sourceIncomingRelationships.length
            });
            
            // Process outgoing relationships (sourceInstance -> target)
            sourceRelationships.forEach(rel => {
                // Find matching target instance on canvas by element_type_id and instance_name
                const matchingTarget = canvasState.elements.find(e => 
                    e.element_type_id === rel.target_element_type_id &&
                    e.instance_name === rel.target_instance_name
                );
                
                if (matchingTarget) {
                    console.log('Found matching target for relationship:', {
                        source: newInstance.instance_name,
                        target: matchingTarget.instance_name,
                        relationshipType: rel.relationship_type
                    });
                    createConnection(newInstance.id, matchingTarget.id, rel.relationship_type);
                } else {
                    console.log('No matching target found for relationship:', {
                        targetElementType: rel.target_element_type,
                        targetInstanceName: rel.target_instance_name
                    });
                }
            });
            
            // Process incoming relationships (source -> sourceInstance)
            sourceIncomingRelationships.forEach(rel => {
                // Find matching source instance on canvas by element_type_id and instance_name
                const matchingSource = canvasState.elements.find(e => 
                    e.element_type_id === rel.source_element_type_id &&
                    e.instance_name === rel.source_instance_name
                );
                
                if (matchingSource) {
                    console.log('Found matching source for incoming relationship:', {
                        source: matchingSource.instance_name,
                        target: newInstance.instance_name,
                        relationshipType: rel.relationship_type
                    });
                    createConnection(matchingSource.id, newInstance.id, rel.relationship_type);
                } else {
                    console.log('No matching source found for incoming relationship:', {
                        sourceElementType: rel.source_element_type,
                        sourceInstanceName: rel.source_instance_name
                    });
                }
            });
        }
        
        // Create copy of existing instance from API data (for instances from other models)
        // Creates new database record instead of duplicating
        async function createInstanceCopyFromData(sourceInstanceData, x, y) {
            saveStateForUndo(); // Save state before creating
            
            // Snap to grid
            const isPeople = sourceInstanceData.element_type && 
                             sourceInstanceData.element_type.toLowerCase() === 'people';
            const elementWidth = isPeople ? 60 : (sourceInstanceData.width || 120);
            const elementHeight = isPeople ? 60 : (sourceInstanceData.height || 120);
            
            const snappedPos = snapElementToGrid(x, y, elementWidth, elementHeight);
            
            // Create new instance record in database (not a duplicate, but a new instance)
            try {
                // Ensure we have a model ID (create one if needed)
                if (!canvasState.currentModelId) {
                    // Create a temporary model name if none exists
                    const modelName = canvasState.currentModelName || 'Untitled Model';
                    const modelResponse = await fetch('/api/canvas/models', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: modelName,
                            description: '',
                            canvas_width: 2000,
                            canvas_height: 2000,
                            zoom_level: canvasState.zoom,
                            pan_x: canvasState.panX,
                            pan_y: canvasState.panY
                        })
                    });
                    
                    if (!modelResponse.ok) {
                        throw new Error('Failed to create model');
                    }
                    
                    const modelData = await modelResponse.json();
                    canvasState.currentModelId = modelData.id;
                    canvasState.currentModelName = modelData.name;
                }
                
                // Create new element instance in database
                const instanceResponse = await fetch('/api/canvas/element-instances', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        canvas_model_id: canvasState.currentModelId,
                        element_type_id: sourceInstanceData.element_type_id,
                        instance_name: sourceInstanceData.instance_name, // Same name - user can rename later
                        x_position: snappedPos.x,
                        y_position: snappedPos.y,
                        width: elementWidth,
                        height: elementHeight,
                        z_index: 0
                    })
                });
                
                if (!instanceResponse.ok) {
                    const error = await instanceResponse.json();
                    throw new Error(error.error || 'Failed to create element instance');
                }
                
                const newInstanceData = await instanceResponse.json();
                
                // Use database ID instead of generating a new one
                const copy = {
                    id: newInstanceData.id, // Use database ID
                    element_type_id: newInstanceData.element_type_id,
                    element_type: newInstanceData.element_type,
                    instance_name: newInstanceData.instance_name,
                    x_position: newInstanceData.x_position,
                    y_position: newInstanceData.y_position,
                    width: newInstanceData.width,
                    height: newInstanceData.height,
                    image_url: newInstanceData.element_image_url || sourceInstanceData.image_url || '',
                    properties: sourceInstanceData.properties ? [...sourceInstanceData.properties] : []
                };
                
                // Update nextElementId if needed
                if (copy.id >= canvasState.nextElementId) {
                    canvasState.nextElementId = copy.id + 1;
                }
                
                // Add to state
                canvasState.elements.push(copy);
                
                // Render on canvas
                renderElement(copy);
                
                // Recreate properties for the copied instance
                recreateInstanceProperties(sourceInstanceData, copy);
                
                // Recreate relationships to matching instances on canvas
                recreateInstanceRelationships(sourceInstanceData, copy);
                
                // Update canvas info and undo/redo
                updateCanvasInfo();
                updateUndoRedoButtons();
                
                console.log('Created new instance record in database from API data:', copy);
            } catch (error) {
                console.error('Error creating element instance:', error);
                showCanvasToast(`Failed to create element instance: ${error.message}`, 'error');
            }
        }
        
        // Load relationship rules for auto-connection
        async function loadRelationshipRules() {
            try {
                const response = await fetch('/api/canvas/relationship-rules');
                canvasState.relationshipRules = await response.json();
                console.log('Loaded relationship rules:', canvasState.relationshipRules);
                
                // Check if Process -> Process flow rule exists
                const processFlowRule = canvasState.relationshipRules.find(rule => 
                    rule.source_element_type === 'Process' && 
                    rule.target_element_type === 'Process' && 
                    rule.relationship_type === 'flow'
                );
                
                if (!processFlowRule) {
                    console.warn('Process -> Process flow relationship rule not found. Attempting to initialize...');
                    // Try to initialize it
                    try {
                        const initResponse = await fetch('/api/canvas/init-process-flow', { method: 'POST' });
                        const initResult = await initResponse.json();
                        console.log('Init result:', initResult);
                        
                        // Reload relationship rules
                        const reloadResponse = await fetch('/api/canvas/relationship-rules');
                        canvasState.relationshipRules = await reloadResponse.json();
                        console.log('Reloaded relationship rules:', canvasState.relationshipRules);
                    } catch (initError) {
                        console.error('Error initializing Process flow relationship:', initError);
                    }
                }
            } catch (error) {
                console.error('Error loading relationship rules:', error);
            }
        }
        
        // Load properties for palette
        async function loadPropertiesForPalette() {
            try {
                const response = await fetch('/api/canvas/properties/palette');
                const properties = await response.json();
                
                const palette = document.getElementById('propertyPaletteList');
                if (!palette) return;
                palette.innerHTML = '';
                
                properties.forEach(prop => {
                    const card = document.createElement('div');
                    card.className = 'property-palette-card';
                    card.draggable = true;
                    card.dataset.propertyId = prop.id;
                    card.dataset.propertyname = prop.propertyname;
                    card.dataset.ragtype = prop.ragtype || '';
                    card.dataset.imageUrl = prop.image_url || '';
                    card.style.cssText = `
                        background: #1e1e1e;
                        border: 1px solid rgba(255,255,255,0.1);
                        border-radius: 4px;
                        padding: 4px;
                        cursor: grab;
                        text-align: center;
                        transition: all 0.2s;
                        user-select: none;
                    `;
                    
                    const tagImage = prop.image_url || getTagImageFromRAG(prop.ragtype) || '/images/Tag-Green.svg';
                    card.innerHTML = `
                        <img src="${tagImage}" alt="${prop.propertyname}" 
                             style="width: 24px; height: 24px; margin-bottom: 4px; object-fit: contain;"
                             onerror="this.src='/images/Tag-Green.svg'; this.onerror=null;">
                        <div style="color: #ffffff; font-size: 8px; font-weight: 500; word-wrap: break-word;">${escapeHtml(prop.propertyname || 'Property')}</div>
                    `;
                    
                    card.addEventListener('dragstart', (e) => {
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', prop.id.toString()); // Required for dragover detection
                        e.dataTransfer.setData('propertyId', prop.id.toString());
                        e.dataTransfer.setData('propertyname', prop.propertyname);
                        e.dataTransfer.setData('ragtype', prop.ragtype || '');
                        e.dataTransfer.setData('imageUrl', tagImage);
                        card.style.opacity = '0.5';
                    });
                    
                    card.addEventListener('dragend', () => {
                        card.style.opacity = '1';
                    });
                    
                    card.addEventListener('mouseenter', () => {
                        card.style.background = '#252550';
                        card.style.transform = 'scale(1.05)';
                    });
                    
                    card.addEventListener('mouseleave', () => {
                        card.style.background = '#1e1e1e';
                        card.style.transform = 'scale(1)';
                    });
                    
                    palette.appendChild(card);
                });
            } catch (error) {
                console.error('Error loading properties:', error);
            }
        }
        
        // Initialize palette sections (collapse/expand state)
        function initPaletteSections() {
            // Load saved collapse state from localStorage
            const savedState = localStorage.getItem('paletteSectionsState');
            const sectionsState = savedState ? JSON.parse(savedState) : {
                elementTypes: true,
                properties: true,
                templates: true
            };
            
            // Initialize each section
            ['elementTypes', 'properties', 'templates'].forEach(sectionId => {
                const isExpanded = sectionsState[sectionId] !== false; // Default to expanded
                setPaletteSectionState(sectionId, isExpanded, false); // false = don't save to localStorage yet
            });
        }
        
        // Toggle palette section collapse/expand
        function togglePaletteSection(sectionId) {
            const content = document.getElementById(`${sectionId}-content`);
            const chevron = document.getElementById(`${sectionId}-chevron`);
            
            if (!content || !chevron) return;
            
            // Check current state by looking at computed style or stored attribute
            const currentMaxHeight = content.style.maxHeight;
            const isCurrentlyExpanded = !currentMaxHeight || (currentMaxHeight !== '0px' && content.offsetHeight > 0);
            setPaletteSectionState(sectionId, !isCurrentlyExpanded, true);
        }
        
        // Set palette section state (expanded or collapsed)
        function setPaletteSectionState(sectionId, isExpanded, saveToStorage = true) {
            const content = document.getElementById(`${sectionId}-content`);
            const chevron = document.getElementById(`${sectionId}-chevron`);
            
            if (!content || !chevron) return;
            
            if (isExpanded) {
                // Expand: Set to a large max-height to show all content
                content.style.maxHeight = '5000px'; // Large value to accommodate any content
                chevron.style.transform = 'rotate(0deg)';
                chevron.textContent = '';
            } else {
                // Collapse: Set max-height to 0
                content.style.maxHeight = '0px';
                chevron.style.transform = 'rotate(-90deg)';
                chevron.textContent = '';
            }
            
            // Save state to localStorage
            if (saveToStorage) {
                const savedState = localStorage.getItem('paletteSectionsState');
                const sectionsState = savedState ? JSON.parse(savedState) : {};
                sectionsState[sectionId] = isExpanded;
                localStorage.setItem('paletteSectionsState', JSON.stringify(sectionsState));
            }
        }
        
        // Load templates for palette
        // Generate thumbnail SVG for Service Blueprint template
        function generateServiceBlueprintThumbnailSVG() {
            const thumbnailSize = 120;
            const thumbnailWidth = thumbnailSize * 1.5; // Wider for horizontal layout
            const laneHeight = thumbnailSize / 3;
            const iconAreaWidth = 30;
            
            const svgNS = 'http://www.w3.org/2000/svg';
            const svg = document.createElementNS(svgNS, 'svg');
            svg.setAttribute('width', thumbnailWidth);
            svg.setAttribute('height', thumbnailSize);
            svg.setAttribute('viewBox', `0 0 ${thumbnailWidth} ${thumbnailSize}`);
            
            // Use Service Blueprint colors with 0.5 opacity
            const colors = {
                experience: '#FF99BD',
                product: '#E599FF',
                architecture: '#A6C0FF'
            };
            
            const lanes = [
                { name: 'Experience', y: 0, color: colors.experience },
                { name: 'Product', y: laneHeight, color: colors.product },
                { name: 'Architecture', y: laneHeight * 2, color: colors.architecture }
            ];
            
            // Add white background rectangle underneath all segments to ensure colors are maintained in dark mode
            const whiteBackground = document.createElementNS(svgNS, 'rect');
            whiteBackground.setAttribute('x', 0);
            whiteBackground.setAttribute('y', 0);
            whiteBackground.setAttribute('width', thumbnailWidth);
            whiteBackground.setAttribute('height', thumbnailSize);
            whiteBackground.setAttribute('fill', '#ffffff');
            whiteBackground.setAttribute('opacity', '1');
            svg.appendChild(whiteBackground);
            
            lanes.forEach((lane, index) => {
                // Background rectangle
                const rect = document.createElementNS(svgNS, 'rect');
                rect.setAttribute('x', 0);
                rect.setAttribute('y', lane.y);
                rect.setAttribute('width', thumbnailWidth);
                rect.setAttribute('height', laneHeight);
                rect.setAttribute('fill', lane.color);
                rect.setAttribute('opacity', '0.5');
                svg.appendChild(rect);
                
                // Icon area background
                const iconAreaBg = document.createElementNS(svgNS, 'rect');
                iconAreaBg.setAttribute('x', 0);
                iconAreaBg.setAttribute('y', lane.y);
                iconAreaBg.setAttribute('width', iconAreaWidth);
                iconAreaBg.setAttribute('height', laneHeight);
                iconAreaBg.setAttribute('fill', lane.color);
                iconAreaBg.setAttribute('opacity', '0.5');
                svg.appendChild(iconAreaBg);
                
                // Divider line - same style as Milkyway Map
                if (index < lanes.length - 1) {
                    const divider = document.createElementNS(svgNS, 'line');
                    divider.setAttribute('x1', 0);
                    divider.setAttribute('y1', lane.y + laneHeight);
                    divider.setAttribute('x2', thumbnailWidth);
                    divider.setAttribute('y2', lane.y + laneHeight);
                    divider.setAttribute('stroke', '#ffffff');
                    divider.setAttribute('stroke-width', '2');
                    divider.setAttribute('opacity', '1');
                    svg.appendChild(divider);
                }
            });
            
            const svgString = new XMLSerializer().serializeToString(svg);
            const base64 = btoa(unescape(encodeURIComponent(svgString)));
            return `data:image/svg+xml;base64,${base64}`;
        }
        
        // Generate thumbnail SVG for Milkyway Map template
        function generateMilkywayMapThumbnailSVG() {
            // Create a small-scale version for thumbnail (fixed size: 120x120)
            const thumbnailSize = 120;
            const centerX = thumbnailSize / 2;
            const centerY = thumbnailSize / 2;
            
            // Define circle sizes (scaled for thumbnail)
            const baseSize = thumbnailSize * 0.4;
            const circle1Radius = baseSize;
            const circle2Radius = baseSize * 0.75;
            const circle3Radius = baseSize * 0.5;
            const circle4Radius = baseSize * 0.25;
            
            // Colors (using dark theme colors for thumbnail)
            const colors = {
                circle1: '#ff6b9d', // Pink
                circle2: '#9bc4e2', // Light blue
                circle3: '#9de2b4', // Light green
                circle4: '#f0f0f0', // White
                bgColor: '#f5f5f5'
            };
            
            const svgNS = 'http://www.w3.org/2000/svg';
            const svg = document.createElementNS(svgNS, 'svg');
            svg.setAttribute('width', thumbnailSize);
            svg.setAttribute('height', thumbnailSize);
            svg.setAttribute('viewBox', `0 0 ${thumbnailSize} ${thumbnailSize}`);
            
            // White background circle
            const whiteBg = document.createElementNS(svgNS, 'circle');
            whiteBg.setAttribute('cx', centerX);
            whiteBg.setAttribute('cy', centerY);
            whiteBg.setAttribute('r', circle1Radius);
            whiteBg.setAttribute('fill', '#ffffff');
            svg.appendChild(whiteBg);
            
            // Outermost ring (pink)
            const ring1 = document.createElementNS(svgNS, 'circle');
            ring1.setAttribute('cx', centerX);
            ring1.setAttribute('cy', centerY);
            ring1.setAttribute('r', circle1Radius);
            ring1.setAttribute('fill', colors.circle1);
            ring1.setAttribute('opacity', '0.5');
            ring1.setAttribute('stroke', '#ffffff');
            ring1.setAttribute('stroke-width', '2');
            svg.appendChild(ring1);
            
            // Cut out inner part
            const ring1Inner = document.createElementNS(svgNS, 'circle');
            ring1Inner.setAttribute('cx', centerX);
            ring1Inner.setAttribute('cy', centerY);
            ring1Inner.setAttribute('r', circle2Radius);
            ring1Inner.setAttribute('fill', colors.bgColor);
            svg.appendChild(ring1Inner);
            
            // Second ring (light blue)
            const ring2 = document.createElementNS(svgNS, 'circle');
            ring2.setAttribute('cx', centerX);
            ring2.setAttribute('cy', centerY);
            ring2.setAttribute('r', circle2Radius);
            ring2.setAttribute('fill', colors.circle2);
            ring2.setAttribute('opacity', '0.5');
            ring2.setAttribute('stroke', '#ffffff');
            ring2.setAttribute('stroke-width', '2');
            svg.appendChild(ring2);
            
            // Cut out inner part
            const ring2Inner = document.createElementNS(svgNS, 'circle');
            ring2Inner.setAttribute('cx', centerX);
            ring2Inner.setAttribute('cy', centerY);
            ring2Inner.setAttribute('r', circle3Radius);
            ring2Inner.setAttribute('fill', colors.bgColor);
            svg.appendChild(ring2Inner);
            
            // Third ring (light green)
            const ring3 = document.createElementNS(svgNS, 'circle');
            ring3.setAttribute('cx', centerX);
            ring3.setAttribute('cy', centerY);
            ring3.setAttribute('r', circle3Radius);
            ring3.setAttribute('fill', colors.circle3);
            ring3.setAttribute('opacity', '0.5');
            ring3.setAttribute('stroke', '#ffffff');
            ring3.setAttribute('stroke-width', '2');
            svg.appendChild(ring3);
            
            // Cut out inner part
            const ring3Inner = document.createElementNS(svgNS, 'circle');
            ring3Inner.setAttribute('cx', centerX);
            ring3Inner.setAttribute('cy', centerY);
            ring3Inner.setAttribute('r', circle4Radius);
            ring3Inner.setAttribute('fill', colors.bgColor);
            svg.appendChild(ring3Inner);
            
            // Center circle (white)
            const circle4 = document.createElementNS(svgNS, 'circle');
            circle4.setAttribute('cx', centerX);
            circle4.setAttribute('cy', centerY);
            circle4.setAttribute('r', circle4Radius);
            circle4.setAttribute('fill', colors.circle4);
            circle4.setAttribute('stroke', '#ffffff');
            circle4.setAttribute('stroke-width', '2');
            circle4.setAttribute('opacity', '0.8');
            svg.appendChild(circle4);
            
            // Draw 4 segment dividing lines (simplified for thumbnail)
            const segmentAngleStep = (2 * Math.PI) / 4;
            for (let i = 0; i < 4; i++) {
                const angle = (i * segmentAngleStep) - (Math.PI / 2);
                const x1 = centerX + Math.cos(angle) * circle4Radius;
                const y1 = centerY + Math.sin(angle) * circle4Radius;
                const x2 = centerX + Math.cos(angle) * circle1Radius;
                const y2 = centerY + Math.sin(angle) * circle1Radius;
                
                const segmentLine = document.createElementNS(svgNS, 'line');
                segmentLine.setAttribute('x1', x1);
                segmentLine.setAttribute('y1', y1);
                segmentLine.setAttribute('x2', x2);
                segmentLine.setAttribute('y2', y2);
                segmentLine.setAttribute('stroke', '#ffffff');
                segmentLine.setAttribute('stroke-width', '2');
                svg.appendChild(segmentLine);
            }
            
            // Vertical guide line
            const lineV = document.createElementNS(svgNS, 'line');
            lineV.setAttribute('x1', centerX);
            lineV.setAttribute('y1', centerY - circle1Radius);
            lineV.setAttribute('x2', centerX);
            lineV.setAttribute('y2', centerY - circle4Radius);
            lineV.setAttribute('stroke', '#ffffff');
            lineV.setAttribute('stroke-width', '2');
            svg.appendChild(lineV);
            
            // Convert SVG to data URL for use in img tag
            const svgString = new XMLSerializer().serializeToString(svg);
            const base64 = btoa(unescape(encodeURIComponent(svgString)));
            return `data:image/svg+xml;base64,${base64}`;
        }
        
        function loadTemplatesForPalette() {
            const palette = document.getElementById('templatePaletteList');
            if (!palette) return;
            palette.innerHTML = '';
            
            // Define available templates
            const templates = [
                {
                    id: 'milkyway-map',
                    name: 'Milkyway Map',
                    useGeneratedSVG: true
                },
                {
                    id: 'service-blueprint',
                    name: 'Service Blueprint',
                    useGeneratedSVG: true
                }
            ];
            
            templates.forEach(template => {
                const card = document.createElement('div');
                card.className = 'template-palette-card';
                card.draggable = true;
                card.dataset.templateId = template.id;
                card.dataset.templateName = template.name;
                card.style.cssText = `
                    background: #1e1e1e;
                    border: 1px solid rgba(255,255,255,0.1);
                    border-radius: 4px;
                    padding: 4px;
                    cursor: grab;
                    text-align: center;
                    transition: all 0.2s;
                    user-select: none;
                `;
                
                // Generate SVG thumbnail for templates
                let imageSrc = template.image;
                if (template.useGeneratedSVG) {
                    if (template.id === 'milkyway-map') {
                        imageSrc = generateMilkywayMapThumbnailSVG();
                    } else if (template.id === 'service-blueprint') {
                        imageSrc = generateServiceBlueprintThumbnailSVG();
                    }
                }
                
                card.innerHTML = `
                    <img src="${imageSrc}" alt="${template.name}" 
                         style="width: 100%; height: auto; max-height: 60px; object-fit: contain; margin-bottom: 4px; border-radius: 2px;"
                         onerror="this.style.display='none';">
                    <div style="color: #ffffff; font-size: 8px; font-weight: 500; word-wrap: break-word;">${escapeHtml(template.name)}</div>
                `;
                
                card.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('text/plain', template.id); // Required for dragover detection
                    e.dataTransfer.setData('templateId', template.id);
                    e.dataTransfer.setData('templateName', template.name);
                    e.dataTransfer.setData('isTemplate', 'true');
                    card.style.opacity = '0.5';
                });
                
                card.addEventListener('dragend', () => {
                    card.style.opacity = '1';
                });
                
                card.addEventListener('mouseenter', () => {
                    card.style.background = '#252550';
                    card.style.transform = 'scale(1.05)';
                });
                
                card.addEventListener('mouseleave', () => {
                    card.style.background = '#1e1e1e';
                    card.style.transform = 'scale(1)';
                });
                
                palette.appendChild(card);
            });
        }
        
        // Setup canvas event listeners
        // Use a flag to prevent duplicate setup
        let canvasEventListenersSetup = false;
        function setupCanvasEventListeners() {
            const container = document.getElementById('canvasContainer');
            const elementsLayer = document.getElementById('elementsLayer');
            const connectionsLayer = document.getElementById('connectionsLayer');
            
            if (!container) {
                console.error('Canvas container not found!');
                return;
            }
            
            // If already setup, skip to prevent duplicate listeners
            if (canvasEventListenersSetup) {
                console.log('Canvas event listeners already setup - skipping duplicate setup');
                return;
            }
            
            // Shared dragover handler - allow all non-property drags
            const handleDragover = (e) => {
                const types = Array.from(e.dataTransfer.types || []);
                if (types.length > 0) {
                    // Note: dataTransfer.types uses lowercase keys
                    const isPropertyDrop = types.includes('propertyid') || types.includes('propertyId');
                    const isExistingInstance = types.includes('isexistinginstance') || types.includes('isExistingInstance') || 
                                               types.includes('instanceid') || types.includes('instanceId');
                    
                    if (isPropertyDrop) {
                        e.dataTransfer.dropEffect = 'none';
                        return;
                    }
                    
                    // Allow template drops
                    if (types.includes('templateid') || types.includes('templateId')) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.dataTransfer.dropEffect = 'copy';
                    }
                    
                    // Allow element drops (new or existing instances)
                    if (isExistingInstance || types.includes('elementtypeid') || types.includes('elementTypeId')) {
                e.preventDefault();
                        e.stopPropagation();
                e.dataTransfer.dropEffect = 'copy';
                    }
                }
            };
            
            // Add dragover to container and layers
            container.addEventListener('dragover', handleDragover);
            if (elementsLayer) {
                elementsLayer.addEventListener('dragover', handleDragover);
            }
            if (connectionsLayer) {
                connectionsLayer.addEventListener('dragover', handleDragover);
            }
            
            // Shared drop handler - use a global flag to prevent multiple handlers from firing
            // Initialize global flag if it doesn't exist
            if (typeof window.canvasDropHandled === 'undefined') {
                window.canvasDropHandled = false;
            }
            
            // Store reference to old handler if it exists
            const oldDropHandler = container._canvasDropHandler;
            
            const handleDrop = async (e) => {
                console.log('=== DROP HANDLER CALLED ===', {
                    target: e.target,
                    targetId: e.target.id,
                    targetClass: e.target.className,
                    isOnElement: e.target.closest('.canvas-element') !== null
                });
                
                // Prevent multiple handlers from processing the same drop
                if (window.canvasDropHandled) {
                    console.log('Drop already handled - ignoring duplicate');
                e.preventDefault();
                e.stopPropagation();
                    e.stopImmediatePropagation();
                    return false;
                }
                
                // Check types first to determine what kind of drop this is
                // Note: dataTransfer.types uses lowercase keys
                const types = Array.from(e.dataTransfer.types || []);
                console.log('Drop event types:', types);
                const hasTemplateId = types.includes('templateid') || types.includes('templateId');
                const hasPropertyId = types.includes('propertyid') || types.includes('propertyId');
                const hasElementTypeId = types.includes('elementtypeid') || types.includes('elementTypeId');
                const hasInstanceId = types.includes('instanceid') || types.includes('instanceId');
                
                console.log('Drop detection:', { hasTemplateId, hasPropertyId, hasElementTypeId, hasInstanceId });
                
                // Handle template drops first
                if (hasTemplateId) {
                    console.log('Template drop detected');
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    window.canvasDropHandled = true;
                    
                    const templateId = e.dataTransfer.getData('templateId');
                    console.log('Applying template:', templateId);
                    
                    if (templateId) {
                        // Track that this is a new template being added
                        const previousTemplate = canvasState.canvasTemplate;
                        applyCanvasTemplate(templateId, previousTemplate !== templateId);
                    }
                    
                    setTimeout(() => {
                        window.canvasDropHandled = false;
                        console.log('Drop flag reset');
                    }, 100);
                    
                    return;
                }
                
                // Check if drop is on an existing element - but only for property drops
                // For instance drops, we want to create a copy even if dropped on an element
                // Don't return early for instance drops - they should be handled by canvas
                if (e.target.closest('.canvas-element') && hasPropertyId && !hasInstanceId) {
                    console.log('Dropped property on existing element - letting element handle it');
                    return; // Let element's drop handler process property drops
                }
                
                // If it's a property drop (and NOT an instance drop), ignore it (elements handle property drops)
                if (hasPropertyId && !hasInstanceId) {
                    console.log('Property drop detected on canvas - ignoring');
                    return;
                }
                
                // Try to detect existing instance drop by checking for instanceId in types
                // If instanceId is present, get all data at once (getData can only be called once)
                // Priority: Check instance drops FIRST before new element drops
                if (hasInstanceId) {
                    console.log('=== INSTANCE DROP DETECTED ===', { hasInstanceId, types });
                    
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    window.canvasDropHandled = true;
                    
                    // Get all instance data at once (getData can only be called once per event)
                    const instanceIdStr = e.dataTransfer.getData('instanceId');
                    const existingInstanceFlag = e.dataTransfer.getData('isExistingInstance');
                    const elementTypeIdStr = e.dataTransfer.getData('elementTypeId');
                    const elementType = e.dataTransfer.getData('elementType');
                    const instanceName = e.dataTransfer.getData('instanceName');
                    const imageUrl = e.dataTransfer.getData('imageUrl');
                    const widthStr = e.dataTransfer.getData('width');
                    const heightStr = e.dataTransfer.getData('height');
                    const propertiesJson = e.dataTransfer.getData('properties');
                    const relationshipsJson = e.dataTransfer.getData('relationships');
                    const incomingRelationshipsJson = e.dataTransfer.getData('incoming_relationships');
                    
                    console.log('Instance drop data:', {
                        instanceId: instanceIdStr,
                        isExistingInstance: existingInstanceFlag,
                        elementTypeId: elementTypeIdStr,
                        elementType,
                        instanceName,
                        imageUrl
                    });
                    
                    // Verify it's actually an existing instance
                    if (existingInstanceFlag !== 'true' || !instanceIdStr) {
                        console.log('Not actually an existing instance - ignoring', {
                            existingInstanceFlag,
                            instanceIdStr,
                            types
                        });
                        window.canvasDropHandled = false;
                        return;
                    }
                    
                    console.log('=== PROCESSING INSTANCE DROP ===', {
                        instanceId: instanceIdStr,
                        elementTypeId: elementTypeIdStr,
                        elementType,
                        instanceName
                    });
                    
                    const instanceId = parseInt(instanceIdStr);
                    const elementTypeId = parseInt(elementTypeIdStr);
                    
                    // Get properties if available
                    let properties = [];
                    if (propertiesJson) {
                        try {
                            properties = JSON.parse(propertiesJson);
                        } catch (err) {
                            console.error('Error parsing properties:', err);
                        }
                    }
                    
                    // Get relationships if available
                    let relationships = [];
                    let incomingRelationships = [];
                    if (relationshipsJson) {
                        try {
                            relationships = JSON.parse(relationshipsJson);
                            console.log('Parsed relationships:', relationships);
                        } catch (err) {
                            console.error('Error parsing relationships:', err);
                        }
                    }
                    if (incomingRelationshipsJson) {
                        try {
                            incomingRelationships = JSON.parse(incomingRelationshipsJson);
                            console.log('Parsed incoming relationships:', incomingRelationships);
                        } catch (err) {
                            console.error('Error parsing incoming relationships:', err);
                        }
                    }
                    
                    // Calculate drop position
                const rect = container.getBoundingClientRect();
                const x = (e.clientX - rect.left - canvasState.panX) / canvasState.zoom;
                const y = (e.clientY - rect.top - canvasState.panY) / canvasState.zoom;
                
                    // Try to find instance in current model first
                    const sourceInstance = canvasState.elements.find(e => e.id === instanceId);
                    
                    if (sourceInstance) {
                        // Instance is in current model - use it directly
                        // Add relationships from drag data if available (may not be in canvasState)
                        if (relationships.length > 0 || incomingRelationships.length > 0) {
                            sourceInstance.relationships = relationships;
                            sourceInstance.incoming_relationships = incomingRelationships;
                        }
                        console.log('Found instance in current model:', sourceInstance);
                        await createInstanceCopy(sourceInstance, x, y);
                    } else {
                        // Instance not in current model - fetch from API
                        console.log('Instance not in current model, fetching from API:', instanceId);
                        try {
                            // Fetch all instances of this element type to find the source
                            const instances = await getInstancesForElementType(elementTypeId);
                            const foundInstance = instances.find(inst => inst.id === instanceId);
                            if (foundInstance) {
                                // Add relationships from drag data if API didn't return them
                                if ((!foundInstance.relationships || foundInstance.relationships.length === 0) && relationships.length > 0) {
                                    foundInstance.relationships = relationships;
                                }
                                if ((!foundInstance.incoming_relationships || foundInstance.incoming_relationships.length === 0) && incomingRelationships.length > 0) {
                                    foundInstance.incoming_relationships = incomingRelationships;
                                }
                                console.log('Found instance in API:', foundInstance);
                                // Use the fetched instance data
                                await createInstanceCopyFromData(foundInstance, x, y);
                            } else {
                                console.error('Source instance not found in API:', instanceId);
                                window.canvasDropHandled = false;
                                return;
                            }
                        } catch (err) {
                            console.error('Error fetching instance from API:', err);
                            window.canvasDropHandled = false;
                            return;
                        }
                    }
                    
                    // Reset flag after a delay to allow for next drop
                    setTimeout(() => { 
                        window.canvasDropHandled = false;
                        console.log('Drop flag reset');
                    }, 1000);
                    
                    return;
                }
                
                // If it's not an element drop, ignore it
                if (!hasElementTypeId) {
                    console.log('Not an element drop - ignoring');
                    return;
                }
                
                console.log('Element drop detected on canvas');
                
                // Set flag IMMEDIATELY before any operations
                window.canvasDropHandled = true;
                
                // Stop propagation to prevent other handlers
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                
                // Get all data at once (getData can only be called once per event)
                const elementTypeId = e.dataTransfer.getData('elementTypeId');
                const elementType = e.dataTransfer.getData('elementType');
                const elementImage = e.dataTransfer.getData('elementImage');
                
                console.log('Element drop data:', { elementTypeId, elementType, elementImage });
                
                // Validate elementTypeId
                if (!elementTypeId || elementTypeId === '') {
                    console.log('No elementTypeId found - invalid drop');
                    window.canvasDropHandled = false;
                    return;
                }
                
                const rect = container.getBoundingClientRect();
                const x = (e.clientX - rect.left - canvasState.panX) / canvasState.zoom;
                const y = (e.clientY - rect.top - canvasState.panY) / canvasState.zoom;
                
                const finalElementImage = elementImage || `/images/Shape-${elementType}.svg`;
                
                console.log('Creating element instance:', { elementTypeId, elementType, elementImage: finalElementImage, x, y });
                createElementInstance(parseInt(elementTypeId), elementType, finalElementImage, x, y);
                
                // Reset flag after a delay to allow for next drop
                setTimeout(() => { 
                    window.canvasDropHandled = false;
                    console.log('Drop flag reset');
                }, 1000);
            };
            
            // Store handler reference for potential removal
            container._canvasDropHandler = handleDrop;
            
            // Remove old handler if it exists (must match the exact same function reference)
            if (oldDropHandler) {
                container.removeEventListener('drop', oldDropHandler, true);
                console.log('Removed old drop handler');
            }
            
            // Add drop handler ONLY to container - let events bubble from layers
            // Use capture phase to catch first and stop propagation
            container.addEventListener('drop', handleDrop, true);
            console.log('Added new drop handler');
            // Don't add handlers to layers - they will bubble to container
            
            // Pan with mouse drag
            let isPanning = false;
            let panStart = { x: 0, y: 0 };
            
            container.addEventListener('mousedown', (e) => {
                // Check if clicking on template layer
                const templateLayer = document.getElementById('templateLayer');
                const isClickingTemplate = templateLayer && (e.target === templateLayer || e.target.closest('#templateLayer') || templateLayer.contains(e.target));
                
                // If clicking on template and template is active, let template handle selection
                if (isClickingTemplate && canvasState.canvasTemplate === 'milkyway-map') {
                    // Template selection is handled by setupTemplateSelection click handler
                    // But if template is already selected, allow panning
                    if (canvasState.templateSelected) {
                        isPanning = true;
                        isAnyElementDragging = true;
                        panStart.x = e.clientX - canvasState.templatePanX;
                        panStart.y = e.clientY - canvasState.templatePanY;
                        container.style.cursor = 'grabbing';
                    }
                    return; // Let template handle its own click
                }
                
                // Don't start panning if clicking on an element or property
                if (e.target.closest('.canvas-element') || e.target.closest('[id^="property-"]')) {
                    // Deselect template if clicking elsewhere
                    if (canvasState.templateSelected) {
                        canvasState.templateSelected = false;
                        updateTemplateSelectionVisual();
                        updateZoomDisplay();
                    }
                    return; // Let element/property handle the event
                }
                
                // If clicking on canvas background, deselect template
                if (e.target === container || e.target.id === 'connectionsLayer' || e.target.id === 'elementsLayer' || e.target.id === 'propertyInstancesLayer') {
                    if (canvasState.templateSelected) {
                        canvasState.templateSelected = false;
                        updateTemplateSelectionVisual();
                        updateZoomDisplay();
                    }
                    
                    // Start panning elements
                    isPanning = true;
                    isAnyElementDragging = true;
                    panStart.x = e.clientX - canvasState.panX;
                    panStart.y = e.clientY - canvasState.panY;
                    container.style.cursor = 'grabbing';
                }
            });
            
            container.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    // Milkyway Map template is locked - no panning allowed
                    // Only allow panning for Service Blueprint if selected
                    if (canvasState.templateSelected && canvasState.canvasTemplate === 'service-blueprint') {
                        canvasState.templatePanX = e.clientX - panStart.x;
                        canvasState.templatePanY = e.clientY - panStart.y;
                        localStorage.setItem('templatePanX', canvasState.templatePanX.toString());
                        localStorage.setItem('templatePanY', canvasState.templatePanY.toString());
                    } else {
                        canvasState.panX = e.clientX - panStart.x;
                        canvasState.panY = e.clientY - panStart.y;
                    }
                    updateCanvasTransform();
                }
            });
            
            
            container.addEventListener('mouseup', () => {
                isPanning = false;
                isAnyElementDragging = false;
                const templateLayer = document.getElementById('templateLayer');
                if (templateLayer) {
                    // Milkyway Map is locked - always default cursor
                    if (canvasState.canvasTemplate === 'milkyway-map') {
                        templateLayer.style.cursor = 'default';
                    } else {
                        templateLayer.style.cursor = canvasState.templateSelected ? 'move' : 'pointer';
                    }
                }
                container.style.cursor = 'default';
            });
            
            // Deselect element when clicking on canvas background
            container.addEventListener('click', (e) => {
                // Don't handle clicks if property context menu is open
                const propertyMenu = document.getElementById('propertyContextMenu');
                if (propertyMenu && document.body.contains(propertyMenu)) {
                    // Let the menu handle its own clicks
                    if (propertyMenu.contains(e.target)) {
                        return;
                    }
                }
                
                // Don't deselect if clicking on an element (let element handle its own click)
                if (e.target.closest('.canvas-element')) {
                    // Deselect template when clicking on element (only for Service Blueprint)
                    if (canvasState.templateSelected && canvasState.canvasTemplate === 'service-blueprint') {
                        canvasState.templateSelected = false;
                        updateTemplateSelectionVisual();
                        updateZoomDisplay();
                    }
                    return;
                }
                
                if (e.target === container || e.target.id === 'connectionsLayer' || e.target.id === 'elementsLayer' || e.target.id === 'propertyInstancesLayer' || e.target.id === 'templateLayer') {
                    // Deselect template when clicking on canvas background (only for Service Blueprint)
                    if (canvasState.templateSelected && canvasState.canvasTemplate === 'service-blueprint') {
                        canvasState.templateSelected = false;
                        updateTemplateSelectionVisual();
                        updateZoomDisplay();
                    }
                    // Deselect element when clicking on canvas background
                    if (canvasState.selectedElementId) {
                        deselectElementForRelationship();
                    }
                    // Clear multi-select when clicking on background
                    canvasState.selectedElementIds = [];
                    updateElementSelection();
                }
            });
            
            // Zoom with mouse wheel
            container.addEventListener('wheel', (e) => {
                // Milkyway Map template is locked - no zooming allowed
                // Only allow zooming for Service Blueprint if selected
                if (canvasState.templateSelected && canvasState.canvasTemplate === 'service-blueprint') {
                    // Allow zoom with or without Ctrl when template is selected
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? -0.1 : 0.1;
                        canvasState.templateZoom = Math.max(0.2, Math.min(3.0, canvasState.templateZoom + delta));
                        localStorage.setItem('templateZoom', canvasState.templateZoom.toString());
                        updateZoomDisplay();
                        updateCanvasTransform();
                        return;
                    }
                }
                
                // Otherwise, handle normal wheel zoom for elements
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                canvasState.zoom = Math.max(0.5, Math.min(2.0, canvasState.zoom * delta));
                updateZoomDisplay();
                updateCanvasTransform();
            });
            
            // Keyboard handler for Delete key
            document.addEventListener('keydown', (e) => {
                // Only handle Delete key when canvas is active and not typing in input
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    const activeElement = document.activeElement;
                    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                        return; // Don't delete if typing in input
                    }
                    
                    // Check if modeling canvas section is active
                    const canvasSection = document.getElementById('modelingCanvas');
                    if (canvasSection && canvasSection.classList.contains('active')) {
                        e.preventDefault();
                        if (canvasState.selectedElementIds.length > 0) {
                            deleteSelectedElements();
                        }
                    }
                }
            });
        }
        
        // Snap to grid function
        const GRID_SIZE = 20;
        function snapToGrid(value) {
            return Math.round(value / GRID_SIZE) * GRID_SIZE;
        }
        
        // Snap element position to grid, aligning by center for proper alignment between different sized elements
        function snapElementToGrid(x, y, elementWidth, elementHeight) {
            // If snap to grid is disabled, return original position
            if (!canvasState.snapToGridEnabled) {
                return { x: x, y: y };
            }
            
            // Calculate center position
            const centerX = x + elementWidth / 2;
            const centerY = y + elementHeight / 2;
            
            // Snap center to grid (using 60px grid for better alignment - common multiple of 60 and 120)
            const snapGridSize = 60; // Common multiple of both 60px and 120px element sizes
            const snappedCenterX = Math.round(centerX / snapGridSize) * snapGridSize;
            const snappedCenterY = Math.round(centerY / snapGridSize) * snapGridSize;
            
            // Return top-left position based on snapped center
            return {
                x: snappedCenterX - elementWidth / 2,
                y: snappedCenterY - elementHeight / 2
            };
        }
        
        // Create element instance on canvas
        function createElementInstance(elementTypeId, elementType, elementImage, x, y) {
            saveStateForUndo(); // Save state before creating
            
            // Fetch all records to get the correct element_type from the database
            fetch('/api/records')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(allRecords => {
                    // Find the record matching elementTypeId
                    const elementData = Array.isArray(allRecords) ? 
                        allRecords.find(r => r.id === elementTypeId) : null;
                    
                    // Use the element value from database, fallback to passed elementType
                    const correctElementType = (elementData && elementData.element) || elementType;
                    
                    console.log('Creating element instance:', {
                        elementTypeId,
                        passedElementType: elementType,
                        correctElementType: correctElementType,
                        foundInDB: !!elementData
                    });
                    
                    const elementId = canvasState.nextElementId++;
                    const instanceName = `${correctElementType} ${elementId}`;
                    
                    // People elements are smaller (60x60, 50% of standard size)
                    const isPeople = correctElementType && correctElementType.toLowerCase() === 'people';
                    const elementWidth = isPeople ? 60 : 120;
                    const elementHeight = isPeople ? 60 : 120;
                    
                    // Snap position to grid using center-based alignment for proper alignment between different sized elements
                    const snappedPos = snapElementToGrid(x, y, elementWidth, elementHeight);
                    
                    const element = {
                        id: elementId,
                        element_type_id: elementTypeId,
                        element_type: correctElementType,
                        instance_name: instanceName,
                        description: null,
                        x_position: snappedPos.x,
                        y_position: snappedPos.y,
                        width: elementWidth,
                        height: elementHeight,
                        image_url: elementImage,
                        properties: [] // Properties associated with this instance
                    };
                    
                    canvasState.elements.push(element);
                    renderElement(element);
                    
                    // Auto-associate element with segment if dropped on Milkyway template
                    if (canvasState.canvasTemplate === 'milkyway-map' && canvasState.templateSegments && canvasState.templateSegments.length > 0) {
                        const segmentIndex = getSegmentForPosition(snappedPos.x, snappedPos.y, elementWidth, elementHeight);
                        if (segmentIndex !== null) {
                            // Associate element with segment (async, don't wait)
                            associateElementWithSegment(element.id, segmentIndex).catch(err => {
                                console.error('Error associating element with segment:', err);
                            });
                        }
                    }
                    
                    // Only auto-create relationships if enabled
                    if (canvasState.autoCreateRelationships) {
                        autoConnectRelationships(element);
                    }
                    
                    // Start editing the element name immediately after rendering
                    setTimeout(() => {
                        startEditingElement(element.id);
                    }, 50);
                    
                    updateCanvasInfo();
                    updateUndoRedoButtons();
                })
                .catch(error => {
                    console.error('Error fetching element type:', error);
                    // Fallback to using passed elementType if fetch fails
            const elementId = canvasState.nextElementId++;
            const instanceName = `${elementType} ${elementId}`;
            
                    // People elements are smaller (60x60, 50% of standard size)
                    const isPeople = elementType && elementType.toLowerCase() === 'people';
                    const elementWidth = isPeople ? 60 : 120;
                    const elementHeight = isPeople ? 60 : 120;
                    
                    // Snap position to grid using center-based alignment for proper alignment between different sized elements
                    const snappedPos = snapElementToGrid(x, y, elementWidth, elementHeight);
            
            const element = {
                id: elementId,
                element_type_id: elementTypeId,
                element_type: elementType,
                instance_name: instanceName,
                description: null,
                        x_position: snappedPos.x,
                        y_position: snappedPos.y,
                        width: elementWidth,
                        height: elementHeight,
                image_url: elementImage,
                        properties: []
            };
            
            canvasState.elements.push(element);
            renderElement(element);
            
            // Auto-associate element with segment if dropped on Milkyway template
            if (canvasState.canvasTemplate === 'milkyway-map' && canvasState.templateSegments && canvasState.templateSegments.length > 0) {
                const segmentIndex = getSegmentForPosition(snappedPos.x, snappedPos.y, elementWidth, elementHeight);
                if (segmentIndex !== null) {
                    // Associate element with segment (async, don't wait)
                    associateElementWithSegment(element.id, segmentIndex).catch(err => {
                        console.error('Error associating element with segment:', err);
                    });
                }
            }
            
            // Only auto-create relationships if enabled
            if (canvasState.autoCreateRelationships) {
                autoConnectRelationships(element);
            }
            
            // Start editing the element name immediately after rendering
            setTimeout(() => {
                startEditingElement(element.id);
            }, 50);
            
            updateCanvasInfo();
            updateUndoRedoButtons();
                });
        }
        
        // Calculate property position relative to element instance
        function calculatePropertyPosition(elementInstance, index = 0) {
            // Properties are always 120px wide (standard size), regardless of element size
            const propertyWidth = 120;  // Standard property width for all elements
            const propertyHeight = 40;  // Fixed height for compact property display
            const propertyGap = 6;      // Gap between stacked properties and image/label
            
            // Check if this is a People element - label is below the element
            const isPeople = elementInstance.element_type && elementInstance.element_type.toLowerCase() === 'people';
            
            // Calculate actual label height for People elements based on rendered text
            let labelHeight = 0;
            if (isPeople) {
                const labelElement = document.getElementById(`element-label-${elementInstance.id}`);
                if (labelElement) {
                    // Get the actual rendered height of the label
                    const labelRect = labelElement.getBoundingClientRect();
                    const labelComputedStyle = window.getComputedStyle(labelElement);
                    // Account for margin-top (4px) and actual text height
                    labelHeight = labelRect.height + parseFloat(labelComputedStyle.marginTop) || 20;  // Fallback to 20px if measurement fails
                } else {
                    // Fallback: estimate based on text length and line height
                    // 12px font-size * 1.2 line-height = ~14.4px per line, + 4px margin-top
                    const textLength = (elementInstance.instance_name || '').length;
                    const estimatedLines = Math.ceil(textLength / 12);  // Approximate chars per line (100px max-width / ~8px per char)
                    labelHeight = (estimatedLines * 14.4) + 4;
                }
            }
            
            // For People elements, center the property horizontally (since property is wider than element)
            const propertyX = isPeople 
                ? elementInstance.x_position - (propertyWidth - elementInstance.width) / 2  // Center property relative to People element
                : elementInstance.x_position;  // Aligned with element for other elements
            
            let propertyY;
            
            if (isPeople) {
                // For People elements: properties sit directly beneath the text label
                const elementBottomY = elementInstance.y_position + elementInstance.height;
                propertyY = elementBottomY + labelHeight + propertyGap + (index * (propertyHeight + propertyGap));
            } else {
                // For standard elements: properties sit directly beneath the SVG image (not the boundary)
                // Calculate actual rendered image height accounting for object-fit: contain
                let imageBottomY = elementInstance.y_position + elementInstance.height;
                const imageElement = document.getElementById(`element-image-${elementInstance.id}`);
                
                if (imageElement) {
                    const containerWidth = elementInstance.width - 4; // Subtract border (2px each side)
                    const containerHeight = elementInstance.height - 4; // Subtract border (2px each side)
                    if (imageElement.complete && imageElement.naturalWidth > 0 && imageElement.naturalHeight > 0) {
                        const imageAspectRatio = imageElement.naturalWidth / imageElement.naturalHeight;
                        const containerAspectRatio = containerWidth / containerHeight;
                        let renderedImageHeight;
                        if (imageAspectRatio > containerAspectRatio) {
                            renderedImageHeight = containerWidth / imageAspectRatio;
                        } else {
                            renderedImageHeight = containerHeight;
                        }
                        const verticalOffset = (containerHeight - renderedImageHeight) / 2;
                        const imageUrl = imageElement.currentSrc || imageElement.src || '';
                        const contentBottomRatio = getSvgContentBottomRatio(imageUrl) || 1;
                        const contentBottom = verticalOffset + renderedImageHeight * contentBottomRatio;
                        imageBottomY = elementInstance.y_position + 2 + contentBottom;
                    } else {
                        imageBottomY = elementInstance.y_position + elementInstance.height;
                    }
                }
                
                propertyY = imageBottomY + propertyGap + (index * (propertyHeight + propertyGap));
            }
            
            return {
                x: propertyX,
                y: propertyY,
                width: propertyWidth,
                height: propertyHeight
            };
        }
        
        // Create property instance on canvas
        function createPropertyInstance(propertyId, propertyData, elementInstanceId) {
            console.log('createPropertyInstance called', { propertyId, propertyData, elementInstanceId });
            saveStateForUndo();
            
            const elementInstance = canvasState.elements.find(e => e.id === elementInstanceId);
            if (!elementInstance) {
                console.error('Element instance not found:', elementInstanceId, 'Available:', canvasState.elements.map(e => e.id));
                alert('Element instance not found');
                return;
            }
            
            // Count existing properties for this element to calculate position
            const existingProperties = canvasState.propertyInstances.filter(
                p => p.element_instance_id === elementInstanceId
            );
            const position = calculatePropertyPosition(elementInstance, existingProperties.length);
            
            console.log('Calculated property position:', {
                elementPosition: { x: elementInstance.x_position, y: elementInstance.y_position },
                elementSize: { width: elementInstance.width, height: elementInstance.height },
                propertyPosition: position,
                existingPropertiesCount: existingProperties.length
            });
            
            const propertyInstance = {
                id: canvasState.nextPropertyInstanceId++,
                property_id: propertyId,
                element_instance_id: elementInstanceId,
                instance_name: propertyData.propertyname,
                x_position: position.x,
                y_position: position.y,
                isDropped: true, // Mark as dropped property (non-editable)
                width: position.width,
                height: position.height,
                propertyname: propertyData.propertyname,
                ragtype: propertyData.ragtype,
                image_url: propertyData.image_url
            };
            
            console.log('Creating property instance:', propertyInstance);
            canvasState.propertyInstances.push(propertyInstance);
            
            // Render the new property instance first
            renderPropertyInstance(propertyInstance);
            
            // Then update positions for all properties on this element (to ensure proper stacking)
            updatePropertyPositionsForElement(elementInstanceId);
            
            updateUndoRedoButtons();
        }
        
        // Render property instance on canvas
        function renderPropertyInstance(propertyInstance) {
            const layer = document.getElementById('propertyInstancesLayer');
            if (!layer) {
                console.error('Property instances layer not found!');
                return;
            }
            
            // Check if property already exists (avoid duplicates)
            const existingDiv = document.getElementById(`property-${propertyInstance.id}`);
            if (existingDiv) {
                console.log('Property already rendered, updating position');
                existingDiv.style.left = `${propertyInstance.x_position}px`;
                existingDiv.style.top = `${propertyInstance.y_position}px`;
                existingDiv.style.width = `${propertyInstance.width}px`;
                return;
            }
            
            const propertyDiv = document.createElement('div');
            propertyDiv.id = `property-${propertyInstance.id}`;
            propertyDiv.className = 'canvas-property';
            propertyDiv.dataset.elementInstanceId = propertyInstance.element_instance_id;
            propertyDiv.dataset.source = propertyInstance.source || '';
            
            let propertyX = propertyInstance.x_position;
            let propertyY = propertyInstance.y_position;
            const elementInstance = canvasState.elements.find(e => e.id === propertyInstance.element_instance_id);
            if (elementInstance) {
                const ruleCount = document.querySelectorAll(
                    `.canvas-property[data-element-instance-id="${propertyInstance.element_instance_id}"][data-source="rules_engine"]`
                ).length;
                const manualCount = document.querySelectorAll(
                    `.canvas-property[data-element-instance-id="${propertyInstance.element_instance_id}"]:not([data-source="rules_engine"])`
                ).length;
                const positionIndex = propertyInstance.source === 'rules_engine'
                    ? ruleCount
                    : ruleCount + manualCount;
                const position = calculatePropertyPosition(elementInstance, positionIndex);
                propertyX = position.x;
                propertyY = position.y;
                propertyInstance.x_position = propertyX;
                propertyInstance.y_position = propertyY;
                propertyInstance.width = position.width;
                propertyInstance.height = position.height;
            }
            
            propertyDiv.style.cssText = `
                position: absolute;
                left: ${propertyX}px;
                top: ${propertyY}px;
                width: ${propertyInstance.width}px;
                height: ${propertyInstance.height}px;
                cursor: move;
                user-select: none;
                z-index: 3;
                pointer-events: auto;
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            `;
            
            // Helper function to get tag image from RAG type
            function getTagImageFromRAG(ragType) {
                if (!ragType) return '/images/Tag-Green.svg';
                
                const ragTypeLower = ragType.toLowerCase().trim();
                const ragTypeMap = {
                    'green': 'Green',
                    'positive': 'Green',
                    'red': 'Red',
                    'negative': 'Red',
                    'yellow': 'Yellow',
                    'amber': 'Yellow',
                    'warning': 'Yellow',
                    'black': 'Black'
                };
                
                const imageRagType = ragTypeMap[ragTypeLower] || (ragType.charAt(0).toUpperCase() + ragType.slice(1).toLowerCase());
                return `/images/Tag-${imageRagType}.svg`;
            }
            
            // Get image URL - ensure it's a full path
            let imageUrl = propertyInstance.image_url;
            // If image_url is not a proper path (doesn't start with /images/), use RAG type to determine image
            if (!imageUrl || !imageUrl.startsWith('/images/')) {
                imageUrl = getTagImageFromRAG(propertyInstance.ragtype);
            }
            
            // Determine text color based on RAG type
            // Green, Red, and Yellow RAG types display black text
            // Black RAG type displays white text
            const ragType = (propertyInstance.ragtype || '').toLowerCase().trim();
            let textColor = '#ffffff'; // Default to white
            
            // Check for Black RAG type (should have white text)
            if (ragType === 'black' || ragType.startsWith('black')) {
                textColor = '#ffffff';
            }
            // Check for Green/Positive RAG types (should have black text)
            else if (ragType === 'green' || ragType === 'positive' || ragType.startsWith('green') || ragType.startsWith('positive')) {
                textColor = '#000000';
            }
            // Check for Red/Negative RAG types (should have black text)
            else if (ragType === 'red' || ragType === 'negative' || ragType.startsWith('red') || ragType.startsWith('negative')) {
                textColor = '#000000';
            }
            // Check for Yellow/Warning/Amber RAG types (should have black text)
            else if (ragType === 'yellow' || ragType === 'amber' || ragType === 'warning' || 
                     ragType.startsWith('yellow') || ragType.startsWith('amber') || ragType.startsWith('warning')) {
                textColor = '#000000';
            }
            
            console.log('Property RAG type:', ragType, 'Text color:', textColor);
            
            // Escape HTML to prevent XSS and ensure proper URL formatting
            const escapedImageUrl = escapeHtml(imageUrl);
            const escapedRagType = escapeHtml(propertyInstance.ragtype || 'Property');
            
            const gearOverlay = propertyInstance.source === 'rules_engine'
                ? '<div style="position: absolute; top: 3px; right: 3px; width: 16px; height: 16px; background: #ffffff; color: #000000; border-radius: 50%; font-size: 12px; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 2px rgba(0,0,0,0.4);" title="Rules Engine">&#9881;</div>'
                : '';
            
            propertyDiv.innerHTML = `
                <div style="position: relative; width: 100%; height: 100%; margin: 0; padding: 0;">
                    <img id="property-image-${propertyInstance.id}"
                         src="${escapedImageUrl}" 
                         alt="${escapedRagType}" 
                         style="width: 100%; height: 100%; object-fit: contain; display: block; margin: 0; padding: 0;"
                         onerror="if (this.src !== '/images/Tag-Green.svg') { this.src='/images/Tag-Green.svg'; this.onerror=null; }">
                    ${gearOverlay}
                    <div id="property-label-${propertyInstance.id}" 
                         class="property-name-label"
                         style="position: absolute; 
                                top: 50%; 
                                left: 50%; 
                                transform: translate(-50%, -50%);
                                color: ${textColor}; 
                                font-size: 12px; 
                                font-weight: 600;
                                text-align: center; 
                                cursor: ${propertyInstance.isDropped ? 'default' : 'text'};
                                pointer-events: auto;
                                max-width: 90%;
                                word-wrap: break-word;
                                line-height: 1.1;">
                        ${escapeHtml(propertyInstance.instance_name)}
                    </div>
                    <input type="text" 
                           id="property-input-${propertyInstance.id}"
                           class="property-name-input"
                           value="${escapeHtml(propertyInstance.instance_name)}"
                           style="position: absolute;
                                  top: 50%;
                                  left: 50%;
                                  transform: translate(-50%, -50%);
                                  display: none;
                                  background: rgba(0,0,0,0.9);
                                  border: 2px solid #667eea;
                                  padding: 2px 4px;
                                  border-radius: 4px;
                                  text-align: center;
                                  font-size: 12px;
                                  font-weight: 600;
                                  color: #ffffff;
                                  cursor: text;
                                  width: 90%;
                                  z-index: 10;">
                </div>
            `;
            
            setupPropertyInstanceEvents(propertyDiv, propertyInstance);
            layer.appendChild(propertyDiv);
        }
        
        // Setup event listeners for property instance
        function setupPropertyInstanceEvents(propertyDiv, propertyInstance) {
            // Query elements from propertyDiv instead of document to ensure they exist
            const label = propertyDiv.querySelector(`#property-label-${propertyInstance.id}`);
            const input = propertyDiv.querySelector(`#property-input-${propertyInstance.id}`);
            const propertyImage = propertyDiv.querySelector(`#property-image-${propertyInstance.id}`);
            const innerDiv = propertyDiv.querySelector('div');
            
            if (!label || !input) {
                console.error('Property label or input not found for property:', propertyInstance.id);
                return;
            }
            
            // Context menu handler - attach to propertyDiv and all child elements
            const handleContextMenu = (e) => {
                console.log('Property contextmenu event fired', propertyInstance.id, 'target:', e.target);
                e.preventDefault();
                e.stopPropagation();
                showPropertyContextMenu(e, propertyInstance.id);
            };
            
            // Add context menu to property div
            propertyDiv.addEventListener('contextmenu', handleContextMenu, true);
            
            // Add context menu to inner div
            if (innerDiv) {
                innerDiv.addEventListener('contextmenu', handleContextMenu, true);
            }
            
            // Add context menu to image
            if (propertyImage) {
                propertyImage.addEventListener('contextmenu', handleContextMenu, true);
            }
            
            // Add context menu to label (but allow editing on left-click)
            label.addEventListener('contextmenu', handleContextMenu, true);
            
            // Only make editable if property was not dropped (dropped properties are read-only)
            if (!propertyInstance.isDropped) {
                // Click to edit (only on left-click)
                label.addEventListener('click', (e) => {
                    if (e.button === 0) { // Only left-click
                        e.stopPropagation();
                        startEditingProperty(propertyInstance.id);
                    }
                });
                
                // Double-click to edit
                label.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    startEditingProperty(propertyInstance.id);
                });
            } else {
                // Dropped properties: change cursor to default (not text cursor)
                label.style.cursor = 'default';
            }
            
            // Input handlers
            input.addEventListener('blur', () => {
                finishEditingProperty(propertyInstance.id);
            });
            
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishEditingProperty(propertyInstance.id);
                }
            });
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    cancelEditingProperty(propertyInstance.id);
                }
            });
            
            // Dragging - use temporary listeners like element dragging
            let isDraggingProperty = false;
            let dragStart = { x: 0, y: 0 };
            let startX = null, startY = null;
            
            const handlePropertyMouseMove = (e) => {
                if (!isDraggingProperty || startX === null || startY === null) return;
                
                const container = document.getElementById('canvasContainer');
                const rect = container.getBoundingClientRect();
                const deltaX = (e.clientX - startX) / canvasState.zoom;
                const deltaY = (e.clientY - startY) / canvasState.zoom;
                
                propertyInstance.x_position = dragStart.x + deltaX;
                propertyInstance.y_position = dragStart.y + deltaY;
                propertyDiv.style.left = `${propertyInstance.x_position}px`;
                propertyDiv.style.top = `${propertyInstance.y_position}px`;
            };
            
            const handlePropertyMouseUp = () => {
                if (isDraggingProperty) {
                    isDraggingProperty = false;
                    propertyDiv.style.cursor = 'move';
                }
                startX = null;
                startY = null;
                // Remove temporary listeners
                document.removeEventListener('mousemove', handlePropertyMouseMove);
                document.removeEventListener('mouseup', handlePropertyMouseUp);
            };
            
            propertyDiv.addEventListener('mousedown', (e) => {
                // Don't drag when clicking on label/input/image
                if (e.target === label || e.target === input || e.target === propertyImage || e.target.tagName === 'IMG') {
                    return;
                }
                // Don't interfere with right-click
                if (e.button === 2) {
                    return;
                }
                
                e.stopPropagation(); // Prevent element selection
                isDraggingProperty = true;
                startX = e.clientX;
                startY = e.clientY;
                dragStart.x = propertyInstance.x_position;
                dragStart.y = propertyInstance.y_position;
                propertyDiv.style.cursor = 'grabbing';
                
                // Add temporary listeners for this drag operation
                document.addEventListener('mousemove', handlePropertyMouseMove);
                document.addEventListener('mouseup', handlePropertyMouseUp);
            });
        }
        
        // Start editing property name
        function startEditingProperty(propertyInstanceId) {
            const propertyInstance = canvasState.propertyInstances.find(p => p.id === propertyInstanceId);
            if (!propertyInstance) return;
            
            const label = document.getElementById(`property-label-${propertyInstanceId}`);
            const input = document.getElementById(`property-input-${propertyInstanceId}`);
            
            if (label && input) {
                label.style.display = 'none';
                input.style.display = 'block';
                input.focus();
                input.select();
            }
        }
        
        // Finish editing property name
        function finishEditingProperty(propertyInstanceId) {
            const propertyInstance = canvasState.propertyInstances.find(p => p.id === propertyInstanceId);
            if (!propertyInstance) return;
            
            const label = document.getElementById(`property-label-${propertyInstanceId}`);
            const input = document.getElementById(`property-input-${propertyInstanceId}`);
            
            if (label && input) {
                const newName = input.value.trim() || propertyInstance.propertyname;
                const oldName = propertyInstance.instance_name;
                
                // Only save undo state if name actually changed
                if (newName !== oldName) {
                    saveStateForUndo();
                }
                
                propertyInstance.instance_name = newName;
                label.textContent = escapeHtml(newName);
                
                // Update text color based on RAG type to ensure it's correct
                const ragType = (propertyInstance.ragtype || '').toLowerCase().trim();
                let textColor = '#ffffff'; // Default to white
                
                // Check for Black RAG type (should have white text)
                if (ragType === 'black' || ragType.startsWith('black')) {
                    textColor = '#ffffff';
                }
                // Check for Green/Positive RAG types (should have black text)
                else if (ragType === 'green' || ragType === 'positive' || ragType.startsWith('green') || ragType.startsWith('positive')) {
                    textColor = '#000000';
                }
                // Check for Red/Negative RAG types (should have black text)
                else if (ragType === 'red' || ragType === 'negative' || ragType.startsWith('red') || ragType.startsWith('negative')) {
                    textColor = '#000000';
                }
                // Check for Yellow/Warning/Amber RAG types (should have black text)
                else if (ragType === 'yellow' || ragType === 'amber' || ragType === 'warning' || 
                         ragType.startsWith('yellow') || ragType.startsWith('amber') || ragType.startsWith('warning')) {
                    textColor = '#000000';
                }
                
                label.style.color = textColor;
                label.style.display = 'block';
                input.style.display = 'none';
                
                // Update in database if saved
                if (propertyInstance.id > 1000) {
                    fetch(`/api/canvas/property-instances/${propertyInstance.id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ instance_name: newName })
                    }).catch(err => console.error('Error updating property:', err));
                }
                
                updateUndoRedoButtons();
            }
        }
        
        // Cancel editing property name
        function cancelEditingProperty(propertyInstanceId) {
            const propertyInstance = canvasState.propertyInstances.find(p => p.id === propertyInstanceId);
            if (!propertyInstance) return;
            
            const label = document.getElementById(`property-label-${propertyInstanceId}`);
            const input = document.getElementById(`property-input-${propertyInstanceId}`);
            
            if (label && input) {
                input.value = propertyInstance.instance_name;
                label.style.display = 'block';
                input.style.display = 'none';
            }
        }
        
        // Show property context menu
        function showPropertyContextMenu(e, propertyInstanceId) {
            console.log('showPropertyContextMenu called', propertyInstanceId, 'event:', e);
            
            // Prevent default browser context menu
            e.preventDefault();
            e.stopPropagation();
            
            // Remove any existing property context menu (check both body and canvasSection)
            const existingMenu = document.getElementById('propertyContextMenu');
            if (existingMenu) {
                const canvasSection = document.getElementById('modelingCanvas');
                if (document.body.contains(existingMenu)) {
                    document.body.removeChild(existingMenu);
                } else if (canvasSection && canvasSection.contains(existingMenu)) {
                    canvasSection.removeChild(existingMenu);
                }
            }
            
            const menu = document.createElement('div');
            menu.id = 'propertyContextMenu';
            const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] ? e.touches[0].clientX : window.innerWidth / 2);
            const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] ? e.touches[0].clientY : window.innerHeight / 2);
            
            // Check if we're in fullscreen mode and append to the correct container
            const canvasSection = document.getElementById('modelingCanvas');
            const appendTo = (canvasState.isFullscreen && canvasSection) ? canvasSection : document.body;
            
            menu.style.cssText = `
                position: fixed;
                left: ${clientX}px;
                top: ${clientY}px;
                background: #1a1a1a;
                border: 1px solid #808080;
                border-radius: 4px;
                padding: 2px 0;
                min-width: 120px;
                z-index: ${canvasState.isFullscreen ? '10010' : '10005'};
                box-shadow: 0 4px 12px rgba(0,0,0,0.4);
                pointer-events: auto;
                display: block;
                visibility: visible;
                opacity: 1;
            `;
            
            // Helper function to close the menu
            const closePropertyContextMenu = () => {
                console.log('closePropertyContextMenu called');
                const canvasSection = document.getElementById('modelingCanvas');
                
                // Try to find and remove the menu from any location
                const menuToRemove = document.getElementById('propertyContextMenu');
                if (menuToRemove) {
                    // Check if menu has a parent before trying to remove
                    if (menuToRemove.parentNode) {
                        try {
                            console.log('Removing menu from parentNode:', menuToRemove.parentNode.nodeName);
                            // Use parentNode.removeChild - it will throw if not actually a child
                            menuToRemove.parentNode.removeChild(menuToRemove);
                        } catch (e) {
                            console.log('Error removing menu from parentNode:', e.message);
                            // If removeChild fails, try the modern remove() method
                            try {
                                menuToRemove.remove();
                            } catch (e2) {
                                console.log('Alternative removal also failed:', e2.message);
                            }
                        }
                    } else {
                        console.log('Menu has no parentNode - already removed or not in DOM');
                        // Try remove() method directly
                        try {
                            menuToRemove.remove();
                        } catch (e) {
                            console.log('Direct remove() failed:', e.message);
                        }
                    }
                } else {
                    console.log('Menu element not found in DOM');
                }
                
                // Clean up the close handler
                if (menuRef.closeMenuHandler) {
                    document.removeEventListener('click', menuRef.closeMenuHandler, true);
                    menuRef.closeMenuHandler = null;
                }
            };
            
            // Delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'Delete';
            deleteBtn.style.cssText = `
                width: 100%;
                padding: 6px 10px;
                background: transparent;
                border: none;
                color: #c0c0c0;
                text-align: left;
                cursor: pointer;
                font-size: 11px;
                transition: background 0.2s;
                outline: none;
                box-shadow: none;
                border-radius: 0;
            `;
            deleteBtn.addEventListener('mouseenter', () => {
                deleteBtn.style.background = '#3e3e3e';
                deleteBtn.style.boxShadow = 'none';
            });
            deleteBtn.addEventListener('mouseleave', () => {
                deleteBtn.style.background = 'transparent';
                deleteBtn.style.boxShadow = 'none';
            });
            deleteBtn.addEventListener('focus', () => {
                deleteBtn.style.outline = 'none';
                deleteBtn.style.boxShadow = 'none';
                deleteBtn.style.background = '#3e3e3e';
            });
            deleteBtn.addEventListener('mousedown', () => {
                deleteBtn.style.outline = 'none';
                deleteBtn.style.boxShadow = 'none';
                deleteBtn.style.background = '#505050';
            });
            deleteBtn.addEventListener('click', (evt) => {
                evt.preventDefault();
                evt.stopPropagation();
                console.log('Delete property clicked', propertyInstanceId);
                deletePropertyInstance(propertyInstanceId);
                closePropertyContextMenu();
            });
            
            menu.appendChild(deleteBtn);
            appendTo.appendChild(menu);
            
            // Force a reflow to ensure the menu is rendered
            menu.offsetHeight;
            
            console.log('Property context menu created and appended', {
                menu: menu,
                position: { x: clientX, y: clientY },
                computedStyle: window.getComputedStyle(menu),
                isInBody: document.body.contains(menu),
                offsetHeight: menu.offsetHeight,
                offsetWidth: menu.offsetWidth
            });
            
            // Hide other context menus
            const elementMenu = document.getElementById('elementContextMenu');
            if (elementMenu) {
                elementMenu.style.display = 'none';
            }
            const relationshipMenu = document.getElementById('relationshipContextMenu');
            if (relationshipMenu) {
                relationshipMenu.style.display = 'none';
            }
            
            // Close menu when clicking elsewhere - use requestAnimationFrame to ensure menu is rendered
            const menuCreationTime = Date.now();
            let closeMenuHandler = null;
            
            // Store reference to closeMenuHandler so closePropertyContextMenu can access it
            const menuRef = { closeMenuHandler: null };
            
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    // Double RAF ensures the menu is fully rendered
                    closeMenuHandler = (evt) => {
                        menuRef.closeMenuHandler = closeMenuHandler;
                        // Ignore events that happen too soon after menu creation (within 600ms)
                        const timeSinceCreation = Date.now() - menuCreationTime;
                        if (timeSinceCreation < 600) {
                            console.log('Ignoring event too soon after menu creation:', evt.type, timeSinceCreation, 'ms');
                            return;
                        }
                        
                        // Don't close if clicking on the menu itself
                        if (menu.contains(evt.target)) {
                            console.log('Click on menu itself - not closing');
                            return;
                        }
                        
                        // Only close on click events, not contextmenu events
                        // (contextmenu events might fire multiple times from different elements)
                        if (evt.type === 'click') {
                            // Use the helper function to close the menu (it handles cleanup)
                            closePropertyContextMenu();
                        }
                    };
                    
                    // Only listen for click events - don't listen for contextmenu events
                    // Add listener with a delay to avoid catching immediate events
                    setTimeout(() => {
                        menuRef.closeMenuHandler = closeMenuHandler;
                        document.addEventListener('click', closeMenuHandler, true);
                    }, 600);
                });
            });
        }
        
        // Delete property instance
        function deletePropertyInstance(propertyInstanceId) {
            const index = canvasState.propertyInstances.findIndex(p => p.id === propertyInstanceId);
            if (index === -1) return;
            
            const propertyInstance = canvasState.propertyInstances[index];
            
            // Save state BEFORE deletion
            saveStateForUndo();
            
            // Remove from DOM
            const propertyDiv = document.getElementById(`property-${propertyInstanceId}`);
            if (propertyDiv) propertyDiv.remove();
            
            // Remove from state
            canvasState.propertyInstances.splice(index, 1);
            
            // Delete from database if saved
            if (propertyInstance.id > 1000) {
                fetch(`/api/canvas/property-instances/${propertyInstance.id}`, {
                    method: 'DELETE'
                }).catch(err => console.error('Error deleting property:', err));
            }
            
            // Update positions of remaining properties for the same element
            updatePropertyPositionsForElement(propertyInstance.element_instance_id);
            updateUndoRedoButtons();
        }
        
        // Update property positions for an element instance
        function updatePropertyPositionsForElement(elementInstanceId) {
            const elementInstance = canvasState.elements.find(e => e.id === elementInstanceId);
            if (!elementInstance) return;
            
            const properties = canvasState.propertyInstances.filter(
                p => p.element_instance_id === elementInstanceId
            );
            
            properties.forEach((prop, index) => {
                const position = calculatePropertyPosition(elementInstance, index);
                prop.x_position = position.x;
                prop.y_position = position.y;
                prop.width = position.width;
                
                // Update DOM
                const propDiv = document.getElementById(`property-${prop.id}`);
                if (propDiv) {
                    propDiv.style.left = `${position.x}px`;
                    propDiv.style.top = `${position.y}px`;
                    propDiv.style.width = `${position.width}px`;
                    
                // Update text color based on RAG type
                    const label = propDiv.querySelector(`#property-label-${prop.id}`);
                    if (label) {
                        const ragType = (prop.ragtype || '').toLowerCase().trim();
                        let textColor = '#ffffff';
                    if (ragType === 'negative' || ragType === 'red' || ragType.startsWith('negative') || ragType.startsWith('red')) {
                        textColor = '#ffffff';
                    } else if (ragType === 'green' || ragType === 'positive' || ragType.startsWith('green') || ragType.startsWith('positive')) {
                        textColor = '#000000';
                    } else if (ragType === 'yellow' || ragType === 'amber' || ragType === 'warning' || 
                                 ragType.startsWith('yellow') || ragType.startsWith('amber') || ragType.startsWith('warning')) {
                        textColor = '#000000';
                        }
                        label.style.color = textColor;
                        label.style.fontSize = '12px';
                    }
                }
            });
        }
        
        // Get label color for People element based on theme
        function getPeopleLabelColor() {
            return canvasState.theme === 'dark' ? '#ffffff' : '#000000';
        }
        
        // Render element on canvas
        function renderElement(element) {
            const layer = document.getElementById('elementsLayer');
            
            // Check if this is a People element
            const isPeople = element.element_type && element.element_type.toLowerCase() === 'people';
            
            const elementDiv = document.createElement('div');
            elementDiv.id = `element-${element.id}`;
            elementDiv.className = 'canvas-element';
            elementDiv.style.cssText = `
                pointer-events: auto;
                position: absolute;
                left: ${element.x_position}px;
                top: ${element.y_position}px;
                width: ${element.width}px;
                height: ${element.height}px;
                cursor: move;
                user-select: none;
                padding: 0;
                margin: 0;
            `;
            
            // Different layout for People elements - label below element
            if (isPeople) {
                const labelColor = getPeopleLabelColor();
                // Use theme-based image for People elements
                const peopleImage = canvasState.theme === 'dark' 
                    ? '/images/dark-people-element.svg' 
                    : '/images/light-people-element.svg';
                const shadowStyle = canvasState.elementShadowsEnabled ? 'filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));' : '';
                elementDiv.innerHTML = `
                    <div style="position: relative; width: 100%; height: 100%; border: 2px solid transparent; border-radius: 4px; transition: border-color 0.2s; padding: 0; margin: 0; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; box-sizing: border-box; ${shadowStyle}" id="element-border-${element.id}">
                        <img src="${peopleImage}" alt="${element.element_type}" 
                             style="width: 100%; height: 100%; object-fit: contain; pointer-events: none; flex-shrink: 0; display: block; margin: 0; padding: 0; vertical-align: top;"
                             id="element-image-${element.id}"
                             onload="ensureSvgInsetCached(this.currentSrc || this.src).then(() => updatePropertyPositionsForElement(${element.id}))"
                             onerror="this.src='${peopleImage}'; this.onerror=null; updatePropertyPositionsForElement(${element.id});">
                        <div id="element-label-${element.id}"
                             class="element-name-label"
                             style="position: relative;
                                    text-align: center;
                                    font-size: 12px;
                                    font-weight: 500;
                                    color: ${labelColor};
                                    pointer-events: auto;
                                    cursor: text;
                                    z-index: 10;
                                    max-width: 150px;
                                    word-wrap: break-word;
                                    line-height: 1.2;
                                    margin-top: 4px;
                                    width: 100%;
                                    display: flex;
                                    justify-content: center;
                                    align-items: center;">
                            ${escapeHtml(element.instance_name)}
                        </div>
                        <input type="text" 
                               id="element-input-${element.id}"
                               class="element-name-input" 
                               value="${escapeHtml(element.instance_name)}"
                               style="position: relative;
                                      background: rgba(0,0,0,0.8);
                                      border: 2px solid #667eea;
                                      padding: 4px 8px;
                                      border-radius: 4px;
                                      text-align: center;
                                      font-size: 12px;
                                      width: 90px;
                                      z-index: 11;
                                      pointer-events: auto;
                                      color: #ffffff;
                                      cursor: text;
                                      display: none;
                                      margin-top: 4px;
                                      margin-left: auto;
                                      margin-right: auto;"
                               onblur="finishEditingElement(${element.id}, this.value)"
                               onkeypress="if(event.key === 'Enter') { event.preventDefault(); finishEditingElement(${element.id}, this.value); }"
                               onkeydown="if(event.key === 'Escape') { cancelEditingElement(${element.id}); }">
                    </div>
                `;
            } else {
                // Standard layout for other elements
                const shadowStyle = canvasState.elementShadowsEnabled ? 'filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));' : '';
                elementDiv.innerHTML = `
                    <div style="position: relative; width: 100%; height: 100%; border: 2px solid transparent; border-radius: 4px; transition: border-color 0.2s; padding: 0; margin: 0; box-sizing: border-box; ${shadowStyle}" id="element-border-${element.id}">
                        <img src="${element.image_url}" alt="${element.element_type}" 
                             style="width: 100%; height: 100%; object-fit: contain; pointer-events: none; display: block; margin: 0; padding: 0; vertical-align: top;"
                             id="element-image-${element.id}"
                             onload="ensureSvgInsetCached(this.currentSrc || this.src).then(() => updatePropertyPositionsForElement(${element.id}))"
                             onerror="this.src='/images/Shape-${element.element_type}.svg'; this.onerror=null; updatePropertyPositionsForElement(${element.id});">
                        <div id="element-label-${element.id}"
                             class="element-name-label"
                             style="position: absolute; 
                                    top: 50%; 
                                    left: 50%; 
                                    transform: translate(-50%, -50%);
                                    text-align: center;
                                    font-size: 12px;
                                    font-weight: 500;
                                    color: #000000;
                                    pointer-events: auto;
                                    cursor: text;
                                    z-index: 10;
                                    max-width: 100px;
                                    word-wrap: break-word;
                                    line-height: 1.2;">
                            ${escapeHtml(element.instance_name)}
                        </div>
                        <input type="text" 
                               id="element-input-${element.id}"
                               class="element-name-input" 
                               value="${escapeHtml(element.instance_name)}"
                               style="position: absolute; 
                                      top: 50%; 
                                      left: 50%; 
                                      transform: translate(-50%, -50%);
                                      background: rgba(0,0,0,0.8);
                                      border: 2px solid #667eea;
                                      padding: 4px 8px;
                                      border-radius: 4px;
                                      text-align: center;
                                      font-size: 12px;
                                      width: 90px;
                                      z-index: 11;
                                      pointer-events: auto;
                                      color: #ffffff;
                                      cursor: text;
                                      display: none;"
                               onblur="finishEditingElement(${element.id}, this.value)"
                               onkeypress="if(event.key === 'Enter') { event.preventDefault(); finishEditingElement(${element.id}, this.value); }"
                               onkeydown="if(event.key === 'Escape') { cancelEditingElement(${element.id}); }">
                    </div>
                `;
            }
            
            // Make draggable FIRST (before other handlers) - this sets up wasDragged variable
            const dragState = makeElementDraggable(elementDiv, element);
            
            // Add click handler for selection and relationship creation
            elementDiv.addEventListener('click', (e) => {
                console.log('Element click event:', { 
                    elementId: element.id, 
                    target: e.target.className,
                    wasDragged: dragState.wasDragged,
                    isDragging: elementDiv.dataset.isDragging
                });
                
                // Don't handle clicks on input fields
                if (e.target.classList.contains('element-name-input')) return;
                // Click on label should start editing
                if (e.target.classList.contains('element-name-label')) {
                    e.stopPropagation();
                    startEditingElement(element.id);
                    return;
                }
                
                // Check if element was actually dragged (not just clicked)
                // Only block click if element was actually dragged (moved > 5px)
                // The wasDragged flag is only set to true when actual dragging occurs
                const wasActuallyDragged = dragState.wasDragged === true;
                
                if (wasActuallyDragged) {
                    console.log('Element was dragged - ignoring click', { 
                        wasDragged: dragState.wasDragged, 
                        isDragging: elementDiv.dataset.isDragging 
                    });
                    // Clear flags for next interaction
                    dragState.wasDragged = false;
                    dragState.mouseDownTime = null;
                    elementDiv.dataset.isDragging = 'false';
                    return;
                }
                
                console.log('Processing click for relationship selection', { 
                    wasDragged: dragState.wasDragged, 
                    isDragging: elementDiv.dataset.isDragging,
                    elementId: element.id
                });
                e.stopPropagation();
                e.preventDefault();
                // Handle element selection for relationship creation
                console.log('About to call handleElementSelection with elementId:', element.id);
                try {
                    handleElementSelection(element.id);
                    console.log('handleElementSelection completed');
                } catch (error) {
                    console.error('Error in handleElementSelection:', error);
                }
            });
            
            // Add double-click handler to enable editing
            elementDiv.addEventListener('dblclick', (e) => {
                if (!e.target.classList.contains('element-name-input')) {
                    startEditingElement(element.id);
                }
            });
            
            // Add context menu handler - must be after makeElementDraggable
            elementDiv.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showContextMenu(e, element.id);
            });
            
            // Allow dragover for properties only when actually dragging
            elementDiv.addEventListener('dragover', (e) => {
                // Only handle if actually dragging something (types array has items)
                const types = Array.from(e.dataTransfer.types || []);
                // Check for property drag: has 'text/plain' and multiple types (propertyId, propertyname, etc.)
                if (types.length > 1 && types.includes('text/plain')) {
                    // Allow property drop
                    e.preventDefault();
                    e.stopPropagation();
                    e.dataTransfer.dropEffect = 'copy';
                }
                // Don't prevent default for non-drag events - let normal mouse events work
            });
            
            // Handle property drops on element
            elementDiv.addEventListener('drop', (e) => {
                const types = Array.from(e.dataTransfer.types || []);
                console.log('Element drop event', types);
                
                // Check if this is a property drop by checking types (has text/plain + other types)
                const isPropertyDrop = types.length > 1 && types.includes('text/plain');
                
                if (isPropertyDrop) {
                    // Get all data at once before any other handlers consume it
                    const propertyId = e.dataTransfer.getData('propertyId');
                    const propertyname = e.dataTransfer.getData('propertyname');
                    const ragtype = e.dataTransfer.getData('ragtype');
                    const imageUrl = e.dataTransfer.getData('imageUrl');
                    
                    console.log('Property drop data:', { propertyId, propertyname, ragtype, imageUrl });
                    
                    if (propertyId) {
                e.preventDefault();
                e.stopPropagation();
                        const elementId = parseInt(elementDiv.id.replace('element-', ''));
                        
                        console.log('Creating property on element:', { elementId, propertyname, ragtype, imageUrl });
                        createPropertyInstance(parseInt(propertyId), {
                            propertyname: propertyname || 'Property',
                            ragtype: ragtype || '',
                            image_url: imageUrl || ''
                        }, elementId);
                    }
                } else {
                    // Not a property drop, prevent default to avoid canvas drop
                e.preventDefault();
                e.stopPropagation();
                }
            });
            
            layer.appendChild(elementDiv);
        }
        
        // Make element draggable
        function makeElementDraggable(elementDiv, element) {
            let isDragging = false;
            let hasMoved = false;
            let hasSavedUndoState = false; // Track if we've saved undo state for this drag
            const dragState = { 
                wasDragged: false, // Track if element was actually dragged (not just clicked)
                mouseDownTime: null // Track when mousedown occurred
            }; 
            let startX = null, startY = null, startLeft, startTop;
            
            const handleMouseDown = (e) => {
                console.log('Element mousedown:', { target: e.target, button: e.button, elementId: element.id });
                // Don't start dragging if clicking on input or label
                if (e.target.classList.contains('element-name-input') || e.target.classList.contains('element-name-label')) {
                    console.log('Clicked on input/label - not starting drag');
                    return false; // Signal not to add listeners
                }
                // Don't interfere with right-click (context menu)
                if (e.button === 2) {
                    console.log('Right-click - not starting drag');
                    return false; // Signal not to add listeners
                }
                e.stopPropagation(); // Prevent container mousedown handler
                // Don't preventDefault here - let the browser handle it initially
                // We'll preventDefault in mousemove once drag threshold is met
                hasMoved = false;
                isDragging = false;
                dragState.wasDragged = false; // Reset drag flag
                dragState.mouseDownTime = Date.now(); // Record mousedown time
                elementDiv.dataset.isDragging = 'false';
                startX = e.clientX;
                startY = e.clientY;
                startLeft = element.x_position;
                startTop = element.y_position;
                console.log('Drag started:', { startX, startY, startLeft, startTop });
                return true; // Signal to add listeners
            };
            
            const handleMouseMove = (e) => {
                if (startX === null || startY === null) {
                    console.log('Mouse move but no start position');
                    return;
                }
                
                const deltaX = Math.abs(e.clientX - startX);
                const deltaY = Math.abs(e.clientY - startY);
                
                // Only start dragging if mouse moved more than 5 pixels
                if (deltaX > 5 || deltaY > 5) {
                    if (!isDragging) {
                        console.log('Starting drag:', { deltaX, deltaY });
                        // Save undo state when drag starts (only once per drag operation)
                        if (!hasSavedUndoState) {
                            saveStateForUndo();
                            hasSavedUndoState = true;
                        }
                        isDragging = true;
                        isAnyElementDragging = true;
                        hasMoved = true;
                        dragState.wasDragged = true; // Mark that element was actually dragged
                        elementDiv.dataset.isDragging = 'true';
                        // Now prevent default to stop text selection during drag
                        e.preventDefault();
                        elementDiv.style.zIndex = '1000';
                        elementDiv.style.cursor = 'grabbing';
                    }
                    
                    const moveDeltaX = (e.clientX - startX) / canvasState.zoom;
                    const moveDeltaY = (e.clientY - startY) / canvasState.zoom;
                    // Snap to grid during drag using center-based alignment
                    let snappedPos = snapElementToGrid(startLeft + moveDeltaX, startTop + moveDeltaY, element.width, element.height);
                    
                    // Apply snap-to-element if snap guides are enabled
                    if (canvasState.snapGuidesEnabled) {
                        const tempElement = {
                            ...element,
                            x_position: snappedPos.x,
                            y_position: snappedPos.y
                        };
                        const snappedToElements = snapToElements(tempElement, canvasState.elements);
                        snappedPos.x = snappedToElements.x_position;
                        snappedPos.y = snappedToElements.y_position;
                        
                        // Draw snap guides
                        const snapLines = findSnapLines(snappedToElements, canvasState.elements);
                        drawSnapGuides(snapLines);
                    } else {
                        clearSnapGuides();
                    }
                    
                    element.x_position = snappedPos.x;
                    element.y_position = snappedPos.y;
                    
                    // Update segment association if element is moved on Milkyway template
                    if (canvasState.canvasTemplate === 'milkyway-map' && canvasState.templateSegments && canvasState.templateSegments.length > 0) {
                        const segmentIndex = getSegmentForPosition(snappedPos.x, snappedPos.y);
                        if (segmentIndex !== null) {
                            // Update association if segment changed
                            const currentSegment = canvasState.elementSegmentAssociations[element.id];
                            if (currentSegment !== segmentIndex) {
                                associateElementWithSegment(element.id, segmentIndex).catch(err => {
                                    console.error('Error updating segment association:', err);
                                });
                            }
                        } else {
                            // Element moved outside template area, remove association
                            if (canvasState.elementSegmentAssociations[element.id] !== undefined) {
                                delete canvasState.elementSegmentAssociations[element.id];
                            }
                        }
                    }
                    
                    // Batch DOM updates using requestAnimationFrame for smoother performance
                    if (!elementDiv._pendingUpdate) {
                        elementDiv._pendingUpdate = true;
                        requestAnimationFrame(() => {
                    elementDiv.style.left = `${element.x_position}px`;
                    elementDiv.style.top = `${element.y_position}px`;
                            // Update connections immediately during drag (no debounce for smooth real-time updates)
                    updateConnections();
                            // Update property positions
                            updatePropertyPositionsForElement(element.id);
                            elementDiv._pendingUpdate = false;
                        });
                    } else {
                        // Update position immediately for responsiveness, but batch other updates
                        elementDiv.style.left = `${element.x_position}px`;
                        elementDiv.style.top = `${element.y_position}px`;
                    }
                }
            };
            
            const handleMouseUp = (e) => {
                console.log('Mouse up:', { isDragging, wasDragged: dragState.wasDragged, hasMoved });
                
                if (isDragging) {
                    // Final snap to grid on mouseup using center-based alignment
                    let snappedPos = snapElementToGrid(element.x_position, element.y_position, element.width, element.height);
                    
                    // Apply snap-to-element if snap guides are enabled
                    if (canvasState.snapGuidesEnabled) {
                        const tempElement = {
                            ...element,
                            x_position: snappedPos.x,
                            y_position: snappedPos.y
                        };
                        const snappedToElements = snapToElements(tempElement, canvasState.elements);
                        snappedPos.x = snappedToElements.x_position;
                        snappedPos.y = snappedToElements.y_position;
                    }
                    
                    // Clear snap guides on drop
                    clearSnapGuides();
                    
                    element.x_position = snappedPos.x;
                    element.y_position = snappedPos.y;
                    elementDiv.style.left = `${element.x_position}px`;
                    elementDiv.style.top = `${element.y_position}px`;
                    
                    // Update segment association if element is moved on Milkyway template
                    if (canvasState.canvasTemplate === 'milkyway-map' && canvasState.templateSegments && canvasState.templateSegments.length > 0) {
                        const segmentIndex = getSegmentForPosition(snappedPos.x, snappedPos.y, element.width, element.height);
                        if (segmentIndex !== null) {
                            // Update association if segment changed
                            const currentSegment = canvasState.elementSegmentAssociations[element.id];
                            if (currentSegment !== segmentIndex) {
                                associateElementWithSegment(element.id, segmentIndex).catch(err => {
                                    console.error('Error updating segment association:', err);
                                });
                            }
                        } else {
                            // Element moved outside template area, remove association
                            if (canvasState.elementSegmentAssociations[element.id] !== undefined) {
                                delete canvasState.elementSegmentAssociations[element.id];
                            }
                        }
                    }
                    
                    // Update connections immediately on drop
                    updateConnections();
                    // Update property positions
                    updatePropertyPositionsForElement(element.id);
                    isAnyElementDragging = false;
                    isDragging = false;
                    elementDiv.style.zIndex = '2';
                    elementDiv.style.cursor = 'move';
                    // Keep wasDragged flag true - element was actually dragged
                    dragState.wasDragged = true;
                    elementDiv.dataset.isDragging = 'true';
                    // Clear flags after a delay to prevent click event
                    setTimeout(() => {
                        elementDiv.dataset.isDragging = 'false';
                        dragState.wasDragged = false;
                    }, 200);
                } else {
                    // Wasn't dragged - clear flags immediately to allow click
                    console.log('No drag detected - allowing click');
                    dragState.wasDragged = false;
                    dragState.mouseDownTime = null; // Clear timestamp
                    elementDiv.dataset.isDragging = 'false';
                }
                // Reset drag state
                startX = null;
                startY = null;
                hasMoved = false;
                hasSavedUndoState = false; // Reset undo state flag
                // Remove temporary listeners
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            };
            
            elementDiv.addEventListener('mousedown', (e) => {
                console.log('Element mousedown event:', { target: e.target, button: e.button, elementId: element.id });
                // Don't interfere with right-click (context menu) - let it bubble for contextmenu event
                if (e.button === 2) {
                    console.log('Right-click detected - allowing context menu');
                    return;
                }
                const shouldAddListeners = handleMouseDown(e);
                console.log('Should add listeners:', shouldAddListeners);
                if (shouldAddListeners) {
                    // Add temporary listeners for this drag operation
                    console.log('Adding mousemove and mouseup listeners');
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                }
            });
            
            // Return drag state so click handler can access wasDragged
            return dragState;
        }

        
        // Start editing element name
        function startEditingElement(elementId) {
            const input = document.getElementById(`element-input-${elementId}`);
            const label = document.getElementById(`element-label-${elementId}`);
            
            if (input && label) {
                label.style.display = 'none';
                input.style.display = 'block';
                input.focus();
                input.select();
            }
        }
        
        // Finish editing element name
        function finishEditingElement(elementId, newName) {
            const element = canvasState.elements.find(e => e.id === elementId);
            if (!element) return;
            
            const trimmedName = (newName || '').trim();
            const oldName = element.instance_name;
            const finalName = trimmedName || `${element.element_type} ${elementId}`;
            
            // Only save undo state if name actually changed
            if (finalName !== oldName) {
                saveStateForUndo();
            }
            
            element.instance_name = finalName;
            
            const input = document.getElementById(`element-input-${elementId}`);
            const label = document.getElementById(`element-label-${elementId}`);
            
            if (input && label) {
                input.value = element.instance_name;
                input.style.display = 'none';
                label.textContent = element.instance_name;
                // Set color based on theme for People elements, black for others
                const isPeople = element.element_type && element.element_type.toLowerCase() === 'people';
                label.style.color = isPeople ? getPeopleLabelColor() : '#000000';
                label.style.display = 'block';
                
                // For People elements, update property positions after label text changes
                // Use requestAnimationFrame to ensure label is rendered before measuring
                if (isPeople) {
                    requestAnimationFrame(() => {
                        updatePropertyPositionsForElement(elementId);
                    });
                }
            }
            
            updateUndoRedoButtons();
        }
        
        // Cancel editing element name
        function cancelEditingElement(elementId) {
            const element = canvasState.elements.find(e => e.id === elementId);
            if (!element) return;
            
            const input = document.getElementById(`element-input-${elementId}`);
            const label = document.getElementById(`element-label-${elementId}`);
            
            if (input && label) {
                input.value = element.instance_name;
                input.style.display = 'none';
                // Set color based on theme for People elements, black for others
                const isPeople = element.element_type && element.element_type.toLowerCase() === 'people';
                label.style.color = isPeople ? getPeopleLabelColor() : '#000000';
                label.style.display = 'block';
                input.blur();
            }
        }
        
        // Update element name (for compatibility)
        function updateElementName(elementId, newName) {
            finishEditingElement(elementId, newName);
        }
        
        // Auto-connect relationships
        function autoConnectRelationships(newElement) {
            canvasState.relationshipRules.forEach(rule => {
                // Check if new element matches source type
                if (newElement.element_type === rule.source_element_type) {
                    canvasState.elements.forEach(existing => {
                        if (existing.id !== newElement.id && 
                            existing.element_type === rule.target_element_type) {
                            createConnection(newElement.id, existing.id, rule.relationship_type);
                        }
                    });
                }
                // Check if new element matches target type
                if (newElement.element_type === rule.target_element_type) {
                    canvasState.elements.forEach(existing => {
                        if (existing.id !== newElement.id && 
                            existing.element_type === rule.source_element_type) {
                            createConnection(existing.id, newElement.id, rule.relationship_type);
                        }
                    });
                }
            });
        }
        
        // Create connection between elements
        function createConnection(sourceId, targetId, relationshipType) {
            // Check if connection already exists
            const exists = canvasState.relationships.some(r => 
                r.source_instance_id === sourceId && r.target_instance_id === targetId
            );
            if (exists) return;
            
            // Save undo state before creating connection
            saveStateForUndo();
            
            const connection = {
                source_instance_id: sourceId,
                target_instance_id: targetId,
                relationship_type: relationshipType
            };
            
            canvasState.relationships.push(connection);
            debouncedUpdateConnections();
            updateCanvasInfo();
            updateUndoRedoButtons();
        }
        
        // Update connection lines
        function updateConnections() {
            const svg = document.getElementById('connectionsLayer');
            const container = document.getElementById('canvasContainer');
            const containerRect = container.getBoundingClientRect();
            
            // Clear existing connections
            svg.innerHTML = '';
            
            canvasState.relationships.forEach((rel, index) => {
                const source = canvasState.elements.find(e => e.id === rel.source_instance_id);
                const target = canvasState.elements.find(e => e.id === rel.target_instance_id);
                
                if (!source || !target) return;
                
                // Calculate positions accounting for zoom and pan
                // Element positions are in canvas coordinates, need to transform to screen coordinates
                const sourceX = (source.x_position + source.width / 2) * canvasState.zoom + canvasState.panX;
                const sourceY = (source.y_position + source.height / 2) * canvasState.zoom + canvasState.panY;
                const targetX = (target.x_position + target.width / 2) * canvasState.zoom + canvasState.panX;
                const targetY = (target.y_position + target.height / 2) * canvasState.zoom + canvasState.panY;
                
                // Create connection path group for easier interaction
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('data-relationship-index', index);
                group.style.cursor = 'pointer';
                
                // Create invisible wider path for easier clicking
                const hitPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                hitPath.setAttribute('d', `M ${sourceX} ${sourceY} L ${targetX} ${targetY}`);
                hitPath.setAttribute('stroke', 'transparent');
                hitPath.setAttribute('stroke-width', '20');
                hitPath.setAttribute('fill', 'none');
                hitPath.setAttribute('pointer-events', 'all');
                hitPath.style.cursor = 'pointer';
                hitPath.addEventListener('contextmenu', (e) => {
                    console.log('Relationship contextmenu event fired', index);
                    e.preventDefault();
                    e.stopPropagation();
                    const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
                    const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
                    showRelationshipContextMenu({ clientX, clientY }, index);
                }, true);
                group.appendChild(hitPath);
                
                // Create visible connection path
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', `M ${sourceX} ${sourceY} L ${targetX} ${targetY}`);
                path.setAttribute('stroke', '#888');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                path.setAttribute('pointer-events', 'none');
                group.appendChild(path);
                
                // Add relationship type label
                const midX = (sourceX + targetX) / 2;
                const midY = (sourceY + targetY) / 2;
                const relType = rel.relationship_type || '';
                
                if (relType) {
                    // Estimate text width (approximately 6px per character for 11px font)
                    const estimatedWidth = relType.length * 6 + 8;
                    const estimatedHeight = 14;
                    
                    // Add background rectangle for better readability - match canvas background
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', midX - estimatedWidth / 2);
                    rect.setAttribute('y', midY - estimatedHeight / 2 - 2);
                    rect.setAttribute('width', estimatedWidth);
                    rect.setAttribute('height', estimatedHeight);
                    // Match canvas background color for both themes
                    if (canvasState.theme === 'dark') {
                        rect.setAttribute('fill', '#1a1a1a');  // Dark mode canvas background
                        rect.setAttribute('fill-opacity', '1');
                    } else {
                        rect.setAttribute('fill', '#f5f5f5');  // Light mode canvas background
                        rect.setAttribute('fill-opacity', '1');
                    }
                    rect.setAttribute('rx', '3');
                    rect.setAttribute('stroke', 'none');
                    rect.setAttribute('pointer-events', 'none');
                    group.appendChild(rect);
                    
                    // Add text label
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', midX);
                    text.setAttribute('y', midY + 3);
                    text.setAttribute('text-anchor', 'middle');
                    // Swapped: Dark theme = light text, Light theme = dark text
                    if (canvasState.theme === 'dark') {
                        text.setAttribute('fill', '#e0e0e0');
                    } else {
                        text.setAttribute('fill', '#000000');
                    }
                    text.setAttribute('font-size', '11px');
                    text.setAttribute('font-family', 'Arial, sans-serif');
                    text.setAttribute('pointer-events', 'none');
                    text.setAttribute('style', 'user-select: none;');
                    const textNode = document.createTextNode(relType);
                    text.appendChild(textNode);
                    group.appendChild(text);
                }
                
                svg.appendChild(group);
            });
        }
        
        // Update canvas transform
        function updateCanvasTransform() {
            const layer = document.getElementById('elementsLayer');
            const propertyLayer = document.getElementById('propertyInstancesLayer');
            const templateLayer = document.getElementById('templateLayer');
            
            // Update elements and properties with their own zoom/pan
            layer.style.transform = `translate(${canvasState.panX}px, ${canvasState.panY}px) scale(${canvasState.zoom})`;
            layer.style.transformOrigin = '0 0';
            if (propertyLayer) {
                propertyLayer.style.transform = `translate(${canvasState.panX}px, ${canvasState.panY}px) scale(${canvasState.zoom})`;
                propertyLayer.style.transformOrigin = '0 0';
            }
            // Update template layer with its own independent zoom and pan (only for Service Blueprint)
            // Milkyway Map is locked at 125% with no transform
            if (templateLayer && templateLayer.style.display !== 'none') {
                if (canvasState.canvasTemplate === 'milkyway-map') {
                    // Milkyway Map is locked - no transform applied
                    templateLayer.style.transform = 'none';
                    templateLayer.style.transformOrigin = '0 0';
                } else if (canvasState.canvasTemplate === 'service-blueprint') {
                    // Service Blueprint can still be transformed
                    templateLayer.style.transform = `translate(${canvasState.templatePanX}px, ${canvasState.templatePanY}px) scale(${canvasState.templateZoom})`;
                    templateLayer.style.transformOrigin = '0 0';
                }
            }
            // Update connections after a brief delay to ensure transform is applied
            setTimeout(() => debouncedUpdateConnections(), 10);
        }

        function getModelThumbnailStorageKey(modelId) {
            return `canvasModelThumbnail:${modelId}`;
        }

        function getStoredModelThumbnail(modelId) {
            if (!modelId) return null;
            return localStorage.getItem(getModelThumbnailStorageKey(modelId));
        }

        function generateModelThumbnailSvg(elements, relationships = []) {
            if (!elements || elements.length === 0) return null;
            const width = 180;
            const height = 120;
            const padding = 12;
            const minX = Math.min(...elements.map(e => e.x_position));
            const minY = Math.min(...elements.map(e => e.y_position));
            const maxX = Math.max(...elements.map(e => e.x_position + (e.width || 120)));
            const maxY = Math.max(...elements.map(e => e.y_position + (e.height || 120)));
            const spanX = Math.max(maxX - minX, 1);
            const spanY = Math.max(maxY - minY, 1);
            const scale = Math.min((width - padding * 2) / spanX, (height - padding * 2) / spanY);

            const positionMap = new Map();
            const rects = elements.map(e => {
                const x = (e.x_position - minX) * scale + padding;
                const y = (e.y_position - minY) * scale + padding;
                const w = Math.max((e.width || 120) * scale, 6);
                const h = Math.max((e.height || 120) * scale, 6);
                positionMap.set(e.id, { x, y, w, h });
                return `<rect x="${x.toFixed(1)}" y="${y.toFixed(1)}" width="${w.toFixed(1)}" height="${h.toFixed(1)}" rx="4" fill="#3e3e42" stroke="#667eea" stroke-width="1" />`;
            }).join('');

            const lines = relationships.map(rel => {
                const source = positionMap.get(rel.source_instance_id);
                const target = positionMap.get(rel.target_instance_id);
                if (!source || !target) return '';
                const x1 = source.x + source.w / 2;
                const y1 = source.y + source.h / 2;
                const x2 = target.x + target.w / 2;
                const y2 = target.y + target.h / 2;
                return `<line x1="${x1.toFixed(1)}" y1="${y1.toFixed(1)}" x2="${x2.toFixed(1)}" y2="${y2.toFixed(1)}" stroke="#7a7a90" stroke-width="1" />`;
            }).join('');

            const labels = elements.map(e => {
                const pos = positionMap.get(e.id);
                if (!pos) return '';
                const label = (e.instance_name || e.element_type || 'Element').toString().slice(0, 10);
                const x = pos.x + pos.w / 2;
                const y = pos.y + pos.h / 2 + 3;
                return `<text x="${x.toFixed(1)}" y="${y.toFixed(1)}" text-anchor="middle" font-family="Arial, sans-serif" font-size="7" fill="#e0e0e0">${label}</text>`;
            }).join('');

            return `
                <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
                    <rect x="0" y="0" width="${width}" height="${height}" fill="#1a1a1a"/>
                    ${lines}
                    ${rects}
                    ${labels}
                </svg>
            `;
        }

        function storeCurrentModelThumbnail() {
            if (!canvasState.currentModelId) return;
            const svg = generateModelThumbnailSvg(canvasState.elements, canvasState.relationships);
            if (!svg) return;
            const encoded = encodeURIComponent(svg).replace(/'/g, '%27').replace(/"/g, '%22');
            const dataUrl = `data:image/svg+xml,${encoded}`;
            localStorage.setItem(getModelThumbnailStorageKey(canvasState.currentModelId), dataUrl);
        }

        async function refreshPropertyPositionsAfterSave() {
            const images = canvasState.elements
                .map(e => document.getElementById(`element-image-${e.id}`))
                .filter(Boolean);
            const cachePromises = images.map(img => ensureSvgInsetCached(img.currentSrc || img.src));
            await Promise.all(cachePromises);
            requestAnimationFrame(() => {
                const elementIds = canvasState.elements.map(e => e.id);
                elementIds.forEach(id => updatePropertyPositionsForElement(id));
                updateConnections();
            });
        }

        const svgImageInsetCache = new Map();
        let svgInsetFetchInFlight = null;

        function getSvgContentBottomRatio(imageUrl) {
            return svgImageInsetCache.get(imageUrl)?.contentBottomRatio ?? null;
        }

        function ensureSvgInsetCached(imageUrl) {
            if (!imageUrl || !imageUrl.toLowerCase().endsWith('.svg')) return Promise.resolve();
            if (svgImageInsetCache.has(imageUrl)) return Promise.resolve();
            if (!svgInsetFetchInFlight) {
                svgInsetFetchInFlight = new Map();
            }
            if (svgInsetFetchInFlight.has(imageUrl)) return svgInsetFetchInFlight.get(imageUrl);

            const promise = fetch(imageUrl)
                .then(response => {
                    if (!response.ok) return null;
                    return response.text();
                })
                .then(svgText => {
                    if (!svgText) return;
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(svgText, 'image/svg+xml');
                    const svgEl = doc.documentElement;
                    const viewBox = svgEl.getAttribute('viewBox');
                    let viewBoxHeight = 0;
                    if (viewBox) {
                        const parts = viewBox.split(/\s+/).map(parseFloat);
                        viewBoxHeight = parts.length === 4 ? parts[3] : 0;
                    }
                    if (!viewBoxHeight) {
                        const heightAttr = svgEl.getAttribute('height');
                        viewBoxHeight = heightAttr ? parseFloat(heightAttr) : 0;
                    }
                    if (!viewBoxHeight) return;

                    const temp = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    temp.setAttribute('viewBox', viewBox || `0 0 100 ${viewBoxHeight}`);
                    temp.setAttribute('width', '0');
                    temp.setAttribute('height', '0');
                    temp.style.position = 'absolute';
                    temp.style.visibility = 'hidden';
                    temp.style.left = '-9999px';
                    temp.style.top = '-9999px';
                    const imported = document.importNode(svgEl, true);
                    while (imported.firstChild) {
                        temp.appendChild(imported.firstChild);
                    }
                    document.body.appendChild(temp);
                    const bbox = temp.getBBox();
                    temp.remove();
                    if (!bbox || bbox.height === 0) return;
                    const contentBottomRatio = (bbox.y + bbox.height) / viewBoxHeight;
                    svgImageInsetCache.set(imageUrl, { contentBottomRatio });
                })
                .catch(() => {});

            svgInsetFetchInFlight.set(imageUrl, promise);
            return promise.finally(() => {
                svgInsetFetchInFlight.delete(imageUrl);
            });
        }
        
        // Zoom controls
        function zoomCanvas(direction) {
            // Milkyway Map template is locked - no zooming allowed
            // Only allow zooming for Service Blueprint if selected
            if (canvasState.templateSelected && canvasState.canvasTemplate === 'service-blueprint') {
                canvasState.templateZoom = direction === 'in' 
                    ? Math.min(3.0, canvasState.templateZoom * 1.1)
                    : Math.max(0.2, canvasState.templateZoom * 0.9);
                localStorage.setItem('templateZoom', canvasState.templateZoom.toString());
                updateZoomDisplay();
                updateCanvasTransform();
            } else {
                // Otherwise, zoom elements as normal
                canvasState.zoom = direction === 'in' 
                    ? Math.min(2.0, canvasState.zoom * 1.1)
                    : Math.max(0.5, canvasState.zoom * 0.9);
                updateZoomDisplay();
                updateCanvasTransform();
            }
        }
        
        function updateZoomDisplay() {
            const zoomLevel = document.getElementById('zoomLevel');
            if (zoomLevel) {
                // Milkyway Map is locked - no template zoom display
                if (canvasState.templateSelected && canvasState.canvasTemplate === 'service-blueprint') {
                    zoomLevel.textContent = 'Template: ' + Math.round(canvasState.templateZoom * 100) + '%';
                    zoomLevel.style.color = '#ff6b9d'; // Pink to indicate template is selected
                } else {
                    zoomLevel.textContent = Math.round(canvasState.zoom * 100) + '%';
                    zoomLevel.style.color = '#ffffff'; // Reset to white
                }
            }
        }
        
        // Save canvas model
        async function saveCanvasModel() {
            // Store fullscreen state before opening modal
            const wasFullscreen = canvasState.isFullscreen;
            
            // If model was loaded, pre-fill the name
            if (canvasState.currentModelName) {
                document.getElementById('modelNameInput').value = canvasState.currentModelName;
            }
            document.getElementById('saveModelModal').style.display = 'flex';
            document.getElementById('modelNameInput').focus();
            
            // If modal causes fullscreen to exit, restore it after a short delay
            setTimeout(() => {
                if (wasFullscreen && !canvasState.isFullscreen) {
                    toggleFullscreen();
                }
            }, 100);
        }
        
        async function confirmSaveModel() {
            // Store fullscreen state before showing modal/alert
            const wasFullscreen = canvasState.isFullscreen;
            
            // If model was loaded, use its name; otherwise get from input
            let name = canvasState.currentModelName;
            if (!name) {
                name = document.getElementById('modelNameInput').value.trim();
                if (!name) {
                    showCanvasToast('Please enter a model name', 'error');
                    return;
                }
            }
            
            const modelData = {
                name: name,
                description: document.getElementById('modelDescriptionInput').value.trim(),
                canvas_width: 2000,
                canvas_height: 2000,
                zoom_level: canvasState.zoom,
                pan_x: canvasState.panX,
                pan_y: canvasState.panY,
                canvas_template: canvasState.canvasTemplate || 'none',
                template_zoom: canvasState.templateZoom || 1.0,
                template_pan_x: canvasState.templatePanX || 0,
                template_pan_y: canvasState.templatePanY || 0,
                template_segments: canvasState.templateSegments || [],
                elements: canvasState.elements.map(e => ({
                    element_type_id: e.element_type_id,
                    instance_name: e.instance_name,
                    description: e.description || null,
                    x_position: e.x_position,
                    y_position: e.y_position,
                    width: e.width,
                    height: e.height,
                    temp_id: e.id,
                    properties: e.properties || [] // Include instance properties
                })),
                relationships: canvasState.relationships,
                property_instances: canvasState.propertyInstances
                    .filter(p => p.source !== 'rules_engine' && p.rule_id == null)
                    .map(p => {
                        console.log('Saving property instance:', p);
                        return {
                            property_id: p.property_id,
                            element_instance_id: p.element_instance_id,
                            instance_name: p.instance_name,
                            x_position: p.x_position,
                            y_position: p.y_position,
                            width: p.width,
                            height: p.height,
                            temp_id: p.id
                        };
                    })
            };
            
            try {
                const url = canvasState.currentModelId 
                    ? `/api/canvas/models/${canvasState.currentModelId}`
                    : '/api/canvas/models';
                const method = canvasState.currentModelId ? 'PUT' : 'POST';
                
                console.log('Saving model with data:', {
                    elements: modelData.elements.length,
                    relationships: modelData.relationships.length,
                    property_instances: modelData.property_instances.length,
                    property_instances_data: modelData.property_instances
                });
                
                const response = await fetch(url, {
                    method: method,
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(modelData)
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    console.error('Error saving model:', errorData);
                    showCanvasToast(`Error saving model: ${errorData.error || 'Unknown error'}`, 'error');
                    return;
                }
                
                const result = await response.json();
                if (!canvasState.currentModelId) {
                    canvasState.currentModelId = result.id;
                    canvasState.currentModelName = name;
                }
                
                // Evaluate all active design rules after model is saved
                try {
                    const previousRuleProps = getAllRuleGeneratedPropsFromCanvas();
                    const previousElementProps = getAllCanvasOccurrencePropsFromCanvas();
                    const previousViolations = await fetchDesignRuleViolations();
                    await fetch('/api/analytics/design-rules/evaluate-all', { method: 'POST' });
                    // Refresh design rules display if analytics modal is open
                    if (isRepositoryTabActive('analytics')) {
                        loadDesignRulesAndViolations();
                    }
                    await runEdglyRuleUpdateCheck(previousRuleProps, previousViolations, previousElementProps, { refreshProperties: false });
                } catch (error) {
                    console.error('Error evaluating design rules after save:', error);
                }
                
                storeCurrentModelThumbnail();
                closeSaveModal();
                showCanvasToast('Model saved successfully!', 'success');
            } catch (error) {
                showCanvasToast('Error saving model: ' + error.message, 'error');
            }
        }
        
        function closeSaveModal() {
            const wasFullscreen = canvasState.isFullscreen;
            document.getElementById('saveModelModal').style.display = 'none';
            document.getElementById('modelNameInput').value = '';
            document.getElementById('modelDescriptionInput').value = '';
            
            // Restore fullscreen if it was active before modal was shown
            if (wasFullscreen && !canvasState.isFullscreen) {
                setTimeout(() => {
                    if (!canvasState.isFullscreen) {
                        toggleFullscreen();
                    }
                }, 100);
            }
        }
        
        // Load canvas models
        async function loadCanvasModels() {
            // Store fullscreen state before opening modal
            const wasFullscreen = canvasState.isFullscreen;
            
            try {
                const response = await fetch('/api/canvas/models');
                const models = await response.json();
                
                const list = document.getElementById('savedModelsList');
                list.innerHTML = '';
                
                if (models.length === 0) {
                    list.innerHTML = '<div style="color: #b0b0d0; padding: 20px; text-align: center;">No saved models</div>';
                } else {
                    models.forEach(model => {
                        const item = document.createElement('div');
                        item.style.cssText = `
                            padding: 15px;
                            background: #1e1e1e;
                            border: 1px solid rgba(255,255,255,0.1);
                            border-radius: 6px;
                            margin-bottom: 10px;
                            cursor: pointer;
                            transition: all 0.2s;
                        `;
                        item.innerHTML = `
                            <div style="color: #ffffff; font-weight: 600; margin-bottom: 5px;">${escapeHtml(model.name)}</div>
                            ${model.description ? `<div style="color: #b0b0d0; font-size: 12px;">${escapeHtml(model.description)}</div>` : ''}
                            <div style="color: #888; font-size: 11px; margin-top: 5px;">
                                Updated: ${new Date(model.updated_at).toLocaleString()}
                            </div>
                        `;
                        
                        item.addEventListener('mouseenter', () => {
                            item.style.background = '#252550';
                        });
                        item.addEventListener('mouseleave', () => {
                            item.style.background = '#1e1e1e';
                        });
                        
                        item.addEventListener('click', () => {
                            loadCanvasModel(model.id);
                        });
                        
                        list.appendChild(item);
                    });
                }
                
                document.getElementById('loadModelModal').style.display = 'flex';
                
                // If modal causes fullscreen to exit, restore it after a short delay
                setTimeout(() => {
                    if (wasFullscreen && !canvasState.isFullscreen) {
                        toggleFullscreen();
                    }
                }, 100);
            } catch (error) {
                showCanvasToast('Error loading models: ' + error.message, 'error');
            }
        }
        
        async function loadCanvasModel(modelId) {
            try {
                const response = await fetch(`/api/canvas/models/${modelId}`);
                if (!response.ok) {
                    throw new Error('Failed to load model');
                }
                
                const model = await response.json();
                
                // Clear current canvas (including any previous template)
                clearCanvas();
                
                // Set canvas state
                canvasState.currentModelId = model.id;
                canvasState.currentModelName = model.name; // Store model name
                canvasState.zoom = model.zoom_level || 1.0;
                canvasState.panX = model.pan_x || 0;
                canvasState.panY = model.pan_y || 0;
                
                // Load template configuration if available
                if (model.canvas_template && model.canvas_template !== 'none') {
                    canvasState.canvasTemplate = model.canvas_template;
                    // Milkyway Map is locked at 125% - ignore saved zoom/pan values
                    if (canvasState.canvasTemplate === 'milkyway-map') {
                        canvasState.templateZoom = 1.0;
                        canvasState.templatePanX = 0;
                        canvasState.templatePanY = 0;
                    } else {
                        canvasState.templateZoom = model.template_zoom || 1.0;
                        canvasState.templatePanX = model.template_pan_x || 0;
                        canvasState.templatePanY = model.template_pan_y || 0;
                    }
                    localStorage.setItem('canvasTemplate', model.canvas_template);
                } else {
                    // Ensure template is cleared if model has no template
                    clearTemplate();
                }
                
                // Load template segments and associations
                if (model.template_segments && model.template_segments.length > 0) {
                    canvasState.templateSegments = model.template_segments;
                    canvasState.templateSegmentCount = model.template_segments.length || 4;
                } else {
                    canvasState.templateSegments = [];
                    canvasState.templateSegmentCount = 4;
                    await loadTemplateSegments();
                }
                await loadElementSegmentAssociations();
                
                // Apply template after loading all configuration
                if (model.canvas_template && model.canvas_template !== 'none') {
                    applyCanvasTemplate(model.canvas_template);
                }
                
                // Load elements
                model.elements.forEach(elem => {
                    // Ensure element_type is correct - use the value from database
                    const elementType = elem.element_type || 'Unknown';
                    console.log('Loading element from model:', {
                        id: elem.id,
                        element_type_id: elem.element_type_id,
                        element_type: elementType,
                        instance_name: elem.instance_name
                    });
                    
                    canvasState.elements.push({
                        id: elem.id,
                        element_type_id: elem.element_type_id,
                        element_type: elementType,
                        instance_name: elem.instance_name,
                        description: elem.description || null,
                        x_position: snapElementToGrid(elem.x_position, elem.y_position, elem.width || 120, elem.height || 120).x,
                        y_position: snapElementToGrid(elem.x_position, elem.y_position, elem.width || 120, elem.height || 120).y,
                        width: elem.width,
                        height: elem.height,
                        image_url: elem.element_image_url || `/images/Shape-${elementType}.svg`,
                        properties: elem.properties || [] // Load instance properties
                    });
                    renderElement(canvasState.elements[canvasState.elements.length - 1]);
                });
                
                // Load property instances
                if (model.property_instances && model.property_instances.length > 0) {
                    let maxPropertyInstanceId = 0;
                    model.property_instances.forEach(prop => {
                        const propInstance = {
                            id: prop.id,
                            property_id: prop.property_id,
                            element_instance_id: prop.element_instance_id,
                            instance_name: prop.instance_name,
                            x_position: prop.x_position,
                            y_position: prop.y_position,
                            width: prop.width,
                            height: prop.height,
                            propertyname: prop.propertyname,
                            ragtype: prop.ragtype,
                            image_url: prop.image_url,
                            source: prop.source,
                            rule_id: prop.rule_id,
                            isDropped: false // Loaded properties are editable (not dropped)
                        };
                        canvasState.propertyInstances.push(propInstance);
                        renderPropertyInstance(propInstance);
                        // Track max ID for nextPropertyInstanceId
                        if (prop.id > maxPropertyInstanceId) {
                            maxPropertyInstanceId = prop.id;
                        }
                    });
                    // Set nextPropertyInstanceId to max + 1 to avoid conflicts
                    canvasState.nextPropertyInstanceId = maxPropertyInstanceId + 1;
                }
                
                // Load relationships
                model.relationships.forEach(rel => {
                    canvasState.relationships.push({
                        source_instance_id: rel.source_instance_id,
                        target_instance_id: rel.target_instance_id,
                        relationship_type: rel.relationship_type
                    });
                });
                
                updateZoomDisplay();
                updateCanvasTransform();
                updateCanvasInfo();
                
                const previousRuleProps = getAllRuleGeneratedPropsFromCanvas();
                const previousElementProps = getAllCanvasOccurrencePropsFromCanvas();
                let previousViolations = [];
                try {
                    const violationResponse = await fetch('/api/analytics/design-rules/violations');
                    if (violationResponse.ok) {
                        previousViolations = await violationResponse.json();
                    }
                } catch (error) {
                    console.warn('EDGly debug: unable to fetch previous violations', error);
                }
                updateEdglyCommentaryBubble('', false);
                // Evaluate all active design rules after model is loaded
                try {
                    await fetch('/api/analytics/design-rules/evaluate-all', { method: 'POST' });
                    // Refresh design rules display if analytics modal is open
                    if (isRepositoryTabActive('analytics')) {
                        loadDesignRulesAndViolations();
                    }
                    await new Promise(resolve => setTimeout(resolve, 250));
                    const changeSummary = await refreshRuleGeneratedProperties(previousRuleProps, { skipEvaluate: true });
                    let nextViolations = [];
                    try {
                        const violationResponse = await fetch('/api/analytics/design-rules/violations');
                        if (violationResponse.ok) {
                            nextViolations = await violationResponse.json();
                        }
                    } catch (error) {
                        console.warn('EDGly debug: unable to fetch updated violations', error);
                    }
                    const violationSummary = summarizeViolationColorChanges(previousViolations, nextViolations);
                    const elementPropSummary = summarizeElementPropertyColorChanges(previousElementProps, getAllCanvasOccurrencePropsFromCanvas());
                    showEdglyChangeNotification(changeSummary, violationSummary, elementPropSummary);
                } catch (error) {
                    console.error('Error evaluating design rules after load:', error);
                }
                
                setTimeout(storeCurrentModelThumbnail, 200);
                closeLoadModal();
            } catch (error) {
                showCanvasToast('Error loading model: ' + error.message, 'error');
            }
        }
        
        function closeLoadModal() {
            const wasFullscreen = canvasState.isFullscreen;
            document.getElementById('loadModelModal').style.display = 'none';
            
            // Restore fullscreen if it was active before modal was shown
            if (wasFullscreen && !canvasState.isFullscreen) {
                setTimeout(() => {
                    if (!canvasState.isFullscreen) {
                        toggleFullscreen();
                    }
                }, 100);
            }
        }
        
        // Clear template state and DOM
        function clearTemplate() {
            // Reset template state
            canvasState.canvasTemplate = 'none';
            canvasState.templateZoom = 1.0;
            canvasState.templatePanX = 0;
            canvasState.templatePanY = 0;
            canvasState.templateSegments = [];
            canvasState.templateSegmentCount = 4;
            canvasState.templateSelected = false;
            canvasState.elementSegmentAssociations = {};
            
            // Clear template layer DOM
            const templateLayer = document.getElementById('templateLayer');
            if (templateLayer) {
                templateLayer.style.display = 'none';
                templateLayer.innerHTML = '';
            }
            
            // Apply 'none' template to clear visuals
            if (typeof applyCanvasTemplate === 'function') {
                applyCanvasTemplate('none');
            }
        }
        
        // Clear canvas
        function clearCanvas() {
            saveStateForUndo(); // Save state before clearing
            canvasState.elements = [];
            canvasState.relationships = [];
            canvasState.propertyInstances = [];
            canvasState.nextElementId = 1;
            canvasState.nextPropertyInstanceId = 1;
            canvasState.currentModelId = null;
            canvasState.currentModelName = null;
            canvasState.selectedElementIds = [];
            document.getElementById('elementsLayer').innerHTML = '';
            document.getElementById('propertyInstancesLayer').innerHTML = '';
            document.getElementById('connectionsLayer').innerHTML = '';
            
            // Clear template when clearing canvas
            clearTemplate();
            
            updateCanvasInfo();
            updateUndoRedoButtons();
        }
        
        // ========================================================================
        // Undo/Redo Functionality
        // ========================================================================
        
        // Save current state for undo (max 3 states)
        function saveStateForUndo() {
            const state = {
                elements: JSON.parse(JSON.stringify(canvasState.elements)),
                relationships: JSON.parse(JSON.stringify(canvasState.relationships)),
                propertyInstances: JSON.parse(JSON.stringify(canvasState.propertyInstances)),
                nextElementId: canvasState.nextElementId,
                nextPropertyInstanceId: canvasState.nextPropertyInstanceId
            };
            
            canvasState.undoHistory.push(state);
            if (canvasState.undoHistory.length > 3) {
                canvasState.undoHistory.shift(); // Remove oldest
            }
            
            // Clear redo history when new action is performed
            canvasState.redoHistory = [];
            updateUndoRedoButtons();
        }
        
        // Undo last action
        function undoCanvasAction() {
            if (canvasState.undoHistory.length === 0) return;
            
            // Save current state to redo
            const currentState = {
                elements: JSON.parse(JSON.stringify(canvasState.elements)),
                relationships: JSON.parse(JSON.stringify(canvasState.relationships)),
                propertyInstances: JSON.parse(JSON.stringify(canvasState.propertyInstances)),
                nextElementId: canvasState.nextElementId,
                nextPropertyInstanceId: canvasState.nextPropertyInstanceId
            };
            canvasState.redoHistory.push(currentState);
            
            // Restore previous state
            const previousState = canvasState.undoHistory.pop();
            canvasState.elements = previousState.elements || [];
            canvasState.relationships = previousState.relationships || [];
            canvasState.propertyInstances = previousState.propertyInstances || [];
            canvasState.nextElementId = previousState.nextElementId || 1;
            canvasState.nextPropertyInstanceId = previousState.nextPropertyInstanceId || 1;
            
            // Re-render canvas
            document.getElementById('elementsLayer').innerHTML = '';
            document.getElementById('propertyInstancesLayer').innerHTML = '';
            canvasState.elements.forEach(elem => renderElement(elem));
            canvasState.propertyInstances.forEach(prop => renderPropertyInstance(prop));
            debouncedUpdateConnections();
            updateCanvasInfo();
            updateUndoRedoButtons();
        }
        
        // Redo last undone action
        function redoCanvasAction() {
            if (canvasState.redoHistory.length === 0) return;
            
            // Save current state to undo
            const currentState = {
                elements: JSON.parse(JSON.stringify(canvasState.elements)),
                relationships: JSON.parse(JSON.stringify(canvasState.relationships)),
                propertyInstances: JSON.parse(JSON.stringify(canvasState.propertyInstances)),
                nextElementId: canvasState.nextElementId,
                nextPropertyInstanceId: canvasState.nextPropertyInstanceId
            };
            canvasState.undoHistory.push(currentState);
            
            // Restore redo state
            const redoState = canvasState.redoHistory.pop();
            canvasState.elements = redoState.elements || [];
            canvasState.relationships = redoState.relationships || [];
            canvasState.propertyInstances = redoState.propertyInstances || [];
            canvasState.nextElementId = redoState.nextElementId || 1;
            canvasState.nextPropertyInstanceId = redoState.nextPropertyInstanceId || 1;
            
            // Re-render canvas
            document.getElementById('elementsLayer').innerHTML = '';
            document.getElementById('propertyInstancesLayer').innerHTML = '';
            canvasState.elements.forEach(elem => renderElement(elem));
            canvasState.propertyInstances.forEach(prop => renderPropertyInstance(prop));
            debouncedUpdateConnections();
            updateCanvasInfo();
            updateUndoRedoButtons();
        }
        
        // Update undo/redo button states
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            
            if (undoBtn) {
                undoBtn.disabled = canvasState.undoHistory.length === 0;
                undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1';
            }
            
            if (redoBtn) {
                redoBtn.disabled = canvasState.redoHistory.length === 0;
                redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1';
            }
        }
        
        // ========================================================================
        // Multi-Select Functionality
        // ========================================================================
        
        // Handle element selection (Ctrl+Click for multi-select)
        function handleElementSelectionMultiSelect(elementId, event) {
            if (!event) {
                // Single select
                canvasState.selectedElementIds = [elementId];
                updateElementSelection();
                return;
            }
            
            if (event.ctrlKey || event.metaKey) {
                // Multi-select: toggle selection
                const index = canvasState.selectedElementIds.indexOf(elementId);
                if (index > -1) {
                    canvasState.selectedElementIds.splice(index, 1);
                } else {
                    canvasState.selectedElementIds.push(elementId);
                }
            } else {
                // Single select
                canvasState.selectedElementIds = [elementId];
            }
            
            updateElementSelection();
        }
        
        // Update visual selection indicators
        function updateElementSelection() {
            canvasState.elements.forEach(elem => {
                const elementDiv = document.getElementById(`element-${elem.id}`);
                if (elementDiv) {
                    const border = elementDiv.querySelector(`#element-border-${elem.id}`);
                    if (border) {
                        if (canvasState.selectedElementIds.includes(elem.id)) {
                            border.style.borderColor = '#667eea';
                            border.style.borderWidth = '3px';
                        } else {
                            border.style.borderColor = 'transparent';
                            border.style.borderWidth = '2px';
                        }
                    }
                }
            });
        }
        
        // Delete selected element instances
        function deleteSelectedElements() {
            if (canvasState.selectedElementIds.length === 0) return;
            
            saveStateForUndo(); // Save state before deletion
            
            // Delete all selected elements
            const idsToDelete = [...canvasState.selectedElementIds];
            idsToDelete.forEach(elementId => {
                // Remove element from state
                canvasState.elements = canvasState.elements.filter(e => e.id !== elementId);
                
                // Remove relationships involving this element
                canvasState.relationships = canvasState.relationships.filter(r => 
                    r.source_instance_id !== elementId && r.target_instance_id !== elementId
                );
                
                // Remove element from DOM
                const elementDiv = document.getElementById(`element-${elementId}`);
                if (elementDiv) {
                    elementDiv.remove();
                }
            });
            
            // Clear selection
            canvasState.selectedElementIds = [];
            
            // Update connections
            debouncedUpdateConnections();
            updateCanvasInfo();
            updateUndoRedoButtons();
        }
        
        // ========================================================================
        // Updated Functions
        // ========================================================================
        
        
    </script>
</body>
</html>





























